# Phục hồi ứng dụng trong Microservices (Resilience in Microservices)
## 1. Giới thiệu
Trong môi trường Microservices, việc phục hồi ứng dụng là một vấn đề quan trọng. Một số vấn đề có thể xảy ra như: một số service không hoạt động, mạng không ổn định, lỗi xảy ra khi gọi service khác, ... Để giải quyết vấn đề này, chúng ta cần phải xây dựng một hệ thống có khả năng phục hồi khi xảy ra lỗi.

Để giải quyết vấn đề này, chúng ta cần phải xây dựng một hệ thống có khả năng phục hồi khi xảy ra lỗi. Có một số cách để giải quyết vấn đề này như: Circuit Breaker, Retry, Timeout, Bulkhead, ... Trong bài viết này, chúng ta sẽ tìm hiểu về các cách giải quyết vấn đề phục hồi ứng dụng trong môi trường Microservices.

Công cụ sử dụng: `Resilience4j` - một thư viện Java giúp xây dựng các cơ chế phục hồi ứng dụng. [Resilience4j](https://resilience4j.readme.io/docs/getting-started-6)

## 2. Circuit Breaker
`Circuit Breaker` là một cơ chế giúp hệ thống `tự động ngắt kết nối` tới một `service` khi service đó `gặp lỗi`. Khi service bị lỗi, `Circuit Breaker` sẽ ngắt kết nối tới service đó và trả về một giá trị mặc định hoặc báo lỗi. Khi service đã được sửa, `Circuit Breaker` sẽ mở lại kết nối tới service đó.

Lợi ích của `Circuit Breaker`:
- `Fail fast`: Nhận biết lỗi nhanh chóng và ngắt kết nối tới service đó.
- `Fail gracefully`: Làm giảm áp lực cho service khác khi service đó gặp lỗi.
- `Recovery seamlessly`: Khi service đã được sửa, `Circuit Breaker` sẽ mở lại kết nối tới service đó.

### 2.1. 3 trạng thái của Circuit Breaker
Trong `Resilience4j`, `Circuit Breaker` có 3 trạng thái:
- `CLOSED`: Khi `Circle Breaker` mới bắt đầu, nó sẽ ở trạng thái `CLOSED`. Trong trạng thái này, `Circuit Breaker` sẽ cho phép gọi tới service từ các request của client.
- `OPEN`: Khi service gặp lỗi, ví dụ tỷ lệ lỗi vượt quá một ngưỡng nào đó, `Circuit Breaker` sẽ chuyển sang trạng thái `OPEN`. Trong trạng thái này, `Circuit Breaker` sẽ ngắt kết nối tới service và trả về một giá trị mặc định hoặc báo lỗi.
- `HALF_OPEN`: Sau một khoảng thời gian, `Circuit Breaker` sẽ chuyển sang trạng thái `HALF_OPEN`. Trong trạng thái này, `Circuit Breaker` sẽ thử kết nối tới service và cho phép 1 số lượng `request từ client` nhất định. Dần dần tăng lên, nếu tỷ lệ lỗi ở dưỡi ngưỡng cho phép, `Circuit Breaker` sẽ chuyển sang trạng thái `CLOSED`. Nếu kết nối không thành công, `Circuit Breaker` sẽ về lại trạng thái `OPEN`.

### 2.2. Cài đặt Circuit Breaker
Để cài đặt `Circuit Breaker` với `Resilience4j`, trước hết chúng ta phải có `Gateway` để quản lý các request từ client. Sau đó, chúng ta cài đặt `Circuit Breaker` cho các service mà `Gateway` gọi tới.

>Cách cài đặt `Spring Cloud Gateway` đã được trình bày trong bài `26. Giao tiếp từ bên ngoài vào trong Microsevices`

#### 2.2.1. Cài đặt Circuit Breaker trong `Gateway`
Cần cài đặt `dependency` của `Resilience4j` trong `pom.xml`:
```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-circuitbreaker-reactor-resilience4j</artifactId>
</dependency>
```

Cấu hình `Circuit Breaker` trong `application.yml` của `Gateway Service`:
>application.yml
```yml
...
resilience4j:
  circuitbreaker:
    configs:
      default:
        sliding-window-size: 10 # So luong request ma circuit breaker se kiem tra de xem service co bi loi hay khong
        permitted-number-of-calls-in-half-open-state: 2 # So luong request cho phep khi service dang trong trang thai half-open, de kiem tra service co hoat dong lai hay khong
        failure-rate-threshold: 50 # Ty le loi cho phep cua service, neu ty le loi > 50% thi circuit breaker OPEN
        wait-duration-in-open-state:
          seconds: 10 # Thoi gian cho phep service chuyen sang HALF-OPEN de kiem tra lai service tu khi circuit breaker chuyen sang OPEN
```
Tiếp theo, thêm 1 số cầu hình của `Circuit Breaker` vào trong bộ lọc `filter` của `Spring Cloud Gateway`, để kiểm tra service có bị lỗi hay không:
>Application.java
```java
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        Application.run(Application.class, args);
    }

    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
        return builder.routes()
                .route("service1", r -> r.path("/service1/**")
                        .filters(f -> 
                            f.circuitBreaker(c -> c.setName("service1") // Ten cua circuit breaker
                                            .setFallbackUri("forward:/contactSupport") // Duong dan khi service bi loi, đã được định nghĩa trong Controller
                                            )
                                )
                        .uri("http://localhost:8081")) 
                .build();
    }
}
```

Sau khi chạy lần lượt `Config Server`, `Euroka Server`, `Service con`, `Gateway`, truy cập vào đường dẫn đại diện cho `Gateway` (ví dụ: `http://localhost:8072/actuator`) để kiểm tra các route của `circuit breaker`.
- `http://localhost:8072/actuator/circuitbreakers`: Hiển thị tất cả các `Circuit Breaker` của `Gateway` và trạng thái của chúng.
```json
{
  "circuitBreakers": {
    "accountsCircuitBreaker": {
      "failureRate": "-1.0%", // Tỷ lệ lỗi của service
      "slowCallRate": "-1.0%", // Tỷ lệ gọi service chậm
      "failureRateThreshold": "50.0%",  // Ngưỡng tỷ lệ lỗi
      "slowCallRateThreshold": "100.0%", // Ngưỡng tỷ lệ gọi service chậm
      "bufferedCalls": 1, // Số lượng request đã gọi tới service
      "failedCalls": 0, // Số lượng request gọi tới service bị lỗi
      "slowCalls": 0, // Số lượng request gọi tới service chậm
      "slowFailedCalls": 0, // Số lượng request gọi tới service chậm bị lỗi
      "notPermittedCalls": 0, // Số lượng request không được phép gọi tới service
      "state": "CLOSED" // Trạng thái của Circuit Breaker
    }
  }
}
```
- `http://localhost:8072/actuator/circuitbreakerevent/{name_circuitBreaker}`: Hiển thị tất cả các sự kiện của `Circuit Breaker` với tên `name_circuitBreaker`.
```json
{
  "circuitBreakerEvents": [
    {
      "circuitBreakerName": "accountsCircuitBreaker", // Tên của Circuit Breaker
      "type": "SUCCESS", // Loại sự kiện (SUCCESS, ERROR, IGNORED_ERROR, STATE_TRANSITION)
      // SUCCESS: Khi request gọi tới service thành công
      // ERROR: Khi request gọi tới service bị lỗi
      // IGNORED_ERROR: Khi request gọi tới service bị lỗi nhưng không được xuất ra
      // STATE_TRANSITION: Khi trạng thái của Circuit Breaker thay đổi (VD: OPEN -> HALF_OPEN)
      "creationTime": "2024-07-15T01:38:51.070389700+07:00[Asia/Saigon]", // Thời gian tạo sự kiện
      "errorMessage": null, // Thông báo lỗi
      "durationInMs": 277, // Thời gian thực hiện request
      "stateTransition": null // Trạng thái chuyển đổi
    }
  ]
}
```

Tiếp theo, chúng ta sẽ khai báo đường dẫn `forward:/contactSupport` trong `Controller` để trả về một giá trị mặc định hoặc báo lỗi khi service bị lỗi:
>Controller.java
```java
@RestController
public class CircuitBreakerController {
    @GetMapping("/contactSupport")
    Mono<String> contactSupport() {
        return Mono.just("Service is not available. Please contact support.");
    }
    // Trong đó, Object Mono là một kiểu dữ liệu của Reactor, giúp xử lý bất đồng bộ trong Spring WebFlux, với Gateway thì sử dụng Mono
    // Mono.just() là một phương thức tạo một Mono với giá trị được truyền vào
}
```
Như vậy, khi service bị lỗi, `Circuit Breaker` sẽ forward request tới đường dẫn `/contactSupport` và trả về giá trị `Service is not available. Please contact support.`

#### 2.2.2. Cài đặt Circuit Breaker trong `Service` con (Chỉ trong `Service 1` giao tiếp với các service khác qua `OpenFeign`)
Cài đặt `dependency` của `Resilience4j` trong `pom.xml`, **Lưu ý** dependency này phải được cài đặt trong `Service` con giao tiếp với các service khác qua `OpenFeign`, và khác với `Gateway`, không phải là `circuitbreaker-reactor-resilience4j` mà là `circuitbreaker-resilience4j`:
```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-circuitbreaker-resilience4j</artifactId>
</dependency>
```

Cấu hình `Circuit Breaker` trong `application.yml` của `Service` con:
>application.yml
```yml
spring:
  cloud:
   openfeign:
     circuitbreaker:
      enabled: true # Cho phép sử dụng circuit breaker cho Feign client

## Circuit Breaker Configuration
resilience4j:
 circuitbreaker:
  configs:
   default:
    sliding-window-size: 10 # So luong request ma circuit breaker se kiem tra de xem service co bi loi hay khong
    permitted-number-of-calls-in-half-open-state: 2 # So luong request cho phep khi service dang trong trang thai half-open, de kiem tra service co hoat dong lai hay khong
    failure-rate-threshold: 50 # Ty le loi cho phep cua service, neu ty le loi > 50% thi circuit breaker OPEN
    wait-duration-in-open-state:
     seconds: 10 # Thoi gian cho phep service chuyen sang HALF-OPEN de kiem tra lai service tu khi circuit breaker chuyen sang OPEN
```

Sau đó, cấu hình `Circuit Breaker` cho `Feign Client` trong `Service` con:
- Tạo 1 `Bean` của `FeignClient` implement `Feign Client` để trả về `Fallback` khi service bị lỗi (Lưu ý phải tắt `fallback` của bên `Gateway` thì mới có thể sử dụng `fallback` của `Service` con):
>LoansFallback.java
```java
@Component // Đánh dấu đây là một Bean
public class LoansFallback implements LoansClient { // implement Feign Client
    @Override // Override phương thức của Feign Client
    public ResponseEntity<LoansDto> fetchLoanDetails(String correlationId, String mobileNumber) {
      // Logic code để xử lý khi service bị lỗi hoặc trả về null
      return null; // Method fallback sẽ trả về null, cache, hoặc giá trị mặc định trong database nếu như service loans không hoạt động
    }
}
```
- Cấu hình `Feign Client` để chỉ đến class `Fallback` trong `Service` con:
>LoansClient.java
```java
@FeignClient(name = "loans", fallback = LoansFallback.class) // fallback = LoansFallback.class: chỉ đến class Fallback trong Service con
// name = "loans": Tên của service cần gọi
public interface LoansClient {
    @GetMapping("/loans/{correlationId}/{mobileNumber}")
    ResponseEntity<LoansDto> fetchLoanDetails(@PathVariable String correlationId, @PathVariable String mobileNumber);
}
```
Như vậy, khi service `loans` bị lỗi, `Feign Client` sẽ gọi tới class `LoansFallback` để xử lý, trả về giá trị của phương thức `fetchLoanDetails` trong class `LoansFallback`.

