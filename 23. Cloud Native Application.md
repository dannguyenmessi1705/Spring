# Cloud Native Application
## 1. Giới thiệu
`Cloud Native Application` là ứng dụng được thiết kế để chạy trên `Cloud` (đặc biệt là `Cloud Public`) với các đặc điểm:
- `Microservice`: ứng dụng được chia nhỏ thành các `service` nhỏ.
- `Container`: ứng dụng được đóng gói thành `container` để chạy trên môi trường khác nhau.
- `DevOps`: quá trình phát triển và vận hành ứng dụng được tự động hóa.
- `Continuous Delivery`: quá trình phát triển và vận hành ứng dụng được liên tục cập nhật.
- `Resilient`: ứng dụng có khả năng chịu lỗi.
- `Scalable`: ứng dụng có khả năng mở rộng.

## 2. Sự khác nhau giữa Cloud Native Application và Traditional Application
| Cloud Native Application | Traditional Application |
|:-------------------------:|:-----------------------:|
| Các hành vi có thể dự đoán được (lỗi, mất kết nối, ...) do sử dụng kiến trúc `Microservices` | Các hành vi không thể dự đoán được do sử dụng kiến trúc `Monolithic` |
| Không phụ thuộc vào `hệ điều hành` | Phụ thuộc vào `hệ điều hành` |
| Kích thước hợp lý | Cos thể gây ra oversize do chứa nhiều thư viện không cần thiết |
| Dễ dàng phát triển và triển khai | Khó khăn trong việc phát triển và triển khai do mô hình hoạt động dựa trên `waterfall` |
| Có khả năng hồi phục nhanh, tự động mở rộng | Khó khăn trong việc hồi phục nhanh, mở rộng do phải thực hiện thủ công |

## 3. 15 nguyên tắc để xây dựng Cloud Native Application
### 3.1. `One Codebase, One Application` (Một mã nguồn cho một ứng dụng)
- Một mã nguồn cho một ứng dụng giúp dễ dàng quản lý và triển khai ứng dụng.
- Trong một ứng dụng có nhiều môi trường, chúng ta cần phải tạo ra nhiều `config` khác nhau để phù hợp với từng môi trường. Tuy nhiên chỉ cần một mã nguồn duy nhất, tránh lãng phí tài nguyên.

### 3.2. `API First` (API là trước hết)
- Khi xây dựng ứng dụng, chúng ta cần xác định `API` trước, sau đó mới xây dựng ứng dụng dựa trên `API` đó.
- `API` giúp chúng ta dễ dàng mở rộng ứng dụng, tạo ra các ứng dụng khác dựa trên `API` đã xác định.

### 3.3. `Dependency Management` (Quản lý phụ thuộc)
- Đảm bảo rằng tất cả các phụ thuộc của ứng dụng đều có thể dễ dàng tìm kiếm và tải về tự động từ một kho lưu trữ phụ thuộc.
- Ví dụ với `Spring Boot`, người dùng chỉ cần thêm `dependency` vào file `pom.xml`, sau đó `Maven` sẽ tự động tải về và cài đặt `dependency` đó.

### 3.4. `Design, build, release, run`
- `Design stage`: Thiết kế ứng dụng, xác định các `technology stack`, `tools` và `dependences` sẽ sử dụng trong ứng dụng.
- `Build stage`: Quá trình `compile` và đóng gói mã nguồn với các `dependency`, tạo số bản dựng `artifactId` duy nhất trong mỗi lần `build`.
- `Release stage`: Kết hợp `build` với 1 số thông số cấu hình cụ thể. Mỗi bản phát hành sẽ có một `version` riêng biệt. Các trung tâm cơ sở kho lưu trữ dễ dàng truy cập, bao gồm cả việc `rollback` nếu cần.
- `Run stage`: Chạy ứng dụng trong môi trường đã được thiết kế sử dụng một bản phát hành cụ thể.

### 3.5. `Configuration, credentials, and code` (Cấu hình, thông tin xác thực và mã nguồn)
- `Configuration` bao gồm tất cả các yếu tố làm thay đổi giữa các lần triển khai (môi trường, cổng kết nối, database, thông tin xác thực API bên thứ 3). Nó nhấn mạnh khả năng sửa đổi `cấu hình` ứng dụng một cách độc lập mà không cần phải `build` lại ứng dụng.
- Các cấu hình, credentials không được phép nhúng vào trong mã nguồn, mà phải được lưu trữ trong một file, kho lưu trữ cấu hình riêng biệt (ngoại trừ cấu hình mặc định). Vì vậy phương pháp khuyến nghị là sử dụng các biến môi trường để lưu trữ các thông tin này.


### 3.6. `Logs` (Nhật ký)
- `Logs` là một phần quan trọng trong việc theo dõi và phân tích ứng dụng.
- Trong `Cloud Native App`, `Logs` không phải là mối quan tâm của ứng dụng.
- Các ứng dụng này sẽ chuyên tiếp `logs` của chúng tới các đầu ra tiêu chuẩn, coi là 1 sự kiện được sắp xếp tuần tự theo thời gian.
- Trách nhiệm ghi, lưu trữ `logs` được chuyển sang các dịch vụ bên ngoài quản lý `logs` như `ELK`, `Splunk`, `Loggly`, ... 

### 3.7. `Disposability` (Khả năng tiêu hủy)
- Đối với `Cloud Native App`, ứng dụng không cần thiết phải duy trì liên tục.
- Nếu có lỗi xảy ra hoặc ứng dụng không phản hồi, ứng dụng có thể tự chấm dứt và thay thế bằng phiên bản mới.
- Trong lúc tải cao, ứng dụng cũng có thể tách ra để xử lý các yêu cầu khác nhau. Chúng có thể tự động start và stop mà không cần sự can thiệp của con người.
- Để giảm vấn đề về hiệu suất, ứng dụng phải có cơ chế `fast startup` và `graceful shutdown`.
- Quá trình `graceful shutdown` bao gồm việc:
    + Ứng dụng nhận được tín hiệu `shutdown`.
    + Ngừng nhận các yêu cầu mới.
    + Xử lý các yêu cầu còn đang chờ.
    + Đóng tất cả các kết nối.

### 3.8. `Backing Services` (Dịch vụ hậu cần)
- `Backing Services` đề cập tới các dịch vụ mà ứng dụng của bạn cần để hoạt động (database, message broker, ...).
- Bằng cách coi những dịch vụ này như 1 `tài nguyên đính kèm`, chúng ta có thể sửa đổi, thay thế chúng mà không cần phải sửa đổi mã nguồn của ứng dụng.
- Ví dụ: Trong quá trình phát triển ứng dụng, chúng ta sử dụng `H2` làm `database` cho `development`, sau đó chuyển sang `MySQL` cho `production`. `Tài nguyên đính kèm` bao gồm `URL` kết nối `database`, `username`, `password`.

### 3.9. `Environment Parity` (Tính tương đồng môi trường)
- `Environment Parity` đảm bảo rằng môi trường phát triển, thử nghiệm và sản xuất là tương đồng nhau, không quá khác biệt.
- `Environment Parity` giúp giải quyết các vấn đề khoảng cách:
    + `Time Gap`: Phương pháp này thúc đẩy tự động hóa và triển khai liên tục (CI/CD) để giảm thiểu thời gian giữa quá trình phát triển và triển khai ứng dụng.
    + `People Gap`: Thúc đẩy sự hợp tác giữa các nhà phát triển và nhà điều hành trên nguyên lý `bạn xây dựng, bạn chạy nó`.
    + `Tools Gap`: Đảm bảo sử dụng cùng loại và cùng phiên bản các dịch vụ và công cụ trong môi trường phát triển, thử nghiệm và sản xuất.

### 3.10. `Administrative Processes` (Quy trình quản trị)
- Các tác vụ quản lý cần thiết để hỗ trợ các ứng dụng, chẳng hạn như `migrate` cơ sở dữ liệu, hoặc tác vụ `bảo trì`, phải được coi là các `quy trình riêng biệt`. 
- Tương tự như các quy trình ứng dụng, mã cho các tác vụ quản trị này phải được kiểm soát phiên bản, đóng gói cùng với ứng dụng và được thực thi trong cùng một môi trường.
- Coi các nhiệm vụ quản trị là các dịch vụ vi mô `độc lập` được thực thi `một lần` rồi `loại bỏ` hoặc như các chức năng được định cấu hình trong một nền tảng không trạng thái để phản hồi các sự kiện cụ thể. Ngoài ra, chúng có thể được tích hợp trực tiếp vào ứng dụng, được kích hoạt bằng cách gọi API Endpoint được chỉ định.

### 3.11. `Port Binding` (Ràng buộc cổng)
- Ứng dụng `Cloud Native App` phải `độc lập` và `cung cấp` các `dịch vụ` của chúng thông qua `liên kết cổng`. Trong môi trường sản xuất, dịch vụ định tuyến có thể được sử dụng để chuyển các yêu cầu từ `public endpoint` sang các dịch vụ `local port`.
- Một ứng dụng được coi là `độc lập` khi nó `không phụ thuộc vào máy chủ bên ngoài` trong môi trường thực thi. 
Ví dụ: một ứng dụng web Java thường có thể chạy trong vùng chứa máy chủ như Tomcat, Jetty hoặc Undertow. Ngược lại, ứng dụng gốc trên đám mây không phụ thuộc vào sự hiện diện của máy chủ Tomcat trong môi trường; nó quản lý máy chủ như một phần phụ thuộc bên trong chính nó. Ví dụ: Spring Boot cho phép sử dụng máy chủ nhúng, trong đó ứng dụng kết hợp với máy chủ thay vì dựa vào tính khả dụng của nó trong môi trường thực thi. Do đó, mỗi ứng dụng được ánh xạ tới máy chủ riêng của nó, khác với cách tiếp cận truyền thống là triển khai nhiều ứng dụng trên một máy chủ.
Sau đó, các dịch vụ do ứng dụng cung cấp sẽ được hiển thị thông qua liên kết cổng. Ví dụ: một ứng dụng web liên kết các dịch vụ HTTP của nó với một cổng cụ thể và có thể đóng vai trò là dịch vụ hỗ trợ cho một ứng dụng khác. Đây là một thực tế phổ biến trong các hệ thống gốc trên nền tảng đám mây.

### 3.12. Stateless Processes (Quy trình không trạng thái)
- Ứng dụng `Cloud Native App` thường được phát triển với khả năng mở rộng cao. Một trong những nguyên tắc chính để đạt được khả năng mở rộng là `thiết kế các ứng dụng dưới dạng quy trình không trạng thái` và áp dụng` kiến ​​trúc không chia sẻ`. 
- Điều này có nghĩa là `không có trạng thái` nào `được chia sẻ` giữa các phiên bản khác nhau của ứng dụng. Điều `quan trọng` là phải đánh giá xem liệu có `dữ liệu nào bị mất hay không` nếu một phiên bản của `ứng dụng bị hủy và được tạo lại`. Nếu `xảy ra mất dữ liệu` thì ứng dụng không thực sự là `stateless`.
- Tuy nhiên, điều quan trọng cần lưu ý là `một số hình thức quản lý trạng thái là cần thiết` để ứng dụng hoạt động được. Để giải quyết vấn đề này, chúng tôi `thiết kế các ứng dụng không có trạng thái` và `ủy quyền xử lý` cũng như `lưu trữ trạng thái cho các dịch vụ có trạng thái cụ thể`, chẳng hạn như `database`. 
- Nói cách khác, một ứng dụng không có trạng thái dựa vào một dịch vụ hỗ trợ riêng biệt để quản lý và lưu trữ trạng thái được yêu cầu, trong khi bản thân ứng dụng đó vẫn không có trạng thái. Cách tiếp cận này cho phép khả năng mở rộng và linh hoạt tốt hơn trong khi vẫn đảm bảo rằng trạng thái cần thiết vẫn được duy trì và có thể truy cập được khi cần.

### 3.13. `Concurrency` (Đồng thời)
- Khả năng mở rộng không chỉ đạt được bằng cách tạo ra các ứng dụng phi trạng thái. Mặc dù `stateless` là quan trọng nhưng khả năng mở rộng cũng đòi hỏi khả năng phục vụ số lượng người dùng lớn hơn. Điều này có nghĩa là các ứng dụng phải `hỗ trợ xử lý đồng thời` để xử lý đồng thời nhiều người dùng.
- Các quy trình đóng một vai trò quan trọng trong thiết kế ứng dụng. Các quy trình này phải có khả năng mở rộng theo chiều ngang, phân phối khối lượng công việc trên nhiều quy trình trên các máy khác nhau. Sự đồng thời này chỉ khả thi khi các ứng dụng không có trạng thái. Trong các ứng dụng Máy ảo Java (JVM), tính đồng thời thường được quản lý thông qua việc sử dụng `nhiều luồng có sẵn từ nhóm luồng`.
- Các quy trình có thể được `phân loại dựa trên loại tương ứng của chúng`. 
Ví dụ: có các quy trình web chịu trách nhiệm xử lý các yêu cầu HTTP cũng như các quy trình công nhân thực thi các công việc nền đã được lên lịch. Bằng cách phân loại các quy trình và tối ưu hóa tính đồng thời của chúng, các ứng dụng có thể mở rộng quy mô và xử lý khối lượng công việc tăng lên một cách hiệu quả.

### 3.14. `Telemetry` (Thu thập dữ liệu)
- Khả năng `quan sát, thu thập` là một đặc điểm cơ bản của các ứng dụng gốc trên nền tảng đám mây. Với sự phức tạp vốn có của việc quản lý hệ thống phân tán trên đám mây, việc có `quyền truy cập vào dữ liệu chính xác và toàn diện từ từng thành phần của hệ thống trở nên cần thiết`. `Dữ liệu` này `cho phép giám sát từ xa hành vi` của hệ thống và `tạo điều kiện quản lý hiệu quả` những vấn đề phức tạp của nó. 
- Dữ liệu đo từ xa, chẳng hạn như nhật ký, số liệu, dấu vết, tình trạng sức khỏe và sự kiện, đóng một vai trò quan trọng trong việc cung cấp khả năng hiển thị này.
- Để giám sát và kiểm soát các ứng dụng từ xa một cách hiệu quả, cần nhiều loại dữ liệu đo từ xa.
- Hãy xem xét loại đo từ xa cần thiết để đảm bảo giám sát và kiểm soát các ứng dụng của bạn từ xa. Điều này bao gồm thông tin như nhật ký chi tiết để khắc phục sự cố, số liệu để đo lường hiệu suất, dấu vết để hiểu Luồng yêu cầu, trạng thái sức khỏe để đánh giá tình trạng hoạt động của hệ thống và các sự kiện để nắm bắt các sự kiện quan trọng. 
- Bằng cách thu thập và sử dụng các loại dữ liệu đo từ xa này, chúng ta có thể có được những hiểu biết có giá trị về ứng dụng của mình và đưa ra quyết định sáng suốt để quản lý chúng một cách hiệu quả từ một địa điểm từ xa.

### 3.15. `Authentication and Authorization` (Xác thực và ủy quyền)
- Để duy trì cách tiếp cận không tin cậy, điều cần thiết là `phải đảm bảo tính bảo mật của mọi tương tác` trong hệ thống, bao gồm các `cấp độ kiến ​​trúc` và `cơ sở hạ tầng`. Mặc dù bảo mật không chỉ liên quan đến xác thực và ủy quyền, nhưng các khía cạnh này đóng vai trò là điểm khởi đầu vững chắc.
- `Xác thực` cho phép chúng ta `theo dõi` và `xác minh danh tính của người dùng truy cập ứng dụng`. 
- Bằng cách xác thực người dùng, chúng ta có thể `tiến hành đánh giá quyền` của họ và `xác định xem họ có quyền` cần thiết để thực hiện các hành động cụ thể hay không. 
- Việc triển khai các tiêu chuẩn quản lý danh tính và quyền truy cập có thể tăng cường bảo mật đáng kể. Các ví dụ đáng chú ý bao gồm OAuth 2.1 và OpenID Connect.