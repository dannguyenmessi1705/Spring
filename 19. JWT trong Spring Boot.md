# Sử dụng JWT trong Spring Boot
## 1. Giới thiệu
`JWT (JSON Web Token)` là một chuẩn mở để truyền dữ liệu an toàn giữa hai bên dưới dạng JSON. `JWT` được sử dụng rộng rãi trong việc xác thực người dùng và truyền dữ liệu an toàn giữa các hệ thống.

`JWT` bao gồm 3 phần, mỗi phần được ngăn cách bằng dấu chấm `.`:
- Header: Chứa thông tin về loại token và thuật toán mã hóa.
    + `alg`: Thuật toán mã hóa.
    + `typ`: Loại token.
- Payload: Chứa thông tin về người dùng.
    + `sub`: Subject, chủ thể của token.
    + `exp`: Expiration time, thời gian hết hạn của token.
    + `iat`: Issued At, thời gian phát hành token.
    + `iss`: Issuer, người phát hành token.
    + `aud`: Audience, người nhận token.
- Signature: Chữ ký số để xác thực token, bao gồm header, payload và secret key.

## 2. JWT Authentication sử dụng Spring Boot's OAuth2 Resource Server
Để sử dụng `JWT` trong `Spring Boot`, chúng ta sử dụng `Spring Boot's OAuth2 Resource Server`. `Spring Boot's OAuth2 Resource Server` hỗ trợ tích hợp `OAuth2` để xác thực người dùng sử dụng `JWT`:
> `pom.xml`
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
</dependency>
```
Chúng ta thực hiện các bước sau để sử dụng `JWT` trong `Spring Boot`:
- 1. Tạo key pair: Sử dụng `java.security.KeyPairGenerator` để tạo key pair. Hoặc sử dụng `openssl` để tạo key pair.
- 2. Tạo đối tượng khóa `RSA` sử dụng key pair: Sử dụng `com.nimbusds.jose.jwk.RSAKey` để tạo đối tượng khóa `RSA`.
- 3. Tạo `JWKSource` (JSON Web Key Source) để cung cấp khóa `RSA`
    + Tạo `JWKSet` để lưu trữ khóa `RSA`.
    + Tạo `JWKSource` từ `JWKSet`.
- 4. Sử dụng khóa công khai `RSA` để giải mã token: Sử dụng `NimbusJwtDecoder.withPublicKey(rsaKey.toRSAPublicKey()).build()` để giải mã token.
- 5. Sử dụng `JWKSource` cho việc mã hóa: trả về `return new NimbusJwsEncoder(jwkSource);` trong `@Bean` của `WebSecurityConfigurerAdapter`.

### 2.1. Cấu hình JWT với Spring Security
1. Chúng ta cấu hình `JWT` với `Spring Security` bằng việc thêm `SecurityFilterChain` để bật o2auth2 `Resource Server`:
```java
import org.springframework.security.web.SecurityFilterChain;
...
	@Bean
	public SecurityFilterChain filterChain(HttpSecurity http) throws Exception{ // Cấu hình JWT với Spring Security
		// Authorize Requests
		http.authorizeHttpRequests(req -> req.anyRequest().authenticated()) // Tất cả các request đều cần xác thực
		.httpBasic(withDefaults()) // Sử dụng HTTP Basic Authentication
		.cors(cors -> cors.disable()) // Tắt CORS
		.csrf(csrf -> csrf.disable()) // Tắt CSRF
		.headers(headers -> headers.frameOptions(frameOptions -> frameOptions.sameOrigin())) // X-Frame-Options: SAMEORIGIN
		.oauth2ResourceServer(oauth2 -> oauth2.jwt(withDefaults())); // Sử dụng JWT để xác thực người dùng khi truy cập vào các resource server (route API)

		return http.build();
	}
    ...
```

2. Tạo `KeyPair`:
```java
import java.security.KeyPair;
import java.security.KeyPairGenerator;
...
	@Bean
	public KeyPair keyPair() throws Exception{ // Tạo một KeyPair bao gồm public key và private key
		KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA"); // Sử dụng thuật toán RSA
		keyPairGenerator.initialize(2048); // Khởi tạo key với độ dài 2048 bits
		return keyPairGenerator.generateKeyPair(); // Trả về một KeyPair
	}
...
```
3. Tạo đối tượng khóa `RSA` sử dụng `KeyPair`:
```java
import com.nimbusds.jose.jwk.RSAKey;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.interfaces.RSAPublicKey;
import java.util.UUID;
...
    @Bean
	public RSAKey rsaKey(KeyPair keyPair) { // Tạo một RSAKey từ KeyPair
		return new RSAKey.Builder((RSAPublicKey) keyPair.getPublic()) // Sử dụng public key
				.privateKey(keyPair.getPrivate()) // Sử dụng private key
				.keyID(UUID.randomUUID().toString()) // Tạo một keyID ngẫu nhiên
				.build(); // Tạo một RSAKey
	}
...
```
4. Tạo `JWKSource` để cung cấp khóa `RSA` cho việc mã hóa:
```java
import com.nimbusds.jose.jwk.JWKSet;
import com.nimbusds.jose.jwk.RSAKey;
import com.nimbusds.jose.jwk.source.JWKSource;
import com.nimbusds.jose.proc.SecurityContext;
...
    @Bean
	public JWKSource<SecurityContext> jwkSource(RSAKey rsaKey) { // Tạo một JWKSource từ RSAKey
		JWKSet jwkSet = new JWKSet(rsaKey); // Tạo một JWKSet từ RSAKey
		return (jwkSelector, context) -> jwkSelector.select(jwkSet); // Trả về một JWKSource
	}
...
```
5. Sử dụng khóa công khai `RSA` để giải mã token:
```java
import com.nimbusds.jose.JOSEException;
import com.nimbusds.jose.jwk.RSAKey;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;
...
	@Bean
	public JwtDecoder jwtDecoder(RSAKey rsaKey) throws JOSEException { // Tạo một JwtDecoder từ RSAKey để giải mã token JWT
		return NimbusJwtDecoder.withPublicKey(rsaKey.toRSAPublicKey()).build(); // Trả về một JwtDecoder
    }
...
```

6. Tạo phương thức dùng để mã hóa JWKSource:
```java
import org.springframework.context.annotation.Bean;
import com.nimbusds.jose.jwk.source.JWKSource;
import com.nimbusds.jose.proc.SecurityContext;
import org.springframework.security.oauth2.jwt.NimbusJwtEncoder;
import org.springframework.security.oauth2.jwt.JwtEncoder;
...
	@Bean
	public JwtEncoder jwtEncoder(JWKSource<SecurityContext> jwkSource) {
		return new NimbusJwtEncoder(jwkSource); // Trả về một JwtEncoder từ JWKSource, sử dụng NimbusJwtEncoder
	}
...
```

### 2.2. Tạo API để xác thực người dùng, tạo và trả về JWT token để người dùng sử dụng
> `JWTController.java`
```java
package com.didan.learn_spring_security;

import java.time.Instant;
import java.util.stream.Collectors;

import org.springframework.security.core.Authentication;
import org.springframework.security.oauth2.jwt.JwtClaimsSet;
import org.springframework.security.oauth2.jwt.JwtEncoder;
import org.springframework.security.oauth2.jwt.JwtEncoderParameters;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class JwtAuthenticationController {
	private final JwtEncoder jwtEncoder; // Inject JwtEncoder (từ class JWTSecurityConfig) vào JwtAuthenticationController để mã hóa token JWT
	
	public JwtAuthenticationController(JwtEncoder jwtEncoder) {
		this.jwtEncoder = jwtEncoder;
	}
	
	@PostMapping("/authenticate") // Phương thức để xác thực người dùng, lấy token sau khi xác thực
	public JwtResponse authenticate(Authentication authentication) { // Authentication là một interface, nó chứa thông tin về người dùng sau khi xác thực Basic Authentication
		return new JwtResponse(createToken(authentication)); // Trả về token sau khi xác thực
	}
	
	
	private String createToken(Authentication authentication) { // Tạo token JWT từ thông tin người dùng sau khi xác thực
		JwtClaimsSet claims = JwtClaimsSet.builder() // Tạo claims cho token JWT
				.issuer("self") // Issuer của token là chính nó
				.issuedAt(Instant.now()) // Thời gian phát hành token
				.expiresAt(Instant.now().plusSeconds(60 * 15)) // Token hết hạn sau 15 phút
				.subject(authentication.getName()) // Subject của token là username của người dùng (có thể lấy bằng cáhc autthentication.getPricipal());
				.claim("scope", createScope(authentication)) // Tạo thêm trường tùy chỉnh trong body payload của token JWT, ở đây là scope
				.build(); // Tạo claims
		
		JwtEncoderParameters jwtEncoderParameters = JwtEncoderParameters.from(claims); // Tạo JwtEncoderParameters từ claims vừa tạo
		return jwtEncoder.encode(jwtEncoderParameters).getTokenValue(); // Mã hóa token JWT từ JwtEncoderParameters và trả về token
	}
	
	private String createScope(Authentication authentication) { // Tạo scope từ thông tin người dùng sau khi xác thực
		return authentication.getAuthorities().stream() // Lấy danh sách các quyền của người dùng sau khi xác thực
				.map(a -> a.getAuthority()) // Lấy tên của quyền
				.collect(Collectors.joining(" ")); // Nối tất cả các tên quyền lại với nhau và ngăn cách bằng dấu cách
	}
}

record JwtResponse(String token) {}; // Class này dùng để trả về token sau khi xác thực, sử dụng record để tạo class với constructor tự động
```
## 3. Sử dụng JWT với Spring Security Database Authentication (Tắt Basic Authentication)
### 3.1. Tắt Basic Authentication
```java
...
				.httpBasic(httpBasic -> httpBasic.disable())
				.formLogin(formLogin -> formLogin.disable())
...
```

### 3.2. Cấu hình `UserDetailsService` để xác thực người dùng từ database, Xem ở mục ## 5. (14. Spring Security.md)

### 3.3. Thay đổi logic trong `API route` để xác thực từ `Request Body` thay vì `Basic Authentication`
```java
@PostMapping("/login")
	public ResponseEntity<?> auth(@RequestBody Login login) {
		Authentication auth = authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(login.getUsername(), login.getPassword())); // Xác thực người dùng từ database thay vì Basic Authentication (Sau khi đã Custom UserDetailsService)
		return new ResponseEntity<>(new ResponseToken(createToken(auth)), HttpStatus.ACCEPTED); // Trả về token sau khi xác thực
	}
	
	private String createToken(Authentication authentication) {
		JwtClaimsSet jwtClaimsSet = JwtClaimsSet.builder()
				.issuer("self")
				.issuedAt(Instant.now())
				.expiresAt(Instant.now().plusSeconds(60 * 15))
				.subject(authentication.getName())
				.build();
		JwtEncoderParameters jwtEncoderParameters = JwtEncoderParameters.from(jwtClaimsSet);
		return jwtEncoder.encode(jwtEncoderParameters).getTokenValue();
	}
}

record ResponseToken(String token) {};
```