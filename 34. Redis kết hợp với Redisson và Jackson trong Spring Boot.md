# Sử dụng Redis kết hợp với Redisson và Jackson trong Spring Boot
Trong bài viết này, chúng ta sẽ tìm hiểu cách sử dụng Redis kết hợp với Redisson và Jackson trong Spring Boot.

## 1. Giới thiệu.
### 1.1. Redis
Redis là một hệ thống cơ sở dữ liệu mã nguồn mở, lưu trữ dữ liệu dạng `key-value`.

Hỗ trợ nhiều kiểu dữ liệu như string, list, set, sorted set, hash, stream, hyperloglog, bitmap, geospatial và định tuyến. 

Redis cung cấp các tính năng như in-memory, lưu trữ dữ liệu trên ổ đĩa, replica, partition, cluster, pub/sub, lua scripting, transation, key expiration, LRU eviction, geospatial indexing, và các tính năng khác.

### 1.2. Redisson
Redisson là một thư viện Java hỗ trợ tương tác với Redis. 

Redisson cung cấp các tính năng như Redis client, Redisson client, Redisson Spring Cache, Redisson Spring Data, Redisson Spring Session, Redisson Spring Boot Starter, Redisson Spring Data Connection, Redisson Spring Data Repository, Redisson Spring Data Transaction, Redisson Spring Data Web, Redisson Spring Data Web Reactive, Redisson Spring Data Web Socket, Redisson Spring Data Web Socket

### 1.3. Jackson
Jackson là một thư viện Java hỗ trợ chuyển đổi dữ liệu giữa Java Object và JSON.

Để làm việc với Redis, chúng ta cần chuyển đổi dữ liệu giữa Java Object sang JSON khi lưu vào Redis và ngược lại khi lấy dữ liệu từ Redis.


## 2. Cài đặt và cấu hình Redis + Redisson + Jackson trong Spring Boot
### 2.1. Thêm dependency vào `pom.xml`
Chỉ cần thêm thư viện của `Redisson` chúng ta đã có thể sử dụng `Redis` và `Jackson` trong ứng dụng Spring Boot. Tuy nhiên, bài viết này sẽ tách các thư viện ra thành từng phần để dễ hiểu hơn.

> pom.xml
```xml
<!-- Redisson -->
    <dependency>
      <groupId>org.redisson</groupId>
      <artifactId>redisson-spring-boot-starter</artifactId>
      <version>3.36.0</version>
    </dependency>

<!-- Redis -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-data-redis</artifactId>
    </dependency>

<!-- Jackson -->
    <dependency>
      <groupId>com.fasterxml.jackson.core</groupId>
      <artifactId>jackson-databind</artifactId>
      <version>2.17.2</version>
    </dependency>
```

### 2.2. Cấu hình Redisson + Redis Connection
Redis chia ra thành nhiều loại `connection` như `single`, `sentinel`, `cluster`, `replicated`, `master_slave`. Tham khảo các câu hình cho từng `connection` tại [Redisson Configuration](https://www.baeldung.com/redis-redisson)

Trong bài viết này, chúng ta sẽ đi sâu vào `single connection` và `cluster connection`.

#### 2.2.1. Cấu hình trong `application.properties`
Chúng ta có thể cấu hình tất cả các thông số kết nối Redis trong file `application.properties` hoặc `application.yml`. Tuy nhiên, bài viết này chúng ta chỉ thêm cấu hình này:
> application.properties
```properties
spring.application.name=demo
app.cache.redis.enable=true # Thuộc tính để xác định điều kiện kích hoạt Redis sẽ được cấu hình sau trong @Bean
```

#### 2.2.2. Thiết lập các thông số kết nối Redisson.
Chúng ta tạo 1 class mới lưu thông số kết nối Redisson:

> RedissonConfigurationProperties.java
```java
package com.example.demo.config;

import java.util.HashMap;
import java.util.Map;
import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.context.properties.EnableConfigurationProperties;

@ConfigurationProperties("app.cache.redis") // Định nghĩa tiền tố cho các thuộc tính cấu hình Redisson đã được định nghĩa trong application.properties nếu có. (Tham khảo ###5.2 ở bài 7)
@Data
public class RedissonConfigurationProperties {
//======= Cấu hình Redis với Máy chủ là SingleNode===================
  private String address = "redis://redis-10569.c302.asia-northeast1-1.gce.redns.redis-cloud.com:10569"; // Địa chỉ máy chủ Redis dạng redis://host:port
  private int subscriptionConnectionMinimumIdleSize = 1; // Kích thước tối thiểu của pool kết nối trống cho các kênh đăng ký (pub/sub). Được sử dụng bởi các đối tượng RTopic, RPatternTopic, RLock, RSemaphore, RCountDownLatch, RClusteredLocalCachedMap, RClusteredLocalCachedMapCache, RLocalCachedMap, RLocalCachedMapCache và Hibernate Local Cached Region Factories.
  private int subscriptionConnectionPoolSize = 50; // Kích thước tối đa của pool kết nối cho các kênh đăng ký (pub/sub). Được sử dụng bởi các đối tượng RTopic, RPatternTopic, RLock, RSemaphore, RCountDownLatch, RClusteredLocalCachedMap, RClusteredLocalCachedMapCache, RLocalCachedMap, RLocalCachedMapCache và Hibernate Local Cached Region Factories.
  private int connectionMinimumIdleSize = 24; // Số lượng kết nối Redis đang rảnh tối thiểu.
  private int connectionPoolSize = 64; // Kích thước tối đa của pool kết nối Redis.
  private int dnsMonitoringInterval = 5000; // Khoảng thời gian giám sát thay đổi DNS. Ứng dụng phải đảm bảo TTL bộ nhớ cache JVM DNS đủ thấp để hỗ trợ điều này. Đặt -1 để vô hiệu hóa. Chế độ Proxy hỗ trợ nhiều kết nối IP cho một tên máy chủ duy nhất.
  private int idleConnectionTimeout = 10000; // Nếu kết nối được gom không được sử dụng trong khoảng thời gian chờ và số lượng kết nối hiện tại lớn hơn kích thước pool kết nối rảnh tối thiểu, thì nó sẽ bị đóng và loại bỏ khỏi pool. Giá trị tính bằng mili giây.
  private int connectTimeout = 10000; // Thời gian chờ kết nối với bất kỳ máy chủ Redis nào.
  private int timeout = 3000; // Thời gian chờ phản hồi từ máy chủ Redis. Bắt đầu đếm ngược khi lệnh Redis được gửi thành công. Giá trị tính bằng mili giây.
  private int retryAttempts = 3; // Số lần thử lại gửi lệnh Redis đến máy chủ Redis trước khi bỏ cuộc. Nếu lệnh Redis không thể được gửi đến máy chủ Redis sau retryAttempts, lỗi sẽ được ném. Nhưng nếu nó được gửi thành công thì thời gian chờ sẽ bắt đầu.
  private int retryInterval = 1500; // Khoảng thời gian sau đó một lần thử gửi lệnh Redis khác sẽ được thực hiện. Giá trị tính bằng mili giây.
  private int database = 0; // Chỉ số cơ sở dữ liệu được sử dụng cho kết nối Redis (Mặc định là 0).
  private String username = "default"; // Tên người dùng cho xác thực máy chủ Redis. Yêu cầu Redis 6.0+
  private String password = "lL72ALG8YqUPTQw8qghJQageck9xxfER"; // Mật khẩu cho xác thực máy chủ Redis.
  private int subscriptionsPerConnection = 5; // Giới hạn số lượng đăng ký trên mỗi kết nối đăng ký. Được sử dụng bởi các đối tượng RTopic, RPatternTopic, RLock, RSemaphore, RCountDownLatch, RClusteredLocalCachedMap, RClusteredLocalCachedMapCache, RLocalCachedMap, RLocalCachedMapCache và Hibernate Local Cached Region Factories.
  private String clientName = null; // Tên kết nối khách hàng

//===================== Cấu hình Redis với Máy chủ là Cluster Node ====================
  private boolean checkSlotsCoverage = true; // Cho phép kiểm tra slot cụm trong quá trình khởi động Redisson.
  private String[] nodeAddresses = {"redis://10.207.56.44:8379", "redis://10.207.56.45:8379", "redis://10.207.56.46:8379", "redis://10.207.56.44:8479", "redis://10.207.56.45:8479", "redis://10.207.56.46:8479" }; // Thêm địa chỉ node Redis cluster hoặc địa chỉ đầu cuối Redis dạng host:port. Redisson tự động khám phá cấu trúc cụm. Sử dụng giao thức rediss:// để kết nối SSL.
  private int canInterval = 1000; // Khoảng thời gian quét trong mili giây. Áp dụng cho quét cấu trúc cụm Redis.
  private String readMode = "SLAVE"; // Đặt loại nút được sử dụng cho hoạt động đọc. Các giá trị có sẵn: SLAVE - Đọc từ các nút slave, sử dụng MASTER nếu không có SLAVES nào khả dụng, MASTER - Đọc từ nút master, MASTER_SLAVE - Đọc từ nút master và slave
  private String subscriptionMode = "SLAVE"; // Đặt loại nút được sử dụng cho hoạt động đăng ký. Các giá trị có sẵn: SLAVE - Đăng ký cho các nút slave, MASTER - Đăng ký cho nút master, loadBalancer
//  private int subscriptionConnectionMinimumIdleSize = 1; // Kích thước tối thiểu của pool kết nối trống cho các kênh đăng ký (pub/sub). Được sử dụng bởi các đối tượng RTopic, RPatternTopic, RLock, RSemaphore, RCountDownLatch, RClusteredLocalCachedMap, RClusteredLocalCachedMapCache, RLocalCachedMap, RLocalCachedMapCache và Hibernate Local Cached Region Factories.
//  private int subscriptionConnectionPoolSize = 50; // Kích thước tối đa của pool kết nối cho các kênh đăng ký (pub/sub). Được sử dụng bởi các đối tượng RTopic, RPatternTopic, RLock, RSemaphore, RCountDownLatch, RClusteredLocalCachedMap, RClusteredLocalCachedMapCache, RLocalCachedMap, RLocalCachedMapCache và Hibernate Local Cached Region Factories.
  private int slaveConnectionMinimumIdleSize = 24; // Số lượng kết nối rảnh tối thiểu cho mỗi nút slave Redis.
  private int slaveConnectionPoolSize = 64; // Kích thước tối đa của pool kết nối cho mỗi nút slave Redis.
  private int masterConnectionMinimumIdleSize = 24; // Số lượng kết nối rảnh tối thiểu cho mỗi nút master Redis.
  private int masterConnectionPoolSize = 64; // Kích thước tối đa của pool kết nối cho mỗi nút master Redis.
//  private int idleConnectionTimeout = 10000; // Nếu kết nối được gom không được sử dụng trong khoảng thời gian chờ và số lượng kết nối hiện tại lớn hơn kích thước pool kết nối rảnh tối thiểu, thì nó sẽ bị đóng và loại bỏ khỏi pool. Giá trị tính bằng mili giây.
//  private int connectTimeout = 10000; // Thời gian chờ kết nối với bất kỳ máy chủ Redis nào.
//  private int timeout = 3000; // Thời gian chờ phản hồi từ máy chủ Redis. Bắt đầu đếm ngược khi lệnh Redis được gửi thành công. Giá trị tính bằng mili giây.
//  private int retryAttempts = 3; // Số lần thử lại gửi lệnh Redis đến máy chủ Redis trước khi bỏ cuộc. Nếu lệnh Redis không thể được gửi đến máy chủ Redis sau retryAttempts, lỗi sẽ được ném. Nhưng nếu nó được gửi thành công thì thời gian chờ sẽ bắt đầu.
//  private int etryInterval = 1500; // Khoảng thời gian sau đó một lần thử gửi lệnh Redis khác sẽ được thực hiện. Giá trị tính bằng mili giây.
  private int failedSlaveReconnectionInterval = 3000; // Khoảng thời gian thử kết nối lại Redis Slave khi nó bị loại khỏi danh sách nội bộ của các máy chủ có sẵn. Trên mỗi sự kiện timeout, Redisson cố gắng kết nối với máy chủ Redis bị ngắt kết nối. Giá trị tính bằng mili giây.
//  private String username = "default"; // Tên người dùng cho xác thực máy chủ Redis. Yêu cầu Redis 6.0+
//  private String password = "lL72ALG8YqUPTQw8qghJQageck9xxfER"; // Mật khẩu cho xác thực máy chủ Redis.
//  private int subscriptionsPerConnection = 5; // Giới hạn số lượng đăng ký trên mỗi kết nối đăng ký. Được sử dụng bởi các đối tượng RTopic, RPatternTopic, RLock, RSemaphore, RCountDownLatch, RClusteredLocalCachedMap, RClusteredLocalCachedMapCache, RLocalCachedMap, RLocalCachedMapCache và Hibernate Local Cached Region Factories.
//  private String clientName = null; // Tên kết nối khách hàng.
  private int pingConnectionInterval = 30000; // Định nghĩa khoảng thời gian giữa các lệnh PING được gửi. Giá trị mặc định là 3000 mili giây. Cài đặt này cho phép phát hiện và kết nối lại các kết nối bị hỏng bằng lệnh PING. Đặt 0 để vô hiệu hóa.
  private boolean keepAlive = false; // Không bắt buộc kích hoạt TCP keepAlive cho kết nối.
  private boolean tcpNoDelay = true; // Cho phép TCP noDelay cho kết nối.
  private int scanInterval = 1000; // Khoảng thời gian giữa các lần quét các kết nối Redis. Được sử dụng để kiểm tra kết nối Redis có hoạt động hay không.


  // ttl
  private long ttl = 60000;
  private Map<String, Long> cacheExpirations = new HashMap<>(); // Mapping cacheNames với thời gian hết hạn sau khi ghi trong giây.
}
```

#### 2.2.3. Cấu hình kết nối Redisson đến Redis và tạo `RedisTemplate` để thực hiện các thao tác với Redis.
Chúng ta tạo 1 class mới để cấu hình kết nối Redisson đến Redis và tạo `RedisTemplate` để thực hiện các thao tác với Redis.

> RedisonCacheConfig.java
```java
package com.example.demo.config;

import java.time.Duration;
import java.util.HashMap;
import java.util.Map;
import lombok.extern.slf4j.Slf4j;
import org.redisson.Redisson;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;
import org.redisson.spring.data.connection.RedissonConnectionFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.CachingConfigurer;
import org.springframework.cache.interceptor.CacheErrorHandler;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.cache.RedisCacheWriter;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.JdkSerializationRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializationContext.SerializationPair;
import org.springframework.data.redis.serializer.RedisSerializer;
import org.springframework.util.StringUtils;

@Configuration
@Slf4j
@EnableConfigurationProperties(RedissonConfigurationProperties.class) // Chỉ định class RedissonConfigurationProperties là class chứa các properties cấu hình
@ConditionalOnProperty(value = "app.cache.redis.enable", havingValue = "true") // Điều kiện để load class này, chỉ load khi app.cache.redis.enable = true (đã định nghĩa trong application.properties)
public class RedissonCacheConfig implements CachingConfigurer {

  @Value("${spring.application.name}") // Đọc giá trị của property spring.application.name
  private String appName;

  @Bean
  @Primary
  public RedisTemplate<String, Object> redisTemplate(RedissonConnectionFactory cf) { // Hàm kết nối tới Redis để thực hiện các chức năng như đọc ghi, sử dụng cấu hình kết nối của Redisson
    RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>(); // Tạo RedisTemplate với key là String, value là Object
    redisTemplate.setKeySerializer(RedisSerializer.string()); // Đảm bảo key được serialize thành String trước khi lưu vào Redis
    redisTemplate.setHashKeySerializer(RedisSerializer.string()); // Đảm bảo hash key được serialize thành String trước khi lưu vào Redis
    redisTemplate.setConnectionFactory(cf); // Thiết lập connection factory cho RedisTemplate
    return redisTemplate;
  }

  @Bean(destroyMethod = "shutdown") // Bean với phương thức destroyMethod là "shutdown" dùng để đóng RedissonClient
  public RedissonClient redisson(RedissonConfigurationProperties props) {
    // Singleton instance of Redisson
    Config config = new Config();
    config.useSingleServer()
        .setAddress(props.getAddress())
        .setSubscriptionConnectionMinimumIdleSize(props.getSubscriptionConnectionMinimumIdleSize())
        .setSubscriptionConnectionPoolSize(props.getSubscriptionConnectionPoolSize())
        .setDatabase(props.getDatabase())
        .setConnectionPoolSize(props.getConnectionPoolSize())
        .setConnectionMinimumIdleSize(props.getConnectionMinimumIdleSize())
        .setDnsMonitoringInterval(props.getDnsMonitoringInterval())
        .setIdleConnectionTimeout(props.getIdleConnectionTimeout())
        .setConnectTimeout(props.getConnectTimeout())
        .setTimeout(props.getTimeout())
        .setRetryAttempts(props.getRetryAttempts())
        .setRetryInterval(props.getRetryInterval())
        .setUsername(props.getUsername())
        .setPassword(props.getPassword())
        .setSubscriptionsPerConnection(props.getSubscriptionsPerConnection());


    // Cluster
//    config.useClusterServers()
//        .setCheckSlotsCoverage(props.isCheckSlotsCoverage())
//        .setIdleConnectionTimeout(props.getIdleConnectionTimeout())
//        .setConnectTimeout(props.getConnectTimeout())
//        .setTimeout(props.getTimeout())
//        .setRetryAttempts(props.getRetryAttempts())
//        .setRetryInterval(props.getRetryInterval())
//        .setFailedSlaveReconnectionInterval(props.getFailedSlaveReconnectionInterval())
//        .setPassword(props.getPassword())
//        .setSubscriptionsPerConnection(props.getSubscriptionsPerConnection())
//        .setClientName(props.getClientName())
//        .setSubscriptionConnectionPoolSize(props.getSubscriptionConnectionPoolSize())
//        .setSlaveConnectionMinimumIdleSize(props.getSlaveConnectionMinimumIdleSize())
//        .setSlaveConnectionPoolSize(props.getSlaveConnectionPoolSize())
//        .setMasterConnectionMinimumIdleSize(props.getMasterConnectionMinimumIdleSize())
//        .setMasterConnectionPoolSize(props.getMasterConnectionPoolSize())
//        .setScanInterval(props.getScanInterval())
//        .setPingConnectionInterval(props.getPingConnectionInterval())
//        .setKeepAlive(props.isKeepAlive())
//        .setTcpNoDelay(props.isTcpNoDelay())
//        .setNodeAddresses(Arrays.asList(props.getNodeAddresses()));
    return Redisson.create(config);
  }

  // Hàm tạo RedissonConnectionFactory với tham số là RedissonClient, với redissonClient là cấu hình Redisson kết nối tới Redis
  @Bean
  public RedissonConnectionFactory redissonConnectionFactory(
      RedissonClient redissonClient) { 
    return new RedissonConnectionFactory(redissonClient);
  }

  // Tạo custom CacheErrorHandler để xử lý exception khi thao tác với cache
  @Override
  public CacheErrorHandler errorHandler() { 
    return new RedisCachErrorHandle();
  }


//============ CẤU HÌNH ĐỂ SỬ DỤNG ANNOTATION @Cacheable, @CacheConfig, @CachePut, @CacheEvict ====================
  public SerializationPair<Object> getJdkSerialization() { // Hàm trả về SerializationPair<Object> với JdkSerializationRedisSerializer
    ClassLoader loader = Thread.currentThread()
        .getContextClassLoader(); // Lấy class loader của thread hiện tại
    JdkSerializationRedisSerializer jdkSerializer = new JdkSerializationRedisSerializer(
        loader); // Tạo JdkSerializationRedisSerializer với class loader vừa lấy
    return SerializationPair.fromSerializer(
        jdkSerializer); // Trả về SerializationPair<Object> với JdkSerializationRedisSerializer vừa tạo
  } // Hàm này sẽ được sử dụng để serialize value khi lưu vào Redis với JdkSerializationRedisSerializer (mặc định)

  public RedisCacheConfiguration createDefaultCacheConfiguration(
      long ttl) { // Hàm tạo RedisCacheConfiguration mặc định với thời gian sống là ttl
    return RedisCacheConfiguration.defaultCacheConfig()
        .serializeValuesWith(
            getJdkSerialization()) // thuộc tính serializeValuesWith với giá trị trả về từ hàm getJdkSerialization()
        .computePrefixWith(cacheName -> {
          String prefix = appName + "::"; // Tạo prefix là appName + "::"
          if (StringUtils.hasText(cacheName)) {
            prefix += cacheName + "::"; // Nếu cacheName không rỗng thì thêm cacheName vào prefix
          }
          return prefix; // Trả về prefix vừa tạo
        })
        .entryTtl(Duration.ofMillis(ttl)); // Thiết lập thời gian sống của entry là ttl
  }

  @Bean
  public CacheManager redisCacheManager(RedissonConnectionFactory redissonConnectionFactory,
      RedissonConfigurationProperties properties) {
    Map<String, RedisCacheConfiguration> config = new HashMap<>();
    RedisCacheWriter redisCacheWriter = RedisCacheWriter.nonLockingRedisCacheWriter(redissonConnectionFactory);
    for (Map.Entry<String, Long> cachesWithTtl : properties.getCacheExpirations().entrySet()) {
      config.put(cachesWithTtl.getKey(), createDefaultCacheConfiguration(cachesWithTtl.getValue()));
    }
    return RedisCacheManager.builder(redisCacheWriter)
        .cacheDefaults(createDefaultCacheConfiguration(properties.getTtl()))
        .withInitialCacheConfigurations(config)
        .build();
  }

  /**
   * Sử dụng bằng cách đặt annotation @CacheConfig(cacheNames = {"cacheName"}, cacheManager= "redisCacheManager") trên class
   * Trong đó:
   * * cacheNames: Tên cache
   * * cacheManager: Tên bean CacheManager, có thể tạo nhiều CacheManager với tên khác nhau
   * Ngoài ra, có thể sử dụng @Cacheable(value="namefunc", key="#name", sync=true) trên method để cache kết quả trả về của method ví dụ như method này
   * Trong đó:
   * * value: Tên cache
   * * key: Biến sẽ nhận giá trị truyền vào từ method
   * * sync: Đồng bộ cache giúp tránh việc nhiều thread cùng truy cập cache cùng một lúc
   * Ví dụ:
   * @Cacheable(value="namefunc", key="#name", sync=true)
   * public String getName(String name) {
   *    return name; // name sẽ được key của Cache get đươợc trong name "namefunc" truyên xuống
   *    }
   *
   */

}
```

#### 2.2.4. Tạo class `RedisCachErrorHandle` để xử lý exception khi thao tác với cache
Chúng ta có thể tùy chỉnh cách xử lý exception khi thao tác với cache bằng cách tạo class `RedisCachErrorHandle` kế thừa từ `CacheErrorHandler`.

> RedisCachErrorHandle.java
```java
package com.example.demo.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.Cache;
import org.springframework.cache.interceptor.CacheErrorHandler;

@Slf4j
public class RedisCachErrorHandle implements CacheErrorHandler {

  @Override
  public void handleCacheGetError(RuntimeException exception, Cache cache, Object key) {
    hanldeTimeOutException(exception);
    log.info("Unable to get into cache {}:{}", cache.getName(), exception.getMessage());
  }


  @Override
  public void handleCachePutError(RuntimeException exception, Cache cache, Object key,
      Object value) {
    hanldeTimeOutException(exception);
    log.info("Unable to put into cache {}:{}", cache.getName(), exception.getMessage());
  }

  @Override
  public void handleCacheEvictError(RuntimeException exception, Cache cache, Object key) {
    hanldeTimeOutException(exception);
    log.info("Unable to evict cache {}:{}:{}", cache.getName(), key, exception.getMessage());
  }

  @Override
  public void handleCacheClearError(RuntimeException exception, Cache cache) {
    hanldeTimeOutException(exception);
    log.info("Unable to clean cache {}:{}", cache.getName(), exception.getMessage());
  }

  private void hanldeTimeOutException(RuntimeException exception) {
    log.error(exception.getMessage(), exception);
  }
}

```

### 2.3. Cấu hình và cài đặt Jackson (Sử dụng ObjectMapper)
Chúng ta cần cấu hình `ObjectMapper` từ thư viện `Jackson` để chuyển đổi dữ liệu giữa Java Object và JSON.

> ObjectMapperUtils.java
```java
package com.example.demo.utils;

import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;
import com.fasterxml.jackson.databind.util.StdDateFormat;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import java.text.Normalizer;
import java.text.Normalizer.Form;
import java.util.Calendar;
import java.util.regex.Pattern;
import lombok.experimental.UtilityClass;
import lombok.extern.slf4j.Slf4j;
import org.springframework.util.ObjectUtils;

@UtilityClass
@Slf4j
public class ObjectMapperUtils {
  public static final String EXCEPTION_WHEN_PARSING_JSON = "Exception when parsing [JSON=%s] to object [class=%s]";
  private static final ObjectMapper objectMapper;

  static {
    objectMapper = new ObjectMapper()
        .setAnnotationIntrospector(new JacksonAnnotationIntrospector()) // thiết lập introspector để sử dụng annotation của Jackson
        .registerModule(new JavaTimeModule()) // thiết lập module để sử dụng các định dạng thời gian của Java
        .setDateFormat(new StdDateFormat()) // thiết lập định dạng ngày tháng
        .disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES) // không bắt lỗi khi có thuộc tính không xác định
        .setTimeZone(Calendar.getInstance().getTimeZone()) // thiết lập múi giờ
        .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); // không viết ngày tháng dưới dạng timestamp
  }

  public static String toJson(Object o) { // chuyển object thành chuỗi JSON
    try {
      return objectMapper.writeValueAsString(o);
    } catch (Exception e) {
      log.error("Exception when parsing object to JSON", e);
      return null;
    }
  }

  public static String toJsonWithParamNotNullOrEmpty(Object o) { // chuyển object thành chuỗi JSON với điều kiện không null hoặc rỗng
    try {
      ObjectMapper objectMapper1 = new ObjectMapper();
      objectMapper1.setSerializationInclusion(Include.NON_NULL); // không chuyển thuộc tính null
      return objectMapper1.writeValueAsString(o);
    } catch (Exception e) {
      log.error("Exception when parsing object to JSON", e);
      return null;
    }
  }

  public static <T> T fromJson(String json, TypeReference<T> typeReference) { // chuyển chuỗi JSON thành object
    try {
      return objectMapper.readValue(json, typeReference);
    } catch (Exception e) {
      log.error(String.format(EXCEPTION_WHEN_PARSING_JSON, json, typeReference.getType()), e);
      return null;
    }
  }

  public static <T> T fromJson(String json, Class<T> clazz) { // chuyển chuỗi JSON thành class cụ thể
    try {
      return objectMapper.readValue(json, clazz);
    } catch (Exception e) {
      log.error(String.format(EXCEPTION_WHEN_PARSING_JSON, json, clazz.getSimpleName()), e);
      return null;
    }
  }

  public static <T> T fromJsonWithUnknownProperties(String json, TypeReference<T> typeReference) {
    try {
      ObjectMapper objectMapper1 = new ObjectMapper();
      objectMapper1.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); // không bắt lỗi khi có thuộc tính không xác định
      return objectMapper1.readValue(json, typeReference);
    } catch (Exception e) {
      log.error(String.format(EXCEPTION_WHEN_PARSING_JSON, json, typeReference.getType()), e);
      return null;
    }
  }

  public static String convertToUnsigned(String input){ // chuyển chuỗi có dấu thành không dấu
    if (ObjectUtils.isEmpty(input)) { // kiểm tra xem chuỗi đầu vào có rỗng không
      return input; // nếu rỗng thì trả về luôn
    }
    String regex = "\\p{InCombiningDiacriticalMarks}+"; // regex để loại bỏ dấu
    String temp = Normalizer.normalize(input, Form.NFD);
    return Pattern.compile(regex).matcher(temp).replaceAll("").replace("đ", "d");
  }

}
```

### 2.4. Sử dụng `RedisTemplate` và `ObjectMapper` trong ứng dụng.
Chúng ta có thể sử dụng `RedisTemplate` và `ObjectMapper` để thực hiện các thao tác với Redis.

> CacheService.java
```java
package com.example.demo.service;

import com.example.demo.utils.ObjectMapperUtils;
import java.util.concurrent.TimeUnit;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

@Service
@Slf4j
@RequiredArgsConstructor
public class CacheService {
  private final RedisTemplate<String, Object> redisTemplate;

  @Value("${spring.application.name}")
  private String appName;

  public <T> void setCache(String cacheName, String key, T value) {
    setCache(cacheName, key, value, -1); // Gọi hàm setCache với thời gian hết hạn mặc định là -1 (không hết hạn)
  }

  public <T> void setCache(String cacheName, String key, T value, long timeout) {
    String keyGen = this.keyGen(cacheName, key);
    log.info("RedisCacheTemplate put: cacheName = {}, key = {}, value = {}", cacheName, keyGen,
        ObjectMapperUtils.toJson(value));
    try {
      String valueStr = ObjectMapperUtils.toJson(value); // Chuyển object thành chuỗi JSON
      redisTemplate.opsForValue().set(keyGen, valueStr); // Lưu chuỗi JSON vào Redis
      if (timeout != -1) { // Nếu thời gian hết hạn khác -1 thì set thời gian hết hạn cho keyGen
        redisTemplate.expire(keyGen, timeout, TimeUnit.SECONDS); // Set thời gian hết hạn cho keyGen là timeout giây
      }
    } catch (Exception ex) {
      log.error("SetCache: Redis cache exception", ex);
    }
  }

  public <T> T getCache(String cacheName, String key, Class<T> objectClass) { // Lấy cache từ Redis
    String keyGen = this.keyGen(cacheName, key); // Tạo key cho cache
    log.info("RedisCacheTemplate get: cacheName = {}, key = {}", cacheName, keyGen); // Log thông tin cacheName và key
    String valueStr = (String) redisTemplate.opsForValue().get(keyGen); // Lấy giá trị từ Redis với keyGen và ép kiểu về String (JSON)
    if (valueStr == null) { // Nếu valueStr rỗng thì trả về null
      log.info("Key {} does not exist", keyGen);
      return null;
    } else {
      try {
        return ObjectMapperUtils.fromJson(valueStr, objectClass); // Chuyển chuỗi JSON thành object với class objectClass
      } catch (Exception ex) {
        log.error("GetCache: Redis cache exception", ex);
        return null;
      }
    }
  }

  public void deleteCache(String cacheName, String key) { // Xóa cache từ Redis
    String keyGen = this.keyGen(cacheName, key); // Tạo key cho cache
    log.info("RedisCacheTemplate delete: cacheName = {}, key = {}", cacheName, keyGen);
    Boolean isDeleted = redisTemplate.delete(keyGen); // Xóa keyGen từ Redis
    if (!Boolean.TRUE.equals(isDeleted)) {
      log.info("Key {} does not exist or delete fail", keyGen);
    }
  }

  private String keyGen(String cacheName, Object key) { // Tạo key cho cache
    return StringUtils.hasLength(cacheName) ? this.appName + ":" + cacheName + ":" + key : key.toString();
  } 

}
```

TỪ `CacheService` chúng ta có thể Inject vào các `Service` khác để thực hiện các thao tác với Redis.