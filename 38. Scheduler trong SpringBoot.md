# Scheduler
## 1. Giới thiệu
Scheduler trong Spring Boot cho phép bạn thực hiện các tác vụ định kỳ hoặc theo lịch trình.

Trong Spring Boot, bạn có thể sử dụng các `Scheduler` sau để lên lịch cho các tác vụ:
- `@Scheduled`: Annotation để đánh dấu phương thức sẽ được thực hiện theo lịch trình.
- `TaskScheduler`: Interface để thực hiện các tác vụ theo lịch trình.
- `Quartz`: Thư viện mạnh mẽ để quản lý các tác vụ theo lịch trình phức tạp.

## 2. @Scheduled
### 2.1. Giới thiệu
`@Scheduled` là một annotation trong Spring cho phép bạn đánh dấu một phương thức sẽ được thực hiện theo lịch trình. Bạn có thể sử dụng các thuộc tính như `fixedRate`, `fixedDelay`, hoặc `cron` để xác định tần suất thực hiện.
### 2.2. Cấu hình
Để sử dụng `@Scheduled`, bạn cần thêm annotation `@EnableScheduling` vào lớp cấu hình hoặc lớp chính của ứng dụng Spring Boot. Điều này sẽ kích hoạt tính năng lập lịch trong ứng dụng của bạn.

```java
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableScheduling;
@Configuration
@EnableScheduling
public class SchedulerConfig {
}
```
Bạn có thể sử dụng các thuộc tính sau trong `@Scheduled`:
- `fixedRate`: Thực hiện phương thức sau một khoảng thời gian cố định tính bằng milliseconds kể từ khi phương thức bắt đầu thực hiện.
- `fixedDelay`: Thực hiện phươngthức sau một khoảng thời gian cố định tính bằng milliseconds kể từ khi phương thức kết thúc.
- `cron`: Sử dụng biểu thức cron để xác định lịch trình thực hiện phương thức.
- `initialDelay`: Khoảng thời gian trì hoãn trước khi phương thức đầu tiên được thực hiện, tính bằng milliseconds.
- `zone`: Múi giờ sử dụng cho biểu thức cron (nếu sử dụng `cron`).
### 2.3. Ví dụ
```java
package com.didan.schedule.processor;

import com.didan.schedule.config.TaskExecutorConfig;
import com.didan.schedule.service.UserService;
import com.didan.schedule.utils.Data;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.task.TaskExecutor;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

@Component
@Slf4j
@RequiredArgsConstructor
public class UseScheduled {

  private final UserService userService;
  private final TaskExecutor threadPoolTaskExecutor;

  @Scheduled(fixedRate = 5000)
  public void scheduled() {
    try {
      TaskExecutorConfig.handlerTask(threadPoolTaskExecutor, 8);
      threadPoolTaskExecutor.execute(() -> {
        log.info("@Scheduled is running every 5 seconds, with IDX: [{}]", Data.BEGIN_IDX++);
        userService.getUsers();
      });
    } catch (Exception ex) {
      log.error("Error in @Scheduled", ex);
    } finally {
      log.info("@Scheduled is done");
    }
  }
}

```

### 2.4. Biểu thức Cron
Biểu thức cron cho phép bạn xác định lịch trình thực hiện phương thức một cách linh hoạt. Cú pháp của biểu thức cron bao gồm 6 hoặc 7 trường, mỗi trường đại diện cho một phần của thời gian:
```
* * * * * *
| | | | | |
| | | | | +----- Ngày trong tuần (0 - 7) (0 và 7 đều đại diện cho Chủ nhật)
| | | | +------- Tháng (1 - 12)
| | | +--------- Ngày trong tháng
| | +----------- Giờ (0 - 23)
| +------------- Phút (0 - 59)
+--------------- Giây (0 - 59) (tùy chọn, nếu không có thì mặc định là 0)
```
Ví dụ:
```java
@Scheduled(cron = "0 0/5 * * * ?") // Thực hiện mỗi 5 phút
public void performTask() {
    System.out.println("Task performed at: " + System.currentTimeMillis());
}
```

### 2.5. Lợi ích khi sử dụng @Scheduled
- **Đơn giản và dễ sử dụng**: Chỉ cần thêm annotation vào phương thức
- **Tích hợp tốt với Spring**: Tự động quản lý vòng đời của các tác vụ theo lịch trình.

### 2.6. Nhược điểm
- **Hạn chế về tính năng**: Không hỗ trợ các tác vụ phức tạp như lập lịch theo lịch âm, lập lịch theo tuần, tháng.
- **Không hỗ trợ phân tán**: Không thể quản lý các tác vụ theo lịch trình trên nhiều máy chủ hoặc dịch vụ khác nhau.

## 3. TaskScheduler
### 3.1. Giới thiệu
`TaskScheduler` là một interface trong Spring cho phép bạn thực hiện các tác vụ theo lịch trình. Nó cung cấp các phương thức để lên lịch các tác vụ một cách linh hoạt hơn so với `@Scheduled`.
### 3.2. Cấu hình
Để sử dụng `TaskScheduler`, bạn cần định nghĩa một bean của loại `TaskScheduler`. Spring cung cấp một số triển khai của `TaskScheduler`, bao gồm `ThreadPoolTaskScheduler` và `ConcurrentTaskScheduler`.
```java
package com.didan.schedule.config;

// Import Lombok annotation để tự động tạo logger
import lombok.extern.slf4j.Slf4j;
// Import Bean annotation để đánh dấu phương thức tạo bean
import org.springframework.context.annotation.Bean;
// Import Configuration để đánh dấu class này là configuration class
import org.springframework.context.annotation.Configuration;
// Import interface TaskScheduler - interface chung cho việc lên lịch task
import org.springframework.scheduling.TaskScheduler;
// Import implementation cụ thể của TaskScheduler sử dụng thread pool
import org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;

// Annotation đánh dấu đây là class cấu hình Spring
@Configuration
// Annotation Lombok để tự động tạo logger với tên là log
@Slf4j
public class TaskSchedulerConfig {

  // Bean tạo TaskScheduler để lên lịch các task theo thời gian
  @Bean
  public TaskScheduler taskScheduler() {
    // Tạo instance của ThreadPoolTaskScheduler - implementation cụ thể của TaskScheduler
    ThreadPoolTaskScheduler taskScheduler = new ThreadPoolTaskScheduler();

    // Thiết lập kích thước pool = 8 thread
    // Khác với TaskExecutor, TaskScheduler chỉ có một pool size duy nhất
    // Tất cả 8 thread có thể được sử dụng để chạy scheduled task
    taskScheduler.setPoolSize(8);

    // Đặt prefix cho tên thread = "TaskScheduler-"
    // Các thread sẽ có tên dạng: TaskScheduler-1, TaskScheduler-2, ...
    taskScheduler.setThreadNamePrefix("TaskScheduler-");

    // Chờ các task hoàn thành trước khi shutdown ứng dụng
    // Đảm bảo không mất scheduled task khi application stop
    taskScheduler.setWaitForTasksToCompleteOnShutdown(true);

    // Set task decorator để copy MDC (Mapped Diagnostic Context) giữa các thread
    // Giúp maintain logging context trong scheduled task execution
    taskScheduler.setTaskDecorator(new MdcTaskDecorator());

    // Thiết lập handler xử lý khi task bị reject (khi pool đầy)
    taskScheduler.setRejectedExecutionHandler((runnable, exec) -> {
      try {
        // Kiểm tra executor chưa shutdown
        if (!exec.isShutdown()) {
          // Thử đưa task vào queue một lần nữa (blocking)
          // put() sẽ chờ đến khi có chỗ trống trong queue
          exec.getQueue().put(runnable);

          // Log debug thông tin về việc retry scheduled task
          log.debug("Task scheduler rejected, retrying. ActiveCount: {}, CompletedCount: {}, Queue: {}",
              exec.getActiveCount(), // Số thread đang active
              exec.getCompletedTaskCount(), // Số task đã hoàn thành
              exec.getQueue().size()); // Số task trong queue
        } else {
          // Nếu scheduler đang shutdown, không thể queue task
          log.error("Task scheduler is shutting down, cannot queue task.");
        }
      } catch (InterruptedException ex) {
        // Restore interrupt status cho thread hiện tại khi bị interrupt
        Thread.currentThread().interrupt();
        // Log error khi scheduler đang shutdown
        log.error("Task scheduler is shutting down, cannot queue task.");
      }
    });

    // Khởi tạo scheduler (tạo các thread trong pool)
    taskScheduler.initialize();
    return taskScheduler;
  }

  // Phương thức static để xử lý task scheduler - kiểm tra và điều chỉnh pool
  public static void handlerTask(TaskScheduler scheduler, int maxPoolSize) {
    try {
      // Kiểm tra scheduler có phải là ThreadPoolTaskScheduler không
      // Sử dụng pattern matching (Java 14+) thay vì instanceof + cast
      if (scheduler instanceof ThreadPoolTaskScheduler threadPool) {

        // Log thông tin về pool size hiện tại và yêu cầu
        log.info("Handling task. Current max pool size: {}, Requested max pool size: {}",
            threadPool.getPoolSize(), // Pool size hiện tại
            maxPoolSize); // Pool size được yêu cầu

        // Lấy số thread đang active (đang xử lý scheduled task)
        int activeThread = threadPool.getActiveCount();

        // Kiểm tra nếu số thread active >= maxPoolSize yêu cầu
        if (activeThread >= maxPoolSize) {
          // Log warning khi vượt quá giới hạn
          log.warn("Current max pool size exceeded, waiting task.");
          // Sleep ngắn để giảm tải và chờ một số scheduled task hoàn thành
          Thread.sleep(200);
        }
      }
    } catch (InterruptedException ex) {
      // Xử lý exception khi bị interrupt trong quá trình sleep
      log.error("Handler task exception {}", ex.getMessage());
      // Restore interrupt status cho thread hiện tại
      Thread.currentThread().interrupt();
    }
  }
}
```
### 3.3. Ví dụ
```java
package com.didan.schedule.processor;


import com.didan.schedule.config.TaskExecutorConfig;
import com.didan.schedule.config.TaskSchedulerConfig;
import com.didan.schedule.service.UserService;
import com.didan.schedule.utils.Data;
import java.time.Duration;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.scheduling.TaskScheduler;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
@Slf4j
public class UseTaskScheduler implements InitializingBean {

  private final UserService userService;
  private final ThreadPoolTaskExecutor threadPoolTaskExecutor;
  private final TaskScheduler taskScheduler;

  @Override
  public void afterPropertiesSet() throws Exception {
    try {
      TaskExecutorConfig.handlerTask(threadPoolTaskExecutor, 8);
      threadPoolTaskExecutor.execute(() -> {
        TaskSchedulerConfig.handlerTask(taskScheduler, 8);
        taskScheduler.scheduleAtFixedRate(() -> {
          log.info("Task scheduler is running every 5 seconds, with IDX: [{}]", Data.BEGIN_IDX++);
          userService.getUsers();
        }, Duration.ofSeconds(5));
      });
    } catch (Exception ex) {
      log.error("Error in Task scheduler", ex);
    } finally {
      log.info("Task scheduler is done");
    }
  }
}
```

### 3.4. Lợi ích khi sử dụng TaskScheduler
- **Linh hoạt hơn**: Bạn có thể lên lịch các tác vụ một cách linh hoạt hơn so với `@Scheduled`.
- **Hỗ trợ nhiều loại tác vụ**: Bạn có thể lên lịch các tác vụ không chỉ là phương thức mà còn là các Runnable hoặc Callable.
- **Quản lý tốt hơn**: Bạn có thể quản lý các tác vụ theo lịch trình một cách dễ dàng hơn, bao gồm việc hủy bỏ các tác vụ đã lên lịch.
### 3.5. Nhược điểm
- **Cần cấu hình thêm**: Bạn cần định nghĩa bean và cấu hình thêm so với `@Scheduled`.
- **Phức tạp hơn**: Việc sử dụng `TaskScheduler` có thể phức tạp hơn so với việc sử dụng `@Scheduled`, đặc biệt là khi bạn chỉ cần thực hiện các tác vụ đơn giản theo lịch trình.

## 4. Quartz
### 4.1. Giới thiệu
`Quartz` là một thư viện mạnh mẽ để quản lý các tác vụ theo lịch trình. Nó hỗ trợ các tính năng như lập lịch theo lịch âm, lập lịch theo tuần, tháng, và hỗ trợ phân tán. `Quartz` có thể được tích hợp với Spring Boot để quản lý các tác vụ theo lịch trình một cách hiệu quả.
### 4.2. Thêm phụ thuộc
Để sử dụng `Quartz` trong Spring Boot, bạn cần thêm phụ thuộc vào file `pom.xml`:
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-quartz</artifactId>
</dependency>
```
### 4.3. Cấu hình
Tạo lớp chứa tên các job và cấu hình lịch trình:
```java
package com.didan.schedule.config;

import java.util.Set;
import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

@Configuration
@Data
@ConfigurationProperties(prefix = "quartz.jobs")
public class QuartzRunningJobConfig {
  private Set<String> runningJobs;
}
```

Thêm cấu hình vào file `application.yml`:
```yaml
quartz:
  jobs:
    running-jobs: # Danh sách các job đang chạy
      - User Service
```

Tạo bean mở rộng hỗ trợ tự động autowire các bean trong job Quartz:
```java
package com.didan.schedule.config;

// Import các class cần thiết từ Quartz và Spring
import org.quartz.spi.TriggerFiredBundle;
import org.springframework.beans.factory.config.AutowireCapableBeanFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.scheduling.quartz.SpringBeanJobFactory;

// Lớp này mở rộng SpringBeanJobFactory để hỗ trợ tự động autowire các bean trong job của Quartz
public class AutowiringSpringBeanJobFactory extends SpringBeanJobFactory implements ApplicationContextAware {

  // Biến lưu trữ beanFactory để autowire các bean
  private AutowireCapableBeanFactory beanFactory;

  // Phương thức này được gọi bởi Spring để truyền ApplicationContext vào class này
  @Override
  public void setApplicationContext(ApplicationContext applicationContext) {
    // Lấy ra AutowireCapableBeanFactory từ ApplicationContext để sử dụng autowire
    beanFactory = applicationContext.getAutowireCapableBeanFactory();
  }

  // Ghi đè phương thức tạo instance của job, đồng thời autowire các dependency cho job
  @Override
  protected Object createJobInstance(TriggerFiredBundle bundle) throws Exception {
    // Tạo instance của job thông qua SpringBeanJobFactory
    Object job = super.createJobInstance(bundle);
    // Thực hiện autowire các dependency cho job vừa tạo
    beanFactory.autowireBean(job);
    // Trả về job đã được autowire
    return job;
  }
}
```

Tạo cấu hình cho Quartz:
```java
package com.didan.schedule.config;

// Import các class cần thiết cho Quartz scheduler

import com.didan.schedule.utils.CommonUtils;
import java.util.Arrays;
import java.util.Calendar;
import java.util.List;
import java.util.Properties;
import java.util.Set;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.quartz.CronTrigger;
import org.quartz.Job;
import org.quartz.JobDetail;
import org.quartz.SimpleTrigger;
import org.quartz.Trigger;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.quartz.CronTriggerFactoryBean;
import org.springframework.scheduling.quartz.JobDetailFactoryBean;
import org.springframework.scheduling.quartz.SchedulerFactoryBean;
import org.springframework.scheduling.quartz.SimpleTriggerFactoryBean;
import org.springframework.scheduling.quartz.SpringBeanJobFactory;

// Annotation để đánh dấu đây là class cấu hình Spring
@Configuration
// Annotation để tự động tạo logger với tên là log
@Slf4j
// Annotation Lombok để tự động tạo constructor với các final field
@RequiredArgsConstructor
public class QuartzConfig {

  // Dependency injection: Config chứa danh sách các job được phép chạy
  private final QuartzRunningJobConfig quartzRunningJobConfig;
  // Dependency injection: ApplicationContext để truy cập Spring container
  private final ApplicationContext applicationContext;

  // Bean tạo SpringBeanJobFactory với khả năng autowire
  @Bean
  public SpringBeanJobFactory springBeanJobFactory() {
    // Tạo instance của custom job factory có khả năng autowire
    AutowiringSpringBeanJobFactory jobFactory = new AutowiringSpringBeanJobFactory();
    // Set ApplicationContext để job factory có thể autowire các bean
    jobFactory.setApplicationContext(applicationContext);
    return jobFactory;
  }

  // Bean tạo SchedulerFactoryBean - trái tim của Quartz scheduler
  @Bean
  public SchedulerFactoryBean scheduler(Trigger... triggers) {
    // Tạo instance của SchedulerFactoryBean
    SchedulerFactoryBean schedulerFactoryBean = new SchedulerFactoryBean();

    // Tạo properties để cấu hình Quartz scheduler
    Properties properties = new Properties();
    // Đặt tên cho scheduler instance
    properties.setProperty("org.quartz.scheduler.instanceName", "QuartzScheduler");
    // Đặt ID duy nhất cho scheduler instance
    properties.setProperty("org.quartz.scheduler.instanceId", "Instance1");

    // Cho phép ghi đè các job đã tồn tại khi restart
    schedulerFactoryBean.setOverwriteExistingJobs(true);
    // Tự động start scheduler khi ứng dụng khởi động
    schedulerFactoryBean.setAutoStartup(true);
    // Set các properties đã cấu hình cho scheduler
    schedulerFactoryBean.setQuartzProperties(properties);
    // Set job factory có khả năng autowire
    schedulerFactoryBean.setJobFactory(springBeanJobFactory());
    // Đợi các job hoàn thành trước khi shutdown ứng dụng
    schedulerFactoryBean.setWaitForJobsToCompleteOnShutdown(true);

    // Lấy danh sách các job được phép chạy từ config
    Set<String> runningJobs = quartzRunningJobConfig.getRunningJobs();
    // Log danh sách job được phép chạy
    log.info("RUNNING JOBS: {}", CommonUtils.toJson(runningJobs));

    // Kiểm tra xem có trigger nào được truyền vào không
    if (triggers != null && triggers.length > 0) {
      // Lọc ra những trigger có job name nằm trong danh sách được phép chạy
      List<Trigger> triggerFiltered = Arrays.stream(triggers)
          .filter(trigger -> runningJobs.contains(trigger.getJobKey().getName()))
          .toList();

      // Tạo mảng trigger từ list ��ã lọc
      Trigger[] triggerFilterArray = new Trigger[triggerFiltered.size()];
      // Copy từng trigger vào mảng và log thông tin
      for (int i = 0; i < triggerFiltered.size(); i++) {
        triggerFilterArray[i] = triggerFiltered.get(i);
        // Log tên job sẽ được chạy
        log.info("PREPARE TO RUN: [{}]", triggerFilterArray[i].getJobKey().getName());
      }
      // Set mảng trigger đã lọc cho scheduler
      schedulerFactoryBean.setTriggers(triggerFilterArray);
    }
    return schedulerFactoryBean;
  }

  // Phương thức static để tạo JobDetailFactoryBean
  public static JobDetailFactoryBean createJobDetail(Class<? extends Job> jobClass, String jobName) {
    // Log thông tin tạo job detail
    log.info("createJobDetail(jobClass: {}, jobName: {})", jobClass.getName(), jobName);
    // Tạo JobDetailFactoryBean
    JobDetailFactoryBean factoryBean = new JobDetailFactoryBean();
    // Set tên cho job
    factoryBean.setName(jobName);
    // Set class của job
    factoryBean.setJobClass(jobClass);
    // Set durability = true để job không bị xóa khi không có trigger
    factoryBean.setDurability(true);
    return factoryBean;
  }

  // Phương thức static để tạo CronTriggerFactoryBean (trigger chạy theo cron expression)
  public static CronTriggerFactoryBean createCronTrigger(JobDetail jobDetail, String cronExpression, String triggerName) {
    // Log thông tin tạo cron trigger
    log.info("createCronTrigger(jobDetail: {}, cronExpression: {}, triggerName: {})", jobDetail.getKey(), cronExpression, triggerName);

    // Tạo Calendar để set thời gian bắt đầu
    Calendar calendar = Calendar.getInstance();
    // Set giây về 0 để trigger chạy đúng phút
    calendar.set(Calendar.SECOND, 0);
    // Set millisecond về 0 để chính xác hơn
    calendar.set(Calendar.MILLISECOND, 0);

    // Tạo CronTriggerFactoryBean
    CronTriggerFactoryBean factoryBean = new CronTriggerFactoryBean();
    // Set job detail cho trigger
    factoryBean.setJobDetail(jobDetail);
    // Set cron expression (định nghĩa lịch chạy)
    factoryBean.setCronExpression(cronExpression);
    // Set thời gian bắt đầu
    factoryBean.setStartTime(calendar.getTime());
    // Set delay = 0 để không có độ trễ
    factoryBean.setStartDelay(0L);
    // Set tên cho trigger
    factoryBean.setName(triggerName);
    // Set misfire instruction: không làm gì khi miss fire
    factoryBean.setMisfireInstruction(CronTrigger.MISFIRE_INSTRUCTION_DO_NOTHING);

    return factoryBean;
  }

  // Phương thức static để tạo SimpleTriggerFactoryBean (trigger chạy theo interval)
  public static SimpleTriggerFactoryBean createTrigger(JobDetail jobDetail, long pollFreqMs, String triggerName) {
    // Log thông tin tạo simple trigger
    log.info("createTrigger(jobDetail: {}, pollFreqMs: {}, triggerName: {})", jobDetail.getKey(), pollFreqMs, triggerName);
    // Tạo SimpleTriggerFactoryBean
    SimpleTriggerFactoryBean factoryBean = new SimpleTriggerFactoryBean();
    // Set job detail cho trigger
    factoryBean.setJobDetail(jobDetail);
    // Set delay = 0 để trigger chạy ngay
    factoryBean.setStartDelay(0L);
    // Set interval giữa các lần chạy (tính bằng milliseconds)
    factoryBean.setRepeatInterval(pollFreqMs);
    // Set tên cho trigger
    factoryBean.setName(triggerName);
    // Set repeat count = vô hạn để trigger chạy mãi mãi
    factoryBean.setRepeatCount(SimpleTrigger.REPEAT_INDEFINITELY);
    // Set misfire instruction: reschedule với remaining count khi miss fire
    factoryBean.setMisfireInstruction(SimpleTrigger.MISFIRE_INSTRUCTION_RESCHEDULE_NEXT_WITH_REMAINING_COUNT);
    return factoryBean;
  }
}
```

Tạo job cụ thể:
```java
package com.didan.schedule.config;

// Import class UseQuartz - đây là job implementation sẽ được thực thi
import com.didan.schedule.processor.UseQuartz;
// Import JobDetail từ Quartz để định nghĩa job
import org.quartz.JobDetail;
// Import Qualifier để chỉ định bean cụ thể khi inject
import org.springframework.beans.factory.annotation.Qualifier;
// Import Bean annotation để đánh dấu phương thức tạo bean
import org.springframework.context.annotation.Bean;
// Import Configuration để đánh dấu class này là configuration class
import org.springframework.context.annotation.Configuration;
// Import các factory bean để tạo cron trigger
import org.springframework.scheduling.quartz.CronTriggerFactoryBean;
// Import factory bean để tạo job detail
import org.springframework.scheduling.quartz.JobDetailFactoryBean;
// Import factory bean để tạo simple trigger
import org.springframework.scheduling.quartz.SimpleTriggerFactoryBean;

// Annotation đánh dấu đây là class cấu hình Spring
@Configuration
public class QuartzSubmitJob {

  // Bean tạo JobDetail cho User Service
  // name = "jobUserService" - đặt tên cho bean để có thể reference sau này
  @Bean(name = "jobUserService")
  public JobDetailFactoryBean jobUserService() {
    // Sử dụng utility method từ QuartzConfig để tạo JobDetail
    // UseQuartz.class - class chứa logic xử lý job
    // "User Service" - tên hiển thị của job
    return QuartzConfig.createJobDetail(UseQuartz.class, "User Service");
  }

  // Bean tạo SimpleTrigger cho User Service - chạy theo interval cố định
  // name = "triggerJobUserService" - đặt tên cho trigger bean
  @Bean(name = "triggerJobUserService")
  public SimpleTriggerFactoryBean triggerJobUserService(@Qualifier("jobUserService")JobDetail jobDetail) {
    // @Qualifier("jobUserService") - chỉ định inject bean jobUserService đã tạo ở trên
    // JobDetail jobDetail - job detail sẽ được gắn với trigger này

    // Sử dụng utility method từ QuartzConfig để tạo SimpleTrigger
    // jobDetail - job sẽ được trigger thực thi
    // 5000 - interval 5000ms (5 giây) giữa các lần chạy
    // "triggerUserService" - tên của trigger
    return QuartzConfig.createTrigger(jobDetail, 5000, "triggerUserService");
  }

  // Bean tạo CronTrigger cho User Service - chạy theo cron expression
  // name = "cronTriggerJobUserService" - đặt tên cho cron trigger bean
  @Bean(name = "cronTriggerJobUserService")
  public CronTriggerFactoryBean cronTriggerJobUserService(@Qualifier("jobUserService")JobDetail jobDetail) {
    // @Qualifier("jobUserService") - chỉ định inject bean jobUserService đã tạo ở trên
    // JobDetail jobDetail - job detail sẽ được gắn với cron trigger này

    // Sử dụng utility method từ QuartzConfig để tạo CronTrigger
    // jobDetail - job sẽ được trigger thực thi
    // "0/5 * * * * ?" - cron expression: chạy mỗi 5 giây
    //   0/5 - bắt đầu từ giây 0, lặp lại mỗi 5 giây
    //   * - mọi phút
    //   * - mọi giờ
    //   * - mọi ngày trong tháng
    //   * - mọi tháng
    //   ? - không quan tâm ngày trong tuần
    // "cronTriggerUserService" - tên của cron trigger
    return QuartzConfig.createCronTrigger(jobDetail, "0/5 * * * * ?", "cronTriggerUserService");
  }
}
```

### 4.4. Ví dụ
Tạo lớp Job để các tác vụ muốn thực hiện sẽ kế thừa:
```java
package com.didan.schedule.processor;

import lombok.extern.slf4j.Slf4j;
import org.quartz.Job;
import org.quartz.JobExecutionContext;

@Slf4j
public abstract class QuartzContextJob implements Job {

  @Override
  public void execute(JobExecutionContext jobExecutionContext) {
    run(jobExecutionContext);
  }

  public abstract void run(JobExecutionContext context);
}
```
Tạo lớp thực thi Job cụ thể:
```java
package com.didan.schedule.processor;

// Import config để xử lý TaskExecutor
import com.didan.schedule.config.TaskExecutorConfig;
// Import service để gọi business logic
import com.didan.schedule.service.UserService;
// Import utility class chứa static data
import com.didan.schedule.utils.Data;
// Import Lombok annotation để tự động tạo logger
import lombok.extern.slf4j.Slf4j;
// Import annotation của Quartz để ngăn chặn việc thực thi đồng thời
import org.quartz.DisallowConcurrentExecution;
// Import context chứa thông tin về job execution
import org.quartz.JobExecutionContext;
// Import Spring annotation để inject dependency
import org.springframework.beans.factory.annotation.Autowired;
// Import interface TaskExecutor để thực thi task bất đồng bộ
import org.springframework.core.task.TaskExecutor;
// Import Spring annotation để đánh dấu component
import org.springframework.stereotype.Component;

// Annotation Lombok để tự động tạo logger với tên là log
@Slf4j
// Annotation Spring để đánh dấu đây là component, được quản lý bởi Spring container
@Component
// Annotation Quartz để ngăn chặn việc thực thi đồng thời của cùng một job
// Nếu job đang chạy và chưa hoàn thành, trigger tiếp theo sẽ bị bỏ qua
// Điều này đảm bảo chỉ có một instance của job chạy tại một thời điểm
@DisallowConcurrentExecution
public class UseQuartz extends QuartzContextJob {

  // Inject UserService để thực hiện business logic
  @Autowired
  private UserService userService;

  // Inject TaskExecutor (thread pool) để th��c thi task bất đồng bộ
  @Autowired
  private TaskExecutor threadPoolTaskExecutor;

  // Override phương thức run từ QuartzContextJob để định nghĩa logic job
  @Override
  public void run(JobExecutionContext context) {
    try {
      // Gọi utility method để kiểm tra và điều chỉnh thread pool
      // Tham số 8 là maxPoolSize - giới hạn số thread tối đa
      // Nếu số active thread >= 8, sẽ sleep 200ms để chờ
      TaskExecutorConfig.handlerTask(threadPoolTaskExecutor, 8);

      // Submit task vào thread pool để thực thi bất đồng bộ
      threadPoolTaskExecutor.execute(() -> {
        // Log thông tin job đang chạy với tên job và index tăng dần
        // Data.BEGIN_IDX++ - counter static để đếm số lần job chạy
        log.info("Quartz {} is running every 5 seconds, with IDX: [{}]",
            context.getJobDetail().getKey().getName(), // Tên của job
            Data.BEGIN_IDX++); // Index tăng dần mỗi lần chạy

        // Gọi UserService để thực hiện business logic chính
        userService.getUsers();
      });
    } catch (Exception ex) {
      // Bắt và log mọi exception xảy ra trong quá trình thực thi job
      log.error("Error in Quartz", ex);
    } finally {
      // Block finally luôn được thực thi, dù có exception hay không
      // Log thông báo job đã hoàn thành
      log.info("Quartz job {} is done", context.getJobDetail().getKey().getName());
    }
  }
}
```

### 4.5. Lợi ích khi sử dụng Quartz
- **Mạnh mẽ và linh hoạt**: Hỗ trợ các tác vụ phức tạp và lập lịch theo lịch âm, tuần, tháng.
- **Hỗ trợ phân tán**: Có thể quản lý các tác vụ theo lịch trình trên nhiều máy chủ hoặc dịch vụ khác nhau.
- **Quản lý tốt hơn**: Hỗ trợ các tính năng như hủy bỏ các tác vụ đã lên lịch, quản lý trạng thái của các tác vụ, và hỗ trợ các tính năng như retry, timeout.
### 4.6. Nhược điểm
- **Cấu hình phức tạp**: Cần cấu hình nhiều hơn so với `@Scheduled` và `TaskScheduler`.
- **Kích thước lớn**: Thư viện `Quartz` có kích thước lớn hơn so với các giải pháp khác, có thể ảnh hưởng đến kích thước ứng dụng của bạn.
- **Yêu cầu kiến thức chuyên sâu**: Việc sử dụng `Quartz` yêu cầu bạn phải có kiến thức chuyên sâu về cách hoạt động của nó, bao gồm các khái niệm như job, trigger, scheduler, và các tính năng nâng cao khác.

## 5. Sử dụng TaskExecutor để thực thi các tác vụ bất đồng bộ
### 5.1. Giới thiệu
`TaskExecutor` là một interface trong Spring cho phép bạn thực thi các tác vụ bất đồng bộ. Nó cung cấp các phương thức để thực thi các tác vụ một cách linh hoạt và hiệu quả. Bạn có thể sử dụng `TaskExecutor` để thực thi các tác vụ trong các thread riêng biệt, giúp cải thiện hiệu suất và khả năng mở rộng của ứng dụng.
### 5.2. Cấu hình
Để sử dụng `TaskExecutor`, bạn cần định nghĩa một bean của loại `TaskExecutor`. Spring cung cấp một số triển khai của `TaskExecutor`, bao gồm `ThreadPoolTaskExecutor` và `SimpleAsyncTaskExecutor`.
```java
package com.didan.schedule.config;

// Import Lombok annotation để tự động tạo logger
import lombok.extern.slf4j.Slf4j;
// Import Bean annotation để đánh dấu phương thức tạo bean
import org.springframework.context.annotation.Bean;
// Import Configuration để đánh dấu class này là configuration class
import org.springframework.context.annotation.Configuration;
// Import interface TaskExecutor - interface chung cho việc thực thi task bất đồng bộ
import org.springframework.core.task.TaskExecutor;
// Import implementation cụ thể của TaskExecutor sử dụng thread pool
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;

// Annotation đánh dấu đây là class cấu hình Spring
@Configuration
// Annotation Lombok để tự động tạo logger với tên là log
@Slf4j
public class TaskExecutorConfig {

  // Bean tạo TaskExecutor với tên "threadPoolTaskExecutor"
  @Bean({"threadPoolTaskExecutor"})
  public TaskExecutor getAsyncExecutor() {
    // Log thông báo bắt đầu tạo Async Task Executor
    log.info("Creating Async Task Executor");

    // Tạo instance của ThreadPoolTaskExecutor - implementation cụ thể của TaskExecutor
    ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();

    // Thiết lập số thread cơ bản (core) = 5
    // Đây là số thread tối thiểu luôn được giữ trong pool, ngay cả khi idle
    executor.setCorePoolSize(5);

    // Thiết lập số thread tối đa = 8
    // Pool có thể mở rộng đến 8 thread khi có nhiều task chờ xử lý
    executor.setMaxPoolSize(8);

    // Thiết lập kích thước queue = 20
    // Khi tất cả core thread bận, task mới sẽ được đưa vào queue chờ
    // Chỉ khi queue đầy, pool mới tạo thêm thread (đến maxPoolSize)
    executor.setQueueCapacity(20);

    // Đặt prefix cho tên thread = "Async-"
    // Các thread sẽ có tên dạng: Async-1, Async-2, ...
    executor.setThreadNamePrefix("Async-");

    // Chờ các task hoàn thành trước khi shutdown ứng dụng
    // Đảm bảo không mất task khi application stop
    executor.setWaitForTasksToCompleteOnShutdown(true);

    // Thiết lập thời gian sống của thread idle = 30 giây
    // Thread vượt quá core size sẽ bị terminate sau 30s không hoạt động
    executor.setKeepAliveSeconds(30);

    // Set task decorator để copy MDC (Mapped Diagnostic Context) giữa các thread
    // Giúp maintain logging context trong async execution
    executor.setTaskDecorator(new MdcTaskDecorator());

    // Thiết lập handler xử lý khi task bị reject (khi pool và queue đều đầy)
    executor.setRejectedExecutionHandler((runnable, exec) -> {
      try {
        // Kiểm tra executor chưa shutdown
        if (!exec.isShutdown()) {
          // Thử đưa task vào queue một lần nữa (blocking)
          // put() sẽ chờ đến khi có chỗ trống trong queue
          exec.getQueue().put(runnable);

          // Log debug thông tin về việc retry task
          log.debug("Task rejected, retrying. ActiveCount: {}, CompletedCount: {}, Queue: {}",
              exec.getActiveCount(), // Số thread đang active
              exec.getCompletedTaskCount(), // Số task đã hoàn thành
              exec.getQueue().size()); // Số task trong queue
        } else {
          // Nếu executor đang shutdown, không thể queue task
          log.error("Executor is shutting down, cannot queue task.");
        }
      } catch (InterruptedException ex) {
        // Xử lý exception khi bị interrupt trong quá trình put vào queue
        log.error("Task rejected exception {}", ex.getMessage());
        // Restore interrupt status cho thread hiện tại
        Thread.currentThread().interrupt();
      }
    });

    // Khởi tạo executor (tạo core threads)
    executor.initialize();
    return executor;
  }

  // Phương thức static để xử lý task - kiểm tra và điều chỉnh thread pool
  public static void handlerTask(TaskExecutor executor, int maxPoolSize) {
    try {
      // Kiểm tra executor có phải là ThreadPoolTaskExecutor không
      if (executor instanceof ThreadPoolTaskExecutor) {
        // Cast về ThreadPoolTaskExecutor để truy cập các method cụ thể
        ThreadPoolTaskExecutor threadPool = (ThreadPoolTaskExecutor) executor;

        // Log thông tin về pool size hiện tại và yêu cầu
        log.info("Handling task. Current max pool size: {}, Requested max pool size: {}",
            threadPool.getMaxPoolSize(), // Max pool size hiện tại
            maxPoolSize); // Max pool size được yêu cầu

        // Lấy số thread đang active (đang xử lý task)
        int activeThread = threadPool.getActiveCount();

        // Kiểm tra nếu số thread active >= maxPoolSize yêu cầu
        if (activeThread >= maxPoolSize) {
          // Log warning và sleep 200ms để chờ
          log.warn("Current max pool size exceeded, waiting task.");
          // Sleep ngắn để giảm tải và chờ một số task hoàn thành
          Thread.sleep(200);
        }
      }
    } catch (InterruptedException ex) {
      // Xử lý exception khi bị interrupt trong quá trình sleep
      log.error("Handler task exception {}", ex.getMessage());
      // Restore interrupt status cho thread hiện tại
      Thread.currentThread().interrupt();
    }
  }

}
```