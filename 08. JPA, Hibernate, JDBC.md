# Sử dụng JPA, Hibernate, JDBC, H2 Database trong SpringBoot
## 1. H2 Database
H2 Database là một cơ sở dữ liệu in-memory, hỗ trợ phát triển ứng dụng SpringBoot mà không cần cấu hình cơ sở dữ liệu.

Dữ liệu trong H2 Database sẽ bị mất khi ứng dụng SpringBoot bị tắt.

Để sử dụng H2 Database trong ứng dụng SpringBoot, chúng ta cần thêm các library như `H2 Database`, `Spring Data JPA`, `Spring Data JDBC`

### 1.1. Cấu hình cho phép truy cập vào H2 Database từ URL
Để cho phép truy cập vào H2 Database từ URL, chúng ta cần cấu hình trong file `application.properties` hoặc `application.yml`.

Mặc định đường dẫn truy cập vào H2 Database là `http://localhost:8080/h2-console`.

Khi truy cập vào đường dẫn này, chúng ta cần có đường dẫn JDBC URL của H2 Database. Đường dẫn này sẽ được hiển thị trong console khi chúng ta chạy ứng dụng SpringBoot. Ngoài ra ta có thể tùy chỉnh đường dẫn JDBC URL trong file `application.properties` hoặc `application.yml` với prefix là `jdbc:h2:mem:`.

Ví dụ:
```properties
# Chỉ cho phép truy cập vào H2 Database từ URL
spring.h2.console.enabled=true 
# Đường dẫn JDBC URL của H2 Database
spring.datasource.url=jdbc:h2:mem:testdb
# Tên driver của H2 Database, mặc định là org.h2.Driver
spring.datasource.driver-class-name=org.h2.Driver 
# Tên người dùng của H2 Database, mặc định là sa
spring.datasource.username=sa
# Mật khẩu người dùng của H2 Database, mặc định là trống
spring.datasource.password=''
# Cấu hình Dialect của H2 Database dùng cho Hibernate
jpa.database-platform=org.hibernate.dialect.H2Dialect
# Mặc định cho phép khởi tạo schema.sql, data.sql khi ứng dụng SpringBoot khởi chạy (H2 mặc định không cần cấu hình)
spring.sql.init.mode=always
# Mặc định các file init.sql sẽ được chạy ngay khi ứng dụng SpringBoot khởi chạy, nếu dùng JPA tạo schema thì sẽ gây lỗi vì khi data.sql chạy nos sẽ không tìm được bảng. Vì thế cần phải config cho Hibernate chạy trước init.sql
spring.jpa.defer-datasource-initialization=true
```

### 1.2. Tạo schema khi ứng dụng SpringBoot khởi chạy
Để tạo schema khi ứng dụng SpringBoot khởi chạy, chúng ta cần thêm file `schema.sql` hoặc `data.sql` vào thư mục `src/main/resources`.

File `schema.sql` sẽ chứa các câu lệnh SQL để tạo schema, còn file `data.sql` sẽ chứa các câu lệnh SQL để insert dữ liệu vào schema.

Sau khi chạy ứng dụng SpringBoot, các câu lệnh SQL trong file `schema.sql` và `data.sql` sẽ tự động được thực thi.

## 2. Sử dụng JDBC Template
Trong SpringBoot, chúng ta có thể sử dụng `JdbcTemplate` để thao tác với cơ sở dữ liệu thông qua JDBC.

JDBC Template cung cấp các phương thức để thực thi các câu lệnh SQL như:
- `query`: Thực thi câu lệnh SQL truy vấn dữ liệu từ cơ sở dữ liệu.
- `update`: Thực thi câu lệnh SQL thêm, sửa, xóa dữ liệu từ cơ sở dữ liệu.
- `batchUpdate`: Thực thi nhiều câu lệnh SQL cùng một lúc.
- `execute`: Thực thi câu lệnh SQL không trả về kết quả.
- `queryForObject`: Thực thi câu lệnh SQL truy vấn một dòng dữ liệu từ cơ sở dữ liệu.
- `queryForList`: Thực thi câu lệnh SQL truy vấn nhiều dòng dữ liệu từ cơ sở dữ liệu.
- `queryForMap`: Thực thi câu lệnh SQL truy vấn dữ liệu từ cơ sở dữ liệu và trả về dữ liệu dưới dạng Map.
- `queryForRowSet`: Thực thi câu lệnh SQL truy vấn dữ liệu từ cơ sở dữ liệu và trả về dữ liệu dưới dạng `SqlRowSet`.
- `queryForStream`: Thực thi câu lệnh SQL truy vấn dữ liệu từ cơ sở dữ liệu và trả về dữ liệu dưới dạng `Stream`.

Để sử dụng `JdbcTemplate`, chúng ta cần thêm dependency `spring-boot-starter-jdbc` vào file `pom.xml`.

### 2.1. Sử dung JdbcTemplate + H2 Database
Sau khi cấu hình H2 Database, chúng ta có thể sử dụng `JdbcTemplate` để thao tác với cơ sở dữ liệu H2 Database.

- INSERT, UPDATE, DELETE dữ liệu
Ví dụ:
> JdbcTemplateExample.java
```java
package com.example.demo;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

@Repository
public class JdbcTemplateExample {

    @Autowired
    private JdbcTemplate jdbcTemplate; // Inject JdbcTemplate vào để thao tác với cơ sở dữ liệu

    private String INSERT_DATA = """
            INSERT INTO users (id, name) VALUES (1, 'John')
            """; // Câu lệnh SQL thêm dữ liệu vào bảng users, sử dung cú pháp mới của Java 13, ba dấu nháy kép dùng để viết chuỗi trên nhiều dòng, và String phải đặt trong dấu ngoặc đơn.
    
    // Sử dụng ? để tuỳ biến giá trị
    private String DELETE_DATA = """DELETE FROM users WHERE id = ?""";

    private String INSERT_DATA2 = "INSERT INTO users (id, name) VALUES (?, ?)";

    public void createTable() {
        jdbcTemplate.execute("CREATE TABLE IF NOT EXISTS users (id INT, name VARCHAR(255))");
    }

    public void insertData() {
        jdbcTemplate.update(INSERT_DATA);
    }

    public void selectData() {
        jdbcTemplate.query("SELECT * FROM users", (rs, rowNum) -> {
            System.out.println(rs.getInt("id") + " " + rs.getString("name"));
            return null;
        });
    }

    public void deleteData() {
        jdbcTemplate.update(DELETE_DATA, 1); // Xóa dữ liệu có id = 1
    }

    public void insertData2(Person person) {
        jdbcTemplate.update(INSERT_DATA2, person.getId(), person.getName()); // Thêm dữ liệu từ đối tượng Person
    }
}
```

Trong ví dụ trên, chúng ta đã tạo một class `JdbcTemplateExample` để thao tác với cơ sở dữ liệu H2 Database thông qua `JdbcTemplate`.

Để sử dụng `JdbcTemplate`, chúng ta cần inject `JdbcTemplate` vào class và sử dụng các phương thức của `JdbcTemplate` để thao tác với cơ sở dữ liệu.

Ví dụ thực thi các câu lệnh dữ liệu ngay sau khi chạy ứng dụng SpringBoot:
> AppRunner.java
```java

package com.example.demo;

import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

@Component
public class AppRunner implements CommandLineRunner {

    private final JdbcTemplateExample jdbcTemplateExample;

    public AppRunner(JdbcTemplateExample jdbcTemplateExample) {
        this.jdbcTemplateExample = jdbcTemplateExample;
    }

    @Override
    public void run(String... args) throws Exception {
        jdbcTemplateExample.createTable();
        jdbcTemplateExample.insertData();
        jdbcTemplateExample.selectData();
    }
}
```

- SELECT dữ liệu:
    + Để truy vấn dữ liệu từ cơ sở dữ liệu, chúng ta sử dụng phương thức `queryForObject` của `JdbcTemplate`.
    + Phương thức `queryForObject` sẽ trả về một đối tượng `Person` sau khi thực thi câu lệnh SQL truy vấn dữ liệu từ cơ sở dữ liệu.
    + Trước khi trả về đối tượng `Person`, chúng ta cần cấu hình `RowMapper` để ánh xạ dữ liệu từ cơ sở dữ liệu vào đối tượng `Person`, việc mapping này sẽ được thực hiện trong `new BeanPropertyRowMapper<>(Person.class)`.
    + Và trong class `Person`, chúng ta cần cung cấp các getter, setter cho các trường dữ liệu, vì `BeanPropertyRowMapper` sẽ sử dụng reflection để ánh xạ dữ liệu, set dữ liệu từ cơ sở dữ liệu vào đối tượng `Person`.
Ví dụ:
> Person.java
```java
package com.example.demo;

public class Person {

    private int id;
    private String name;

    public Person() {
    }

    public Person(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

> JdbcTemplateExample.java
```java

package com.example.demo;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

@Repository
public class JdbcTemplateExample {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    public Person selectData(long id) {
        return jdbcTemplate.query("SELECT * FROM users WHERE id = ?", new BeanPropertyRowMapper<>(Person.class), id);
    }
}
```

## 3. Sử dụng Spring Data JPA
Spring Data JPA là một phần của Spring Data, cung cấp các phương thức để thao tác với cơ sở dữ liệu thông qua JPA.

Spring JPA làm cho việc thao tác với cơ sở dữ liệu trở nên dễ dàng hơn, chúng ta không cần phải viết các câu lệnh SQL mà chỉ cần viết các phương thức trong interface, Spring JPA sẽ tự động sinh ra các câu lệnh SQL tương ứng. Khác với `JdbcTemplate`, chúng ta cần phải viết các câu lệnh SQL thủ công.

Để sử dụng Spring Data JPA, chúng ta cần thêm dependency `spring-boot-starter-data-jpa` vào file `pom.xml`.

### 3.1. Sử dụng Spring Data JPA + H2 Database
Sau khi cấu hình H2 Database, chúng ta có thể sử dụng Spring Data JPA để thao tác với cơ sở dữ liệu H2 Database.

- Tạo Entity
Entity là một class đại diện cho một bảng trong cơ sở dữ liệu.

Entity sử dụng annotation `@Entity` để đánh dấu, và annotation `@Id` để đánh dấu trường dữ liệu là khóa chính.

Ví dụ:
> User.java
```java
package com.example.demo;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Column;

@Entity(name = "users") // name: Tên bảng trong cơ sở dữ liệu
public class User {

    @Id
    private int id;

    @Column(name = "name") // name: Tên cột trong bảng
    private String name;

    // Cần phải có các phương thức getter, setter để dữ liệu từ cơ sở dữ liệu có thể set vào đối tượng User

    public User() {
    }

    public User(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

- Tạo Repository
Repository là một interface, chứa các phương thức để thao tác với cơ sở dữ liệu.

Spring Data JPA sẽ tự động sinh ra các câu lệnh SQL tương ứng với các phương thức trong Repository.

Ví dụ:
> UserRepository.java
```java
package com.example.demo;

import org.springframework.stereotype.Repository;

import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import jakarta.transaction.Transactional;

@Repository // Đánh dấu đây là Repository
@Transactional // Đánh dấu đây là phương thức transaction dùng để thực thi các câu lệnh SQL mà không cần commit hoặc rollback
public class UserJpa {
	@PersistenceContext // Inject EntityManager để thao tác với cơ sở dữ liệu (tương tự @Autowired)
	private EntityManager entityManager; // EntityManager dùng để thao tác với cơ sở dữ liệu
	
	public void insert(User user) {
		entityManager.merge(user); // Thêm dữ liệu vào cơ sở dữ liệu (merge: thêm mới hoặc cập nhật dữ liệu)
	}


	public void deleteId(long id) {
		User user = entityManager.find(User.class, id); // Tìm kiếm dữ liệu trong cơ sở dữ liệu với tham số đầu tiên là class, tham số thứ hai là khóa chính
		entityManager.remove(user); // Xóa dữ liệu trong cơ sở dữ liệu với tham số là đối tượng cần xóa
	}

	public User getUser(long id) {
		return entityManager.find(User.class, id); // Tìm kiếm dữ liệu trong cơ sở dữ liệu với tham số đầu tiên là class, tham số th
	}
}
```

- Để nhìn thấy các câu lệnh SQL được sinh ra bởi Spring Data JPA, chúng ta cần cấu hình trong file `application.properties` hoặc `application.yml`: `spring.jpa.show-sql=true`.

### 3.2. Sử dụng Spring Data JPA + H2 Database
Spring Data JPA cung cấp các phương thức để thao tác với cơ sở dữ liệu thông qua JPA. Giúp chúng ta thao tác với cơ sở dữ liệu một cách dễ dàng hơn so với JPA.

Spring Data JPA cung cấp các phương thức như `save`, `delete`, `findById`, `findAll`, `count`, `existsById`, `existsByName`, `findBy...`, `deleteBy...`, `countBy...`, `existsBy...`.

Ngoài ra, chúng ta cũng có thể viết các câu lệnh SQL tùy chỉnh thông qua annotation `@Query`.

Bên cạnh đó chúng ta có thể tự đinh nghĩa phương thức trong Repository, Spring Data JPA sẽ tự động sinh ra các câu lệnh SQL tương ứng, theo quy tắc `camelCase` với các cú pháp như:
    + `findBy...`: Tìm kiếm dữ liệu theo trường dữ liệu.
    + `deleteBy...`: Xóa dữ liệu theo trường dữ liệu.
    + `countBy...`: Đếm số lượng dữ liệu theo trường dữ liệu.
    + `existsByName`: Kiểm tra dữ liệu có tồn tại theo trường Name dữ liệu hay không.
    + `findFirstByEntity1_NameAndEntity2_Age`: Tìm kiếm dữ liệu đầu tiên theo trường dữ liệu của Entity1 và Entity2.
    + Các Custom JPA query (find(Count)(First, Top10)By(Username)(OrderBy)(Asc), findAllBy, ...)

Để làm việc với Spring Data JPA, chúng ta cần tạo Entity và Repository.
> UserRepository.java
```java
package com.example.demo;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface UserRepository extends JpaRepository<Tên Entity, Kiểu dữ liệu của cột Id> {
    // Các phương thức sẽ được sinh ra tự động hoặc có thể tự định nghĩa phương thức tùy chỉnh ở đây
    // @Query("SELECT * FROM users WHERE name = :name")
    // User findByName(String name);

    // User findByName(String name);
}
```

## 4. Sự khác nhau giữa JPA và Hibernate
- JPA (Java Persistence API) là một chuẩn API, cung cấp các phương thức để thao tác với cơ sở dữ liệu thông qua JPA: Nó được dùng để định nghĩa các Entity, quản lý các Entity, thực thi các câu lệnh SQL.

- Hibernate là một framework, cung cấp các phương thức để thao tác với cơ sở dữ liệu thông qua JPA.
    + Nó cung cấp các phương thức để thực thi các câu lệnh SQL, quản lý các Entity, thực thi các transaction.
    + Hibernate cung cấp các phương thức để thực thi các câu lệnh SQL, cung cấp các phương thức để thao tác với cơ sở dữ liệu.
    + Là 1 thực thi của JPA.

## 5. Sử dụng JPA + MySQL
### 5.1. Cấu hình MySQL
Để sử dụng MySQL trong ứng dụng SpringBoot, chúng ta cần thêm dependency `mysql-connector-java` vào file `pom.xml`.
```xml
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <scope>runtime</scope>
</dependency>
```

### 5.2. Cấu hình MySQL trong `application.properties`
```properties
# Cấu hình kết nối MySQL
spring.datasource.url=jdbc:mysql://localhost:<PORT>/<DATABASE_NAME>
# Tên người dùng MySQL
spring.datasource.username=<USERNAME>
# Mật khẩu người dùng MySQL
spring.datasource.password=<PASSWORD>
# Cấu hình Dialect của MySQL dùng cho Hibernate
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
# Cấu hình tạo bảng tự động khi ứng dụng khởi chạy với JPA
spring.jpa.hibernate.ddl-auto=update
# Mặc định cho phép khởi tạo schema.sql, data.sql khi ứng dụng SpringBoot khởi chạy (H2 mặc định không cần cấu hình)
spring.sql.init.mode=always
# Mặc định các file init.sql sẽ được chạy ngay khi ứng dụng SpringBoot khởi chạy, nếu dùng JPA tạo schema thì sẽ gây lỗi vì khi data.sql chạy nos sẽ không tìm được bảng. Vì thế cần phải config cho Hibernate chạy trước init.sql
spring.jpa.defer-datasource-initialization=true
```

## 6. Các quan hệ (Relationship) trong JPA
### 6.1. Một - Một (One-to-One)
Một quan hệ `One-to-One` là một quan hệ mà một đối tượng của Entity1 tương ứng với một đối tượng của Entity2.

Sử dụng annotation `@OneToOne` để đánh dấu quan hệ `One-to-One`. Annotation `@JoinColumn` để đánh dấu khóa ngoại.

Ngoài ra, Trường hợp đặc biệt, nếu khóa chính của `Entity1` vừa ược tham chiếu bởi khóa ngoại của `Entity2` cũng vừa làm khóa chính của `Entity2` luôn thì chúng ta có thể sử dụng: 
- `@PrimaryKeyJoinColumn` để đánh dấu khóa chính của `Entity1` đồng thời cũng làm khóa ngoại tham chiếu đến `Entity2`.
- `@MapsId` để tránh việc tạo thêm một cột khóa ngoại trong `Entity2` vì `Entity2` đã sử dụng khóa chính của `Entity1` làm khóa chính cũng làm khóa ngoại.

Ví dụ:
> Person.java
```java
package com.example.demo;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.OneToOne;
import jakarta.persistence.PrimaryKeyJoinColumn;

@Entity
public class Person {

    @Id
    private int personId;

    private String name;

    @OneToOne
    @PrimaryKeyJoinColumn // Khóa chính của Person cũng làm khóa ngoại của PersonDetail tham chiếu đến Person
    private PersonDetail personDetail;

    // Các phương thức getter, setter
}
```

> PersonDetail.java
```java
package com.example.demo;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.MapsId;
import jakarta.persistence.OneToOne;
import jakarta.persistence.JoinColumn;

@Entity
public class PersonDetail {

    @Id
    private int id;

    private String address;

    @OneToOne
    @MapsId // Tránh việc tạo thêm một cột khóa ngoại trong PersonDetail vì PersonDetail đã sử dụng khóa chính của Person làm khóa chính cũng làm khóa ngoại
    @JoinColumn(name = "id") // Khóa ngoại tham chiếu đến Person (id: Khóa chính của PersonDetail)
    private Person person;

    // Các phương thức getter, setter
}
```

### 6.2. Một - Nhiều (One-to-Many)
Một quan hệ `One-to-Many` là một quan hệ mà một đối tượng của Entity1 tương ứng với nhiều đối tượng của Entity2.

Sử dụng annotation `@OneToMany` để đánh dấu quan hệ `One-to-Many`. Annotation `@JoinColumn` để đánh dấu khóa ngoại. 

Trong Annotation `@OneToMany`, chúng ta cần chỉ định trường tham chiếu đến khóa chính của Entity1 thông qua thuộc tính `mappedBy` với giá trị là tên trường tham chiếu.

Trong Annotation `@JoinColumn`, có thuộc tính như `name` dùng để chỉ định tên cột khóa ngoại, `referencedColumnName` dùng để chỉ định tên cột mà khóa ngoại tham chiếu đến của bảng tham chiếu.

Ví dụ:
> Person.java
```java
package com.example.demo;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.OneToMany;
import jakarta.persistence.JoinColumn;

@Entity
public class Person {

    @Id
    private int personId;

    private String name;

    @OneToMany(mappedBy = "person") // Trường tham chiếu đến khóa chính của Person trong PersonDetail
    private List<PersonDetail> personDetails;

    // Các phương thức getter, setter
}
```

> PersonDetail.java
```java
package com.example.demo;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.JoinColumn;

@Entity
public class PersonDetail {

    @Id
    private int id;

    private String address;

    @ManyToOne
    @JoinColumn(name = "personId") // Khóa ngoại tham chiếu đến Person (personId: Khóa chính của PersonDetail)
    private Person person;

    // Các phương thức getter, setter
}
```

### 6.3. Nhiều - Nhiều (Many-to-Many)
Một quan hệ `Many-to-Many` là một quan hệ mà một đối tượng của Entity1 tương ứng với nhiều đối tượng của Entity2 và ngược lại.

Sử dụng annotation `@ManyToMany` để đánh dấu quan hệ `Many-to-Many`. Annotation `@JoinTable` để đánh dấu bảng trung gian.

Trong Annotation `@ManyToMany`, chúng ta cần chỉ định trường tham chiếu đến khóa chính của Entity1 thông qua thuộc tính `mappedBy` với giá trị là tên trường tham chiếu.

Trong Annotation `@JoinTable`, có thuộc tính như `name` dùng để chỉ định tên bảng trung gian, `joinColumns` dùng để chỉ định tên cột khóa ngoại của bảng trung gian tham chiếu đến bảng hiện tại, `inverseJoinColumns` dùng để chỉ định tên cột khóa ngoại của bảng trung gian tham chiếu đến bảng tham chiếu.

Ví dụ:
> Person.java
```java
package com.example.demo;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.JoinTable;
import jakarta.persistence.JoinColumn;

@Entity
public class Person {

    @Id
    private int personId;

    private String name;

    @ManyToMany
    @JoinTable(
        name = "person_address", // Tên bảng trung gian
        joinColumns = @JoinColumn(name = "personId"), // Tên cột khóa ngoại của bảng trung gian tham chiếu đến bảng hiện tại
        inverseJoinColumns = @JoinColumn(name = "addressId") // Tên cột khóa ngoại của bảng trung gian tham chiếu đến bảng tham chiếu
    )
    private List<Address> addresses;

    // Các phương thức getter, setter
}
```

> Address.java
```java
package com.example.demo;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.JoinTable;
import jakarta.persistence.JoinColumn;

@Entity
public class Address {

    @Id
    private int addressId;

    private String address;

    @ManyToMany(mappedBy = "addresses") // Trường tham chiếu đến khóa chính của Person trong PersonDetail
    private List<Person> persons;

    // Các phương thức getter, setter
}
```

### 6.4. Thiết lập siêu khóa (Super Key) trong JPA
Siêu khóa (Super Key) là một tập hợp các trường dữ liệu mà khi kết hợp với nhau sẽ tạo thành một khóa duy nhất.

Trong JPA, chúng ta có thể thiết lập siêu khóa thông qua annotation `@Embeddable`, `@Embeddid` và kế thừa từ class `Serializable`.

Ví dụ, ta có một class `Person` với siêu khóa là `PersonId` bao gồm các trường `id`, `name`:
> PersonId.java
```java
package com.example.demo;

import java.io.Serializable;
import jakarta.persistence.Embeddable;
import jakarta.persistence.Column;

@Embeddable
public class PersonId implements Serializable {
    @Column(name = "id")
    private int id;
    @Column(name = "name")
    private String name;

    // Các contructors, phương thức getter, setter
}
```
> Person.java
```java
package com.example.demo;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.EmbeddedId;

@Entity
public class Person {

    @EmbeddedId
    private PersonId personId;

    // Các phương thức getter, setter
}
```

### 6.5. Cascade, FetchType trong JPA
- `Cascade`: Cascade là một thuộc tính trong JPA, dùng để chỉ định hành vi của các thao tác CRUD (Create, Read, Update, Delete) giữa các Entity. Giúp chúng ta thực thi các thao tác CRUD giữa các Entity một cách tự động. Và điều kiện để sử dụng Cascade là cần phải thiết lập quan hệ giữa các Entity.

Để sử dụng `Cascade`, có thuộc tính `cascade` bên trong các Annotation quan hệ. Có các loại Cascade như:
    + `CascadeType.ALL`: Tất cả các thao tác CRUD sẽ được thực thi. Khi thực thi thao tác CRUD trên Entity1, thao tác CRUD tương ứng sẽ được thực thi trên Entity2.
    + `CascadeType.PERSIST`: Thao tác thêm dữ liệu sẽ được thực thi. Khi thêm dữ liệu vào Entity1, dữ liệu tương ứng sẽ được thêm vào Entity2.
    + `CascadeType.MERGE`: Thao tác cập nhật dữ liệu sẽ được thực thi. Khi cập nhật dữ liệu trong Entity1, dữ liệu tương ứng sẽ được cập nhật trong Entity2.
    + `CascadeType.REMOVE`: Thao tác xóa dữ liệu sẽ được thực thi. Khi xóa dữ liệu trong Entity1, dữ liệu tương ứng sẽ được xóa trong Entity2.
    + `CascadeType.REFRESH`: Thao tác làm mới dữ liệu sẽ được thực thi. Khi làm mới dữ liệu trong Entity1, dữ liệu tương ứng sẽ được làm mới trong Entity2.
    + `CascadeType.DETACH`: Thao tác tách dữ liệu sẽ được thực thi. Khi tách dữ liệu trong Entity1, dữ liệu tương ứng sẽ được tách trong Entity2.

Ví dụ:
> Person.java
```java
package com.example.demo;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.OneToOne;
import jakarta.persistence.CascadeType;

@Entity
public class Person {

    @Id
    private int personId;

    private String name;

    @OneToOne(cascade = CascadeType.ALL) // Tất cả các thao tác CRUD sẽ được thực thi khi thực thi thao tác CRUD trên Person
    private PersonDetail personDetail;

    // Các phương thức getter, setter
}
```

- `FetchType`: FetchType là một thuộc tính trong JPA, dùng để chỉ định cách lấy dữ liệu từ cơ sở dữ liệu. FetchType có hai loại là `EAGER` và `LAZY`. Mặc định FetchType là `EAGER`.

    + `EAGER`: Khi FetchType là EAGER, dữ liệu sẽ được lấy ngay lập tức khi thực thi câu lệnh truy vấn. Dữ liệu sẽ được lấy từ cơ sở dữ liệu ngay lập tức và lưu vào bộ nhớ.
    + `LAZY`: Khi FetchType là LAZY, dữ liệu sẽ không được lấy ngay lập tức khi thực thi câu lệnh truy vấn. Dữ liệu sẽ được lấy từ cơ sở dữ liệu khi cần thiết.

Ví dụ:
> Person.java
```java
package com.example.demo;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.OneToOne;
import jakarta.persistence.FetchType;

@Entity
public class Person {

    @Id
    private int personId;

    private String name;

    @OneToOne(fetch = FetchType.LAZY) // Dữ liệu sẽ không được lấy ngay lập tức khi thực thi câu lệnh truy vấn
    private PersonDetail personDetail;

    // Các phương thức getter, setter
}
```

## 7. Các Annotation khác phục vụ cho JPA
Chúng ta có thể sử dụng `Lombok` để giảm bớt số lượng code trong class Entity như `@Data`, `@Getter`, `@Setter`, `@NoArgsConstructor`, `@AllArgsConstructor`, `@Builder`, `@ToString`, `@EqualsAndHashCode`.

- `@Data` là một Annotation trong `Lombok`, dùng để tự động tạo các phương thức `getter`, `setter`, `toString`, `equals`, `hashCode` cho các trường dữ liệu trong class.

- `@Getter` là một Annotation trong `Lombok`, dùng để tự động tạo các phương thức `getter` cho các trường dữ liệu trong class.

- `@Setter` là một Annotation trong `Lombok`, dùng để tự động tạo các phương thức `setter` cho các trường dữ liệu trong class.

- `@NoArgsConstructor` là một Annotation trong `Lombok`, dùng để tự động tạo một contructor không có tham số cho class.

- `@AllArgsConstructor` là một Annotation trong `Lombok`, dùng để tự động tạo một contructor có tham số cho class.

- `@Builder` là một Annotation trong `Lombok`, dùng để tạo một Builder Pattern cho class.

- `@ToString` là một Annotation trong `Lombok`, dùng để tự động tạo phương thức `toString` cho class.

- `@EqualsAndHashCode` là một Annotation trong `Lombok`, dùng để tự động tạo phương thức `equals` và `hashCode` cho class.

Ngoài ra còn có các Annotation khác như:
- `@MappedSuperclass`: Đánh dấu class là một class cha, các class con sẽ kế thừa các trường dữ liệu từ class cha.
- `@Column`: Đánh dấu trường dữ liệu là một cột trong cơ sở dữ liệu.
    + `@Column(name = "name")`: Đánh dấu tên cột trong cơ sở dữ liệu.
    + `@Column(nullable = false)`: Đánh dấu trường dữ liệu không được null.
    + `@Column(unique = true)`: Đánh dấu trường dữ liệu là duy nhất.
    + `@Column(length = 255)`: Đánh dấu độ dài của trường dữ liệu.
    + `@Column(updatable = false)`: Đánh dấu trường dữ liệu không được phép cập nhật dữ liệu vì nó là trường dữ liệu chỉ đọc.
    + `@Column(insertable = false)`: Đánh dấu trường dữ liệu không được phép thêm dữ liệu khi thêm mới dữ liệu vào cơ sở dữ liệu. Mục đích là để tránh việc thêm dữ liệu vào trường dữ liệu không cần thiết. Nó chỉ cho phép cập nhật dữ liệu.

- `@GeneratedValue`: Đánh dấu trường dữ liệu là một trường dữ liệu tự động tăng.
    + `@GeneratedValue(strategy = GenerationType.AUTO, generator = "native")`: Đánh dấu trường dữ liệu là một trường dữ liệu tự động tăng với chiến lược là `AUTO` và generator là `native`. `native` sẽ tự động chọn chiến lược tăng tự động phù hợp với cơ sở dữ liệu.
- `@GenericGenerator`: Đi kèm với `@GeneratedValue`, dùng để chỉ định chiến lược tăng tự động.
    + `@GenericGenerator(name = "native", strategy = "native")`: Đánh dấu chiến lược tăng tự động là `native`. `native` sẽ tự động chọn chiến lược tăng tự động phù hợp với cơ sở dữ liệu.