# Sử dụng JPA, Hibernate, JDBC, H2 Database trong SpringBoot
## 1. H2 Database
H2 Database là một cơ sở dữ liệu in-memory, hỗ trợ phát triển ứng dụng SpringBoot mà không cần cấu hình cơ sở dữ liệu.

Dữ liệu trong H2 Database sẽ bị mất khi ứng dụng SpringBoot bị tắt.

Để sử dụng H2 Database trong ứng dụng SpringBoot, chúng ta cần thêm các library như `H2 Database`, `Spring Data JPA`, `Spring Data JDBC`

### 1.1. Cấu hình cho phép truy cập vào H2 Database từ URL
Để cho phép truy cập vào H2 Database từ URL, chúng ta cần cấu hình trong file `application.properties` hoặc `application.yml`.

Mặc định đường dẫn truy cập vào H2 Database là `http://localhost:8080/h2-console`.

Khi truy cập vào đường dẫn này, chúng ta cần có đường dẫn JDBC URL của H2 Database. Đường dẫn này sẽ được hiển thị trong console khi chúng ta chạy ứng dụng SpringBoot. Ngoài ra ta có thể tùy chỉnh đường dẫn JDBC URL trong file `application.properties` hoặc `application.yml` với prefix là `jdbc:h2:mem:`.

Ví dụ:
```properties
# Chỉ cho phép truy cập vào H2 Database từ URL
spring.h2.console.enabled=true 
# Đường dẫn JDBC URL của H2 Database
spring.datasource.url=jdbc:h2:mem:testdb
# Tên driver của H2 Database, mặc định là org.h2.Driver
spring.datasource.driver-class-name=org.h2.Driver 
# Tên người dùng của H2 Database, mặc định là sa
spring.datasource.username=sa
# Mật khẩu người dùng của H2 Database, mặc định là trống
spring.datasource.password=''
# Cấu hình Dialect của H2 Database dùng cho Hibernate
jpa.database-platform=org.hibernate.dialect.H2Dialect
# Mặc định cho phép khởi tạo schema.sql, data.sql khi ứng dụng SpringBoot khởi chạy (H2 mặc định không cần cấu hình)
spring.sql.init.mode=always
# Mặc định các file init.sql sẽ được chạy ngay khi ứng dụng SpringBoot khởi chạy, nếu dùng JPA tạo schema thì sẽ gây lỗi vì khi data.sql chạy nos sẽ không tìm được bảng. Vì thế cần phải config cho Hibernate chạy trước init.sql
spring.jpa.defer-datasource-initialization=true
```

### 1.2. Tạo schema khi ứng dụng SpringBoot khởi chạy
Để tạo schema khi ứng dụng SpringBoot khởi chạy, chúng ta cần thêm file `schema.sql` hoặc `data.sql` vào thư mục `src/main/resources`.

File `schema.sql` sẽ chứa các câu lệnh SQL để tạo schema, còn file `data.sql` sẽ chứa các câu lệnh SQL để insert dữ liệu vào schema.

Sau khi chạy ứng dụng SpringBoot, các câu lệnh SQL trong file `schema.sql` và `data.sql` sẽ tự động được thực thi.

## 2. Sử dụng JDBC Template
Trong SpringBoot, chúng ta có thể sử dụng `JdbcTemplate` để thao tác với cơ sở dữ liệu thông qua JDBC.

JDBC Template cung cấp các phương thức để thực thi các câu lệnh SQL như:
- `query`: Thực thi câu lệnh SQL truy vấn dữ liệu từ cơ sở dữ liệu.
- `update`: Thực thi câu lệnh SQL thêm, sửa, xóa dữ liệu từ cơ sở dữ liệu.
- `batchUpdate`: Thực thi nhiều câu lệnh SQL cùng một lúc.
- `execute`: Thực thi câu lệnh SQL không trả về kết quả.
- `queryForObject`: Thực thi câu lệnh SQL truy vấn một dòng dữ liệu từ cơ sở dữ liệu.
- `queryForList`: Thực thi câu lệnh SQL truy vấn nhiều dòng dữ liệu từ cơ sở dữ liệu.
- `queryForMap`: Thực thi câu lệnh SQL truy vấn dữ liệu từ cơ sở dữ liệu và trả về dữ liệu dưới dạng Map.
- `queryForRowSet`: Thực thi câu lệnh SQL truy vấn dữ liệu từ cơ sở dữ liệu và trả về dữ liệu dưới dạng `SqlRowSet`.
- `queryForStream`: Thực thi câu lệnh SQL truy vấn dữ liệu từ cơ sở dữ liệu và trả về dữ liệu dưới dạng `Stream`.

Để sử dụng `JdbcTemplate`, chúng ta cần thêm dependency `spring-boot-starter-jdbc` vào file `pom.xml`.

### 2.1. Sử dung JdbcTemplate + H2 Database
Sau khi cấu hình H2 Database, chúng ta có thể sử dụng `JdbcTemplate` để thao tác với cơ sở dữ liệu H2 Database.

- INSERT, UPDATE, DELETE dữ liệu
Ví dụ:
> JdbcTemplateExample.java
```java
package com.example.demo;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

@Repository
public class JdbcTemplateExample {

    @Autowired
    private JdbcTemplate jdbcTemplate; // Inject JdbcTemplate vào để thao tác với cơ sở dữ liệu

    private String INSERT_DATA = """
            INSERT INTO users (id, name) VALUES (1, 'John')
            """; // Câu lệnh SQL thêm dữ liệu vào bảng users, sử dung cú pháp mới của Java 13, ba dấu nháy kép dùng để viết chuỗi trên nhiều dòng, và String phải đặt trong dấu ngoặc đơn.
    
    // Sử dụng ? để tuỳ biến giá trị
    private String DELETE_DATA = """DELETE FROM users WHERE id = ?""";

    private String INSERT_DATA2 = "INSERT INTO users (id, name) VALUES (?, ?)";

    public void createTable() {
        jdbcTemplate.execute("CREATE TABLE IF NOT EXISTS users (id INT, name VARCHAR(255))");
    }

    public void insertData() {
        jdbcTemplate.update(INSERT_DATA);
    }

    public void selectData() {
        jdbcTemplate.query("SELECT * FROM users", (rs, rowNum) -> {
            System.out.println(rs.getInt("id") + " " + rs.getString("name"));
            return null;
        });
    }

    public void deleteData() {
        jdbcTemplate.update(DELETE_DATA, 1); // Xóa dữ liệu có id = 1
    }

    public void insertData2(Person person) {
        jdbcTemplate.update(INSERT_DATA2, person.getId(), person.getName()); // Thêm dữ liệu từ đối tượng Person
    }
}
```

Trong ví dụ trên, chúng ta đã tạo một class `JdbcTemplateExample` để thao tác với cơ sở dữ liệu H2 Database thông qua `JdbcTemplate`.

Để sử dụng `JdbcTemplate`, chúng ta cần inject `JdbcTemplate` vào class và sử dụng các phương thức của `JdbcTemplate` để thao tác với cơ sở dữ liệu.

Ví dụ thực thi các câu lệnh dữ liệu ngay sau khi chạy ứng dụng SpringBoot:
> AppRunner.java
```java

package com.example.demo;

import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

@Component
public class AppRunner implements CommandLineRunner {

    private final JdbcTemplateExample jdbcTemplateExample;

    public AppRunner(JdbcTemplateExample jdbcTemplateExample) {
        this.jdbcTemplateExample = jdbcTemplateExample;
    }

    @Override
    public void run(String... args) throws Exception {
        jdbcTemplateExample.createTable();
        jdbcTemplateExample.insertData();
        jdbcTemplateExample.selectData();
    }
}
```

- SELECT dữ liệu:
    + Để truy vấn dữ liệu từ cơ sở dữ liệu, chúng ta sử dụng phương thức `queryForObject` của `JdbcTemplate`.
    + Phương thức `queryForObject` sẽ trả về một đối tượng `Person` sau khi thực thi câu lệnh SQL truy vấn dữ liệu từ cơ sở dữ liệu.
    + Trước khi trả về đối tượng `Person`, chúng ta cần cấu hình `RowMapper` để ánh xạ dữ liệu từ cơ sở dữ liệu vào đối tượng `Person`, việc mapping này sẽ được thực hiện trong `new BeanPropertyRowMapper<>(Person.class)`.
    + Và trong class `Person`, chúng ta cần cung cấp các getter, setter cho các trường dữ liệu, vì `BeanPropertyRowMapper` sẽ sử dụng reflection để ánh xạ dữ liệu, set dữ liệu từ cơ sở dữ liệu vào đối tượng `Person`.
Ví dụ:
> Person.java
```java
package com.example.demo;

public class Person {

    private int id;
    private String name;

    public Person() {
    }

    public Person(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

> JdbcTemplateExample.java
```java

package com.example.demo;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

@Repository
public class JdbcTemplateExample {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    public Person selectData(long id) {
        return jdbcTemplate.query("SELECT * FROM users WHERE id = ?", new BeanPropertyRowMapper<>(Person.class), id);
    }
}
```

## 3. Sử dụng Spring Data JPA
Spring Data JPA là một phần của Spring Data, cung cấp các phương thức để thao tác với cơ sở dữ liệu thông qua JPA.

Spring JPA làm cho việc thao tác với cơ sở dữ liệu trở nên dễ dàng hơn, chúng ta không cần phải viết các câu lệnh SQL mà chỉ cần viết các phương thức trong interface, Spring JPA sẽ tự động sinh ra các câu lệnh SQL tương ứng. Khác với `JdbcTemplate`, chúng ta cần phải viết các câu lệnh SQL thủ công.

Để sử dụng Spring Data JPA, chúng ta cần thêm dependency `spring-boot-starter-data-jpa` vào file `pom.xml`.

### 3.1. Sử dụng Spring Data JPA + H2 Database
Sau khi cấu hình H2 Database, chúng ta có thể sử dụng Spring Data JPA để thao tác với cơ sở dữ liệu H2 Database.

- Tạo Entity
Entity là một class đại diện cho một bảng trong cơ sở dữ liệu.

Entity sử dụng annotation `@Entity` để đánh dấu, và annotation `@Id` để đánh dấu trường dữ liệu là khóa chính.

Ví dụ:
> User.java
```java
package com.example.demo;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Column;

@Entity(name = "users") // name: Tên bảng trong cơ sở dữ liệu
public class User {

    @Id
    private int id;

    @Column(name = "name") // name: Tên cột trong bảng
    private String name;

    // Cần phải có các phương thức getter, setter để dữ liệu từ cơ sở dữ liệu có thể set vào đối tượng User

    public User() {
    }

    public User(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

- Tạo Repository
Repository là một interface, chứa các phương thức để thao tác với cơ sở dữ liệu.

Spring Data JPA sẽ tự động sinh ra các câu lệnh SQL tương ứng với các phương thức trong Repository.

Ví dụ:
> UserRepository.java
```java
package com.example.demo;

import org.springframework.stereotype.Repository;

import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import jakarta.transaction.Transactional;

@Repository // Đánh dấu đây là Repository
@Transactional // Đánh dấu đây là phương thức transaction dùng để thực thi các câu lệnh SQL mà không cần commit hoặc rollback
public class UserJpa {
	@PersistenceContext // Inject EntityManager để thao tác với cơ sở dữ liệu (tương tự @Autowired)
	private EntityManager entityManager; // EntityManager dùng để thao tác với cơ sở dữ liệu
	
	public void insert(User user) {
		entityManager.merge(user); // Thêm dữ liệu vào cơ sở dữ liệu (merge: thêm mới hoặc cập nhật dữ liệu)
	}


	public void deleteId(long id) {
		User user = entityManager.find(User.class, id); // Tìm kiếm dữ liệu trong cơ sở dữ liệu với tham số đầu tiên là class, tham số thứ hai là khóa chính
		entityManager.remove(user); // Xóa dữ liệu trong cơ sở dữ liệu với tham số là đối tượng cần xóa
	}

	public User getUser(long id) {
		return entityManager.find(User.class, id); // Tìm kiếm dữ liệu trong cơ sở dữ liệu với tham số đầu tiên là class, tham số th
	}
}
```

- Để nhìn thấy các câu lệnh SQL được sinh ra bởi Spring Data JPA, chúng ta cần cấu hình trong file `application.properties` hoặc `application.yml`: `spring.jpa.show-sql=true`.

### 3.2. Sử dụng Spring Data JPA + H2 Database
Spring Data JPA cung cấp các phương thức để thao tác với cơ sở dữ liệu thông qua JPA. Giúp chúng ta thao tác với cơ sở dữ liệu một cách dễ dàng hơn so với JPA.

Spring Data JPA cung cấp các phương thức như `save`, `delete`, `findById`, `findAll`, `count`, `existsById`, `existsByName`, `findBy...`, `deleteBy...`, `countBy...`, `existsBy...`.

Ngoài ra, chúng ta cũng có thể viết các câu lệnh SQL tùy chỉnh thông qua annotation `@Query`.

Bên cạnh đó chúng ta có thể tự đinh nghĩa phương thức trong Repository, Spring Data JPA sẽ tự động sinh ra các câu lệnh SQL tương ứng, theo quy tắc `camelCase` với các cú pháp như:
    + `findBy...`: Tìm kiếm dữ liệu theo trường dữ liệu.
    + `deleteBy...`: Xóa dữ liệu theo trường dữ liệu.
    + `countBy...`: Đếm số lượng dữ liệu theo trường dữ liệu.
    + `existsByName`: Kiểm tra dữ liệu có tồn tại theo trường Name dữ liệu hay không.
    + `findFirstByEntity1_NameAndEntity2_Age`: Tìm kiếm dữ liệu đầu tiên theo trường dữ liệu của Entity1 và Entity2.
    + Các Custom JPA query (find(Count)(First, Top10)By(Username)(OrderBy)(Asc), findAllBy, ...)

> Lưu ý: Đối với các `method` làm thay đổi dữ liệu trong database như `save`, `delete`, `update`, `insert`, `deleteBy...`, `updateBy...` thì cần phải thêm annotation `@Transactional` và `@Modifying` để đảm bảo tính toàn vẹn dữ liệu nếu quá trình thực thi có lỗi, dữ liệu sẽ được rollback.

Để làm việc với Spring Data JPA, chúng ta cần tạo Entity và Repository.
> UserRepository.java
```java
package com.example.demo;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface UserRepository extends JpaRepository<Tên Entity, Kiểu dữ liệu của cột Id> {
    // Các phương thức sẽ được sinh ra tự động hoặc có thể tự định nghĩa phương thức tùy chỉnh ở đây
    // @Query("SELECT * FROM users WHERE name = :name")
    // User findByName(String name);

    // User findByName(String name);

    // @Transactional
    // @Modifying
    // void deleteByName(String name);
}
```

## 4. Sự khác nhau giữa JPA và Hibernate
- JPA (Java Persistence API) là một chuẩn API, cung cấp các phương thức để thao tác với cơ sở dữ liệu thông qua JPA: Nó được dùng để định nghĩa các Entity, quản lý các Entity, thực thi các câu lệnh SQL.

- Hibernate là một framework, cung cấp các phương thức để thao tác với cơ sở dữ liệu thông qua JPA.
    + Nó cung cấp các phương thức để thực thi các câu lệnh SQL, quản lý các Entity, thực thi các transaction.
    + Hibernate cung cấp các phương thức để thực thi các câu lệnh SQL, cung cấp các phương thức để thao tác với cơ sở dữ liệu.
    + Là 1 thực thi của JPA.

## 5. Sử dụng JPA + MySQL
### 5.1. Cấu hình MySQL
Để sử dụng MySQL trong ứng dụng SpringBoot, chúng ta cần thêm dependency `mysql-connector-java` vào file `pom.xml`.
```xml
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <scope>runtime</scope>
</dependency>
```

### 5.2. Cấu hình MySQL trong `application.properties`
```properties
# Cấu hình kết nối MySQL
spring.datasource.url=jdbc:mysql://localhost:<PORT>/<DATABASE_NAME>
# Tên người dùng MySQL
spring.datasource.username=<USERNAME>
# Mật khẩu người dùng MySQL
spring.datasource.password=<PASSWORD>
# Cấu hình Dialect của MySQL dùng cho Hibernate
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
# Cấu hình tạo bảng tự động khi ứng dụng khởi chạy với JPA
spring.jpa.hibernate.ddl-auto=update
# Mặc định cho phép khởi tạo schema.sql, data.sql khi ứng dụng SpringBoot khởi chạy (H2 mặc định không cần cấu hình)
spring.sql.init.mode=always
# Mặc định các file init.sql sẽ được chạy ngay khi ứng dụng SpringBoot khởi chạy, nếu dùng JPA tạo schema thì sẽ gây lỗi vì khi data.sql chạy nos sẽ không tìm được bảng. Vì thế cần phải config cho Hibernate chạy trước init.sql
spring.jpa.defer-datasource-initialization=true
```

### 5.3. Cấu hình Spring Boot kết nối với nhiều cơ sở dữ liệu khác nhau
Trong Spring Boot, chúng ta có thể cấu hình kết nối với nhiều cơ sở dữ liệu khác nhau. Ví dụ này sẽ hướng dẫn cách cấu hình kết nối với 2 cơ sở dữ liệu MySQL.

Để cấu hình kết nối với nhiều cơ sở dữ liệu, chúng ta cần thêm các dependency `mysql-connector-java` và `spring-boot-starter-data-jpa` vào file `pom.xml`.

#### 5.3.1. Cấu hình thông số của cơ sở dữ liệu trong `application.properties`
Mặc định, Chúng ta cấu hình database ở trong thuộc tính `spring.datasource` của file `application.properties`.

Bây giờ với việc cấu hình nhiều cơ sở dữ liệu, chúng ta cần cấu hình thông số của cơ sở dữ liệu trong các thuộc tính `spring.datasource.<name1>` và `spring.datasource.<name2>`.

> Lưu ý, `name1` và `name2` chúng ta có thể đặt tùy ý theo quy tắc `camelCase`.

Ví dụ:
> application.yml
```yaml
spring:
  application:
    name: posts
  jpa:
    hibernate:
      ddl-auto: update
    properties:
      hibernate:
        dialect: org.hibernate.dialect.MySQL8Dialect
    show-sql: true
  datasource:
    postdb: # Database 1
      url: jdbc:mysql://localhost:3306/forum_posts
      username: 'root'
      password: '17052002'
      driver-class-name: com.mysql.cj.jdbc.Driver
      hikari:
        maximum-pool-size: 10 # Số lượng kết nối tối đa
        connection-timeout: 60000 # Thời gian kết nối tối đa
        max-lifetime: 590000 # Thời gian sống tối đa của kết nối
    reportdb: # Database 2
      url: jdbc:mysql://localhost:3306/forum_reports
      username: 'root'
      password: '17052002'
      driver-class-name: com.mysql.cj.jdbc.Driver
      hikari:
        maximum-pool-size: 10
        connection-timeout: 60000
        max-lifetime: 590000
```

#### 5.3.2. Cấu hình `EntityManager` cho từng cơ sở dữ liệu
Bởi vì có nhiều cấu hình kết nối tới database, nên `Spring Boot` không thể biết được `EntityManager` nào sẽ được sử dụng cho từng cơ sở dữ liệu. Vì vậy, chúng ta cần cấu hình `EntityManager` cho từng cơ sở dữ liệu để xác định từng `Entity` nào sẽ được quản lý bởi `Database` nào và `Repository` nào.

> PostDatabaseConfig.java
```java
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import javax.sql.DataSource;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.autoconfigure.jdbc.DataSourceProperties;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@Slf4j
@Configuration // Đánh dấu đây là class cấu hình
@EnableTransactionManagement // Kích hoạt quản lý transaction
@EnableJpaRepositories( // Kích hoạt quản lý JPA Repository
    entityManagerFactoryRef = "postsEntityManagerFactory", // Tên EntityManagerFactory sẽ được quản lý bởi postsEntityManagerFactory
    transactionManagerRef = "postsTransactionManager", // Tên TransactionManager sẽ được quản lý bởi postsTransactionManager
    basePackages = {"com.didan.forum.posts.repository.post"} // Đường dẫn package chứa Repository của database posts
)
public class PostDatabaseConfig {

  @Primary // Đánh dấu đây là Bean mặc định (Sử dụng db posts làm mặc định)
  @Bean  // Đánh dấu đây là Bean
  @ConfigurationProperties("spring.datasource.postdb") // Cấu hình DataSourceProperties cho database posts (Chính là các thông số cấu hình trong application.properties)
  public DataSourceProperties postsDataSourceProperties() {
    return new DataSourceProperties();
  }

  @Primary
  @Bean(name = "postsDataSource") // Đặt tên cho Bean
  @ConfigurationProperties(prefix = "spring.datasource.postdb.hiraki") // Cấu hình DataSource cho database posts
  public DataSource postsDataSource() { // Tạo DataSource cho database posts (Đây là các thông số cấu hình của Hikari)
    return postsDataSourceProperties().initializeDataSourceBuilder().build();
  }

  @Primary // Đánh dấu đây là Bean mặc định
  @Bean(name = "postsEntityManagerFactory") // Đặt tên cho Bean
  public LocalContainerEntityManagerFactoryBean postEntityManagerFactory( 
    EntityManagerFactoryBuilder builder, @Qualifier("postsDataSource") DataSource dataSource) {
    return builder
        .dataSource(dataSource)
        .packages("com.didan.forum.posts.entity.post") // Đường dẫn package chứa Entity của database posts
        .persistenceUnit("posts") // Đơn vị persistence (Nên đặt tên khác nhau cho từng database)
        .properties(hibernateProperties()) // Cấu hình Hibernate
        .build();
  }

  @Primary
  @Bean(name = "postsTransactionManager") // Đặt tên cho Bean
  public PlatformTransactionManager postsTransactionManager(@Qualifier("postsEntityManagerFactory") // TransactionManager cho database posts
      LocalContainerEntityManagerFactoryBean postsEntityManagerFactory) { 
    return new JpaTransactionManager(Objects.requireNonNull(postsEntityManagerFactory.getObject())); // Tạo TransactionManager
  }

  private Map<String, Object> hibernateProperties() { // Cấu hình Hibernate
    Map<String, Object> properties = new HashMap<>(); 
    properties.put("hibernate.hbm2ddl.auto", "update"); // Cập nhật cấu trúc bảng tự động khi ứng dụng khởi chạy
    properties.put("hibernate.dialect", "org.hibernate.dialect.MySQL8Dialect"); // Dialect của MySQL 
    return properties;
  }

}
```

> ReportDatabaseConfig.java
```java
@Slf4j
@Configuration // Đánh dấu đây là class cấu hình
@EnableTransactionManagement // Kích hoạt quản lý transaction
@EnableJpaRepositories( // Kích hoạt quản lý JPA Repository
    entityManagerFactoryRef = "reportsEntityManagerFactory", // Tên EntityManagerFactory sẽ được quản lý bởi reportsEntityManagerFactory
    transactionManagerRef = "reportsTransactionManager", // Tên TransactionManager sẽ được quản lý bởi reportsTransactionManager
    basePackages = {"com.didan.forum.posts.repository.report"} // Đường dẫn package chứa Repository của database reports
)
public class ReportDatabaseConfig {
  @Bean(name = "reportsDataSourceConfig") // Đặt tên cho Bean
  @ConfigurationProperties("spring.datasource.reportdb") // Cấu hình DataSourceProperties cho database reports (Chính là các thông số cấu hình trong application.properties)
  public DataSourceProperties postsDataSourceProperties() {
    return new DataSourceProperties(); // Tạo DataSourceProperties cho database reports
  }

  @Bean(name = "reportsDataSource") // Đặt tên cho Bean
  @ConfigurationProperties(prefix = "spring.datasource.reportdb.hiraki") // Cấu hình DataSource cho database reports
  public DataSource reportsDataSource() { // Tạo DataSource cho database reports (Đây là các thông số cấu hình của Hikari)
    return postsDataSourceProperties().initializeDataSourceBuilder().build();
  }

  @Bean(name = "reportsEntityManagerFactory")
  public LocalContainerEntityManagerFactoryBean reportsEntityManagerFactory( // EntityManagerFactory cho database reports
      EntityManagerFactoryBuilder builder, @Qualifier("reportsDataSource") DataSource dataSource) {
    return builder
        .dataSource(dataSource) // Sử dụng DataSource của database reports
        .packages("com.didan.forum.posts.entity.report") // Đường dẫn package chứa Entity của database reports
        .persistenceUnit("reports") // Đơn vị persistence (Nên đặt tên khác nhau cho từng database)
        .properties(hibernateProperties()) // Cấu hình Hibernate
        .build();
  }

  @Primary
  @Bean(name = "reportsTransactionManager")
  public PlatformTransactionManager reportsTransactionManager(@Qualifier("reportsEntityManagerFactory") 
  LocalContainerEntityManagerFactoryBean postsEntityManagerFactory) { // TransactionManager cho database reports
    return new JpaTransactionManager(Objects.requireNonNull(postsEntityManagerFactory.getObject()));
  }

  private Map<String, Object> hibernateProperties() { // Cấu hình Hibernate
    Map<String, Object> properties = new HashMap<>();
    properties.put("hibernate.hbm2ddl.auto", "update"); // Cập nhật cấu trúc bảng tự động khi ứng dụng khởi chạy
    properties.put("hibernate.dialect", "org.hibernate.dialect.MySQL8Dialect"); // Dialect của MySQL
    return properties;
  }
}
``` 

Sau đó, chúng ta có thể tạo các `Entity` và `Repository` cho từng cơ sở dữ liệu vào trong các package tương ứng đã khai báo trong `PostDatabaseConfig` và `ReportDatabaseConfig`.

## 6. Các quan hệ (Relationship) trong JPA
### 6.1. Một - Một (One-to-One)
Một quan hệ `One-to-One` là một quan hệ mà một đối tượng của Entity1 tương ứng với một đối tượng của Entity2.

Sử dụng annotation `@OneToOne` để đánh dấu quan hệ `One-to-One`. Annotation `@JoinColumn` để đánh dấu khóa ngoại.

Ngoài ra, Trường hợp đặc biệt, nếu khóa chính của `Entity1` vừa ược tham chiếu bởi khóa ngoại của `Entity2` cũng vừa làm khóa chính của `Entity2` luôn thì chúng ta có thể sử dụng: 
- `@PrimaryKeyJoinColumn` để đánh dấu khóa chính của `Entity1` đồng thời cũng làm khóa ngoại tham chiếu đến `Entity2`.
- `@MapsId` để tránh việc tạo thêm một cột khóa ngoại trong `Entity2` vì `Entity2` đã sử dụng khóa chính của `Entity1` làm khóa chính cũng làm khóa ngoại.

Ví dụ:
> Person.java
```java
package com.example.demo;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.OneToOne;
import jakarta.persistence.PrimaryKeyJoinColumn;

@Entity
public class Person {

    @Id
    private int personId;

    private String name;

    @OneToOne
    @PrimaryKeyJoinColumn // Khóa chính của Person cũng làm khóa ngoại của PersonDetail tham chiếu đến Person
    private PersonDetail personDetail;

    // Các phương thức getter, setter
}
```

> PersonDetail.java
```java
package com.example.demo;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.MapsId;
import jakarta.persistence.OneToOne;
import jakarta.persistence.JoinColumn;

@Entity
public class PersonDetail {

    @Id
    private int id;

    private String address;

    @OneToOne
    @MapsId // Tránh việc tạo thêm một cột khóa ngoại trong PersonDetail vì PersonDetail đã sử dụng khóa chính của Person làm khóa chính cũng làm khóa ngoại
    @JoinColumn(name = "id") // Khóa ngoại tham chiếu đến Person (id: Khóa chính của PersonDetail)
    private Person person;

    // Các phương thức getter, setter
}
```

### 6.2. Một - Nhiều (One-to-Many)
Một quan hệ `One-to-Many` là một quan hệ mà một đối tượng của Entity1 tương ứng với nhiều đối tượng của Entity2.

Sử dụng annotation `@OneToMany` để đánh dấu quan hệ `One-to-Many`. Annotation `@JoinColumn` để đánh dấu khóa ngoại. 

Trong Annotation `@OneToMany`, chúng ta cần chỉ định trường tham chiếu đến khóa chính của Entity1 thông qua thuộc tính `mappedBy` với giá trị là tên trường tham chiếu.

Trong Annotation `@JoinColumn`, có thuộc tính như `name` dùng để chỉ định tên cột khóa ngoại, `referencedColumnName` dùng để chỉ định tên cột mà khóa ngoại tham chiếu đến của bảng tham chiếu.

Ví dụ:
> Person.java
```java
package com.example.demo;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.OneToMany;
import jakarta.persistence.JoinColumn;

@Entity
public class Person {

    @Id
    private int personId;

    private String name;

    @OneToMany(mappedBy = "person") // Trường tham chiếu đến khóa chính của Person trong PersonDetail
    private List<PersonDetail> personDetails;

    // Các phương thức getter, setter
}
```

> PersonDetail.java
```java
package com.example.demo;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.JoinColumn;

@Entity
public class PersonDetail {

    @Id
    private int id;

    private String address;

    @ManyToOne
    @JoinColumn(name = "personId") // Khóa ngoại tham chiếu đến Person (personId: Khóa chính của PersonDetail)
    private Person person;

    // Các phương thức getter, setter
}
```

### 6.3. Nhiều - Nhiều (Many-to-Many)
Một quan hệ `Many-to-Many` là một quan hệ mà một đối tượng của Entity1 tương ứng với nhiều đối tượng của Entity2 và ngược lại.

Sử dụng annotation `@ManyToMany` để đánh dấu quan hệ `Many-to-Many`. Annotation `@JoinTable` để đánh dấu bảng trung gian.

Trong Annotation `@ManyToMany`, chúng ta cần chỉ định trường tham chiếu đến khóa chính của Entity1 thông qua thuộc tính `mappedBy` với giá trị là tên trường tham chiếu.

Trong Annotation `@JoinTable`, có thuộc tính như `name` dùng để chỉ định tên bảng trung gian, `joinColumns` dùng để chỉ định tên cột khóa ngoại của bảng trung gian tham chiếu đến bảng hiện tại, `inverseJoinColumns` dùng để chỉ định tên cột khóa ngoại của bảng trung gian tham chiếu đến bảng tham chiếu.

Ví dụ:
> Person.java
```java
package com.example.demo;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.JoinTable;
import jakarta.persistence.JoinColumn;

@Entity
public class Person {

    @Id
    private int personId;

    private String name;

    @ManyToMany
    @JoinTable(
        name = "person_address", // Tên bảng trung gian
        joinColumns = @JoinColumn(name = "personId"), // Tên cột khóa ngoại của bảng trung gian tham chiếu đến bảng hiện tại
        inverseJoinColumns = @JoinColumn(name = "addressId") // Tên cột khóa ngoại của bảng trung gian tham chiếu đến bảng tham chiếu
    )
    private List<Address> addresses;

    // Các phương thức getter, setter
}
```

> Address.java
```java
package com.example.demo;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.JoinTable;
import jakarta.persistence.JoinColumn;

@Entity
public class Address {

    @Id
    private int addressId;

    private String address;

    @ManyToMany(mappedBy = "addresses") // Trường tham chiếu đến khóa chính của Person trong PersonDetail
    private List<Person> persons;

    // Các phương thức getter, setter
}
```

### 6.4. Thiết lập siêu khóa (Super Key) trong JPA
Siêu khóa (Super Key) là một tập hợp các trường dữ liệu mà khi kết hợp với nhau sẽ tạo thành một khóa duy nhất.

Trong JPA, chúng ta có thể thiết lập siêu khóa thông qua annotation `@Embeddable`, `@Embeddid` và kế thừa từ class `Serializable`.

Ví dụ, ta có một class `Person` với siêu khóa là `PersonId` bao gồm các trường `id`, `name`:
> PersonId.java
```java
package com.example.demo;

import java.io.Serializable;
import jakarta.persistence.Embeddable;
import jakarta.persistence.Column;

@Embeddable
public class PersonId implements Serializable {
    @Column(name = "id")
    private int id;
    @Column(name = "name")
    private String name;

    // Các contructors, phương thức getter, setter
}
```
> Person.java
```java
package com.example.demo;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.EmbeddedId;

@Entity
public class Person {

    @EmbeddedId
    private PersonId personId;

    // Lần lượt JoinColumn các cột của PersonId với Entity khác với tùy chọn bắt buộc phải là:
    // updatable=false và insertable=false
    // Các phương thức getter, setter
}
```

### 6.5. Cascade, FetchType trong JPA
- `Cascade`: Cascade là một thuộc tính trong JPA, dùng để chỉ định hành vi của các thao tác CRUD (Create, Read, Update, Delete) giữa các Entity. Giúp chúng ta thực thi các thao tác CRUD giữa các Entity một cách tự động. Và điều kiện để sử dụng Cascade là cần phải thiết lập quan hệ giữa các Entity.

Để sử dụng `Cascade`, có thuộc tính `cascade` bên trong các Annotation quan hệ. Có các loại Cascade như:
    + `CascadeType.ALL`: Tất cả các thao tác CRUD sẽ được thực thi. Khi thực thi thao tác CRUD trên Entity1, thao tác CRUD tương ứng sẽ được thực thi trên Entity2.
    + `CascadeType.PERSIST`: Thao tác thêm dữ liệu sẽ được thực thi. Khi thêm dữ liệu vào Entity1, dữ liệu tương ứng sẽ được thêm vào Entity2.
    + `CascadeType.MERGE`: Thao tác cập nhật dữ liệu sẽ được thực thi. Khi cập nhật dữ liệu trong Entity1, dữ liệu tương ứng sẽ được cập nhật trong Entity2.
    + `CascadeType.REMOVE`: Thao tác xóa dữ liệu sẽ được thực thi. Khi xóa dữ liệu trong Entity1, dữ liệu tương ứng sẽ được xóa trong Entity2.
    + `CascadeType.REFRESH`: Thao tác làm mới dữ liệu sẽ được thực thi. Khi làm mới dữ liệu trong Entity1, dữ liệu tương ứng sẽ được làm mới trong Entity2.
    + `CascadeType.DETACH`: Thao tác tách dữ liệu sẽ được thực thi. Khi tách dữ liệu trong Entity1, dữ liệu tương ứng sẽ được tách trong Entity2.

Ví dụ:
> Person.java
```java
package com.example.demo;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.OneToOne;
import jakarta.persistence.CascadeType;

@Entity
public class Person {

    @Id
    private int personId;

    private String name;

    @OneToOne(cascade = CascadeType.ALL) // Tất cả các thao tác CRUD sẽ được thực thi khi thực thi thao tác CRUD trên Person
    private PersonDetail personDetail;

    // Các phương thức getter, setter
}
```

- `FetchType`: FetchType là một thuộc tính trong JPA, dùng để chỉ định cách lấy dữ liệu từ cơ sở dữ liệu. FetchType có hai loại là `EAGER` và `LAZY`. Mặc định FetchType là `EAGER`.

    + `EAGER`: Khi FetchType là EAGER, dữ liệu sẽ được lấy ngay lập tức khi thực thi câu lệnh truy vấn. Dữ liệu sẽ được lấy từ cơ sở dữ liệu ngay lập tức và lưu vào bộ nhớ.
    + `LAZY`: Khi FetchType là LAZY, dữ liệu sẽ không được lấy ngay lập tức khi thực thi câu lệnh truy vấn. Dữ liệu sẽ được lấy từ cơ sở dữ liệu khi cần thiết.

Ví dụ:
> Person.java
```java
package com.example.demo;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.OneToOne;
import jakarta.persistence.FetchType;

@Entity
public class Person {

    @Id
    private int personId;

    private String name;

    @OneToOne(fetch = FetchType.LAZY) // Dữ liệu sẽ không được lấy ngay lập tức khi thực thi câu lệnh truy vấn
    private PersonDetail personDetail;

    // Các phương thức getter, setter
}
```

## 7. Các Annotation khác phục vụ cho JPA
Chúng ta có thể sử dụng `Lombok` để giảm bớt số lượng code trong class Entity như `@Data`, `@Getter`, `@Setter`, `@NoArgsConstructor`, `@AllArgsConstructor`, `@Builder`, `@ToString`, `@EqualsAndHashCode`.

- `@Data` là một Annotation trong `Lombok`, dùng để tự động tạo các phương thức `getter`, `setter`, `toString`, `equals`, `hashCode` cho các trường dữ liệu trong class.

- `@Getter` là một Annotation trong `Lombok`, dùng để tự động tạo các phương thức `getter` cho các trường dữ liệu trong class.

- `@Setter` là một Annotation trong `Lombok`, dùng để tự động tạo các phương thức `setter` cho các trường dữ liệu trong class.

- `@NoArgsConstructor` là một Annotation trong `Lombok`, dùng để tự động tạo một contructor không có tham số cho class.

- `@AllArgsConstructor` là một Annotation trong `Lombok`, dùng để tự động tạo một contructor có tham số cho class.

- `@Builder` là một Annotation trong `Lombok`, dùng để tạo một Builder Pattern cho class.

- `@ToString` là một Annotation trong `Lombok`, dùng để tự động tạo phương thức `toString` cho class.

- `@EqualsAndHashCode` là một Annotation trong `Lombok`, dùng để tự động tạo phương thức `equals` và `hashCode` cho class.

Ngoài ra còn có các Annotation khác như:
- `@MappedSuperclass`: Đánh dấu class là một class cha, các class con sẽ kế thừa các trường dữ liệu từ class cha.
- `@Column`: Đánh dấu trường dữ liệu là một cột trong cơ sở dữ liệu.
    + `@Column(name = "name")`: Đánh dấu tên cột trong cơ sở dữ liệu.
    + `@Column(nullable = false)`: Đánh dấu trường dữ liệu không được null.
    + `@Column(unique = true)`: Đánh dấu trường dữ liệu là duy nhất.
    + `@Column(length = 255)`: Đánh dấu độ dài của trường dữ liệu.
    + `@Column(updatable = false)`: Đánh dấu trường dữ liệu không được phép cập nhật dữ liệu vì nó là trường dữ liệu chỉ đọc.
    + `@Column(insertable = false)`: Đánh dấu trường dữ liệu không được phép thêm dữ liệu khi thêm mới dữ liệu vào cơ sở dữ liệu. Mục đích là để tránh việc thêm dữ liệu vào trường dữ liệu không cần thiết. Nó chỉ cho phép cập nhật dữ liệu.

- `@GeneratedValue`: Đánh dấu trường dữ liệu là một trường dữ liệu tự động tăng.
    + `@GeneratedValue(strategy = GenerationType.AUTO, generator = "native")`: Đánh dấu trường dữ liệu là một trường dữ liệu tự động tăng với chiến lược là `AUTO` và generator là `native`. `native` sẽ tự động chọn chiến lược tăng tự động phù hợp với cơ sở dữ liệu.
- `@GenericGenerator`: Đi kèm với `@GeneratedValue`, dùng để chỉ định chiến lược tăng tự động.
    + `@GenericGenerator(name = "native", strategy = "native")`: Đánh dấu chiến lược tăng tự động là `native`. `native` sẽ tự động chọn chiến lược tăng tự động phù hợp với cơ sở dữ liệu.

### 7.1. Sử dụng `Auditing` trong JPA với `@CreatedDate`, `@LastModifiedDate`, `@CreatedBy`, `@LastModifiedBy`
`Auditing` là một tính năng trong JPA, dùng để theo dõi thời gian tạo, thời gian cập nhật, người tạo, người cập nhật dữ liệu.

Thông thường, nếu không sử dụng `Auditing`, chúng ta cần phải tự update thời gian tạo, thời gian cập nhật, người tạo, người cập nhật dữ liệu thủ công vào database.

Để sử dụng `Auditing`, chúng ta cần làm các bước sau:
- 1. Tạo 1 class `implements` `AuditorAware<T>`, trong đó `T` là kiểu dữ liệu của người tạo, người cập nhật dữ liệu.
    > AuditorAwareImpl.java
    ```java
    import java.util.Optional;
    import org.springframework.data.domain.AuditorAware;
    import org.springframework.stereotype.Component;
    
    @Component("auditAwareImpl") // Đánh dấu đây là Bean của Spring với tên là auditAwareImpl, dùng để inject vào class Application
    public class AuditAwareImpl implements AuditorAware<String> { // String: kiểu dữ liệu của createdBy và updatedBy
    
        @Override // Trả về tên người tạo hoặc cập nhật dữ liệu
        public Optional<String> getCurrentAuditor() { // getCurrentAuditor: lấy thông tin người tạo hoặc cập nhật dữ liệu
        	return Optional.of("ACCOUNT_MS"); // Trả về tên người tạo hoặc cập nhật dữ liệu
        }
	}
    ```

- 2. Đánh dấu các `entity`, `column` sử dụng `Audiiting` với các annotation của `springframework`
    > BasicEntity.java
    ```java
    @MappedSuperclass // Đánh dấu đây là Entity cha của các Entity khác sẽ kế thừa nó với các thuộc tính cơ bản
    @Getter @Setter @ToString 
    @EntityListeners(AuditingEntityListener.class) // Sử dụng AuditingEntityListener để tự động set giá trị cho các trường createdAt, createdBy, updatedAt, updatedBy
    public class BasicClass {
        @CreatedDate // Đánh dấu trường này sẽ tự động set giá trị cho nó khi insert dữ liệu
        @Column(name = "created_at", updatable = false) // updatable = false: không cho phép update trường này chỉ cho phép insert, đọc
        private LocalDateTime createdAt;
        
        @CreatedBy // Đánh dấu trường này sẽ tự động set giá trị cho nó khi insert dữ liệu
        @Column(name = "created_by", updatable = false) // updatable = false: không cho phép update trường này chỉ cho phép insert, đọc
        private String createdBy;
        
        @LastModifiedDate // Đánh dấu trường này sẽ tự động set giá trị cho nó khi update dữ liệu
        @Column(name = "updated_at", insertable = false) // insertable = false: không cho phép insert trường này chỉ cho phép update, đọc
        private LocalDateTime updatedAt;
        
        @LastModifiedBy // Đánh dấu trường này sẽ tự động set giá trị cho nó khi update dữ liệu
        @Column(name = "updated_by", insertable = false) // insertable = false: không cho phép insert trường này chỉ cho phép update, đọc
        private String updatedBy;
    }
    ```

- 3. Cấu hình trong file chạy ứng dụng với annotation `@EnableJpaAuditing` để sử dụng `Auditing`.
    > Application.java
    ```java
    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.SpringBootApplication;
    import org.springframework.data.jpa.repository.config.EnableJpaAuditing;

    @SpringBootApplication
    @EnableJpaAuditing(auditorAwareRef = "auditAwareImpl") // Sử dụng JPA Auditing và trỏ đến Bean auditAwareImpl để lấy thông tin người tạo hoặc cập nhật dữ liệu
    public class AccountsApplication {

        public static void main(String[] args) {
            SpringApplication.run(AccountsApplication.class, args);
        }

    }
    ```

Sau khi cấu hình `Auditing`, khi thực thi thao tác CRUD trên Entity, các trường `createdAt`, `createdBy`, `updatedAt`, `updatedBy` sẽ tự động được set giá trị.

## 8. Migrate Database với Flyway
`Flyway` là một công cụ giúp chúng ta quản lý và thực thi các phiên bản của cơ sở dữ liệu. `Flyway` sẽ tự động thực thi các phiên bản của cơ sở dữ liệu khi chúng ta khởi chạy ứng dụng.

Để sử dụng `Flyway`, chúng ta cần thêm dependency `flyway-core` vào file `pom.xml`.

> pom.xml
```xml
<dependency>
    <groupId>org.flywaydb</groupId>
    <artifactId>flyway-core</artifactId>
</dependency>
```

Sau đó, chúng ta cần cấu hình `Flyway` trong file `application.properties`.

> application.properties
```yaml
spring:
  application:
    name: Migrate-Flyway_Spring # Tên ứng dụng
  datasource:
    url: jdbc:mariadb://localhost:3307/migrate_flyway # URL của cơ sở dữ liệu
    username: didannguyen # Tên đăng nhập
    password: 17052002 # Mật khẩu
    driver-class-name: org.mariadb.jdbc.Driver # Driver của cơ sở dữ liệu
  flyway:
    baseline-on-migrate: true # Tạo phiên bản cơ sở dữ liệu nếu chưa tồn tại
    enabled: true # Kích hoạt Flyway
    locations: classpath:db/migration # Đường dẫn chứa các file migrations

```

Sau đó, chúng ta tạo các file migration trong thư mục `resources/db/migration`.

Ví dụ:
> V1__Create_table_person.sql
```sql
CREATE TABLE person (
    person_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL
);
```

> V2__Create_table_person_detail.sql
```sql
CREATE TABLE person_detail (
    id INT PRIMARY KEY AUTO_INCREMENT,
    address VARCHAR(255) NOT NULL,
    person_id INT,
    FOREIGN KEY (person_id) REFERENCES person(person_id)
);
```

Khi chúng ta khởi chạy ứng dụng, `Flyway` sẽ tự động thực thi các file migration trong thư mục `resources/db/migration`.

*** Lưu ý: Khi thực thi các file migration, `Flyway` sẽ tự động thực thi các file migration theo thứ tự tăng dần của phiên bản. Ví dụ: `V1__Create_table_person.sql`, `V2__Create_table_person_detail.sql`, `V3__Create_table_person_address.sql`, ... Quy tắc đặt tên file migration: `V{version}__{description}.sql`. ***

### Ví dụ thực tế cần sử dụng Flyway
1. Khi chúng ta cần thêm một trường dữ liệu mới vào bảng đã tồn tại. Lúc này, chúng ta cần thêm một file migration để thêm trường dữ liệu mới vào bảng đã tồn tại.
2. Khi chúng ta cần thêm một bảng mới vào cơ sở dữ liệu. Lúc này, chúng ta cần thêm một file migration để tạo bảng mới vào cơ sở dữ liệu.
3. Khi cần `INSERT`, `UPDATE`, `DELETE` dữ liệu trước khi khởi chạy ứng dụng. Lúc này, chúng ta cần thêm một file migration để thực thi các thao tác `INSERT`, `UPDATE`, `DELETE` dữ liệu trước khi khởi chạy ứng dụng.
