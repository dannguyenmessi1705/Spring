# Logging Sl4fj
## 1. Giới thiệu
Trong bài viết này, chúng ta sẽ tìm hiểu về thư viện `slf4j` (Simple Logging Facade for Java) để ghi log trong ứng dụng Java.

`slf4j` là một facade logging API cho Java. Nó cung cấp một API đơn giản để ghi log trong ứng dụng Java. `slf4j` không phải là một framework logging mà nó chỉ là một facade logging API. Nó cung cấp một API chung cho các framework logging khác như `log4j`, `logback`, `java.util.logging`,...

## 2. Cấu hình mức độ log
Chúng ta có thể cấu hình `log level` cho ứng dụng thông qua file `application.properties` hoặc `application.yml`.

Có 5 mức độ log:
- `TRACE`: Mức độ log thấp nhất, dùng để ghi log chi tiết nhất.
- `DEBUG`: Mức độ log thấp, dùng để ghi log chi tiết.
- `INFO`: Mức độ log thông tin, dùng để ghi log thông tin.
- `WARN`: Mức độ log cảnh báo, dùng để ghi log cảnh báo.
- `ERROR`: Mức độ log lỗi, dùng để ghi log lỗi.

> Nếu chúng ta cấu hình mức độ log là `INFO`, thì tất cả các log ở mức `INFO`, `WARN`, `ERROR` sẽ được ghi log, còn `DEBUG` và `TRACE` sẽ không được ghi log.

>VD: `application.properties`
```properties
# Logging cho toàn bộ framework Spring
logging.level.org.springframework=debug
# Cấu hình mức độ log cho ứng dụng (thay org.example.demo bằng package của ứng dụng)
logging.level.com.example.demo=info
```

Mặc định nó sẽ lắng nghe logger ở lớp info, để cho nó về lớp trace to nhất thì thay đổi `logging.level.root={loại log}` ở `application.properties`

Để log ra ` file ` thì thêm `logging.file={đường dẫn file}` ở `application.properties (classpath:logs/app.log)`

Tạo file cấu hình `logback-spring.xml` để `cấu hình logger thay vì cấu hình trong application.properties` (src/main/resources/logback-spring.xml)

Các định dạng của logger:
- `%d{yyyy-MM-dd HH:mm:ss.SSS}` : thời gian log
- `${PID}` : process id
- `$-5level` : In ra tất cả các log có level từ trace đến error
- `%5p` : loại log (trace, debug, info, warn, error)
- `%logger`{36} : tên class log (36 ký tự) 
- `%t` : thread
- `%c` : class
- `%M` : method
- `%L` : line
- `%msg` : message chính
- `%n` : xuống dòng
- `%ex` : log ra exception
- `%X` : log ra các thông tin trong MDC (Mapped Diagnostic Context) dùng để lưu trữ thông tin trong quá trình xử lý request
    
>VD: 
```bash
%d{yyyy-MM-dd HH:mm:ss.SSS} ${PID:-} $-5level %logger{36} %t %c %M %L %msg %n %ex
```

## 3. Sử dụng `slf4j` trong ứng dụng Java
Sau khi cấu hình mức độ log, chúng ta sử dụng `slf4j` trong ứng dụng Java như sau:

> `Controller.java`
```java
package com.example.demo;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController {
    private static final Logger logger = LoggerFactory.getLogger(getClass()); // Khai báo Logger, lấy class hiện tại để ghi log
    @GetMapping("/hello")
    public String hello() {
    logger.info("The log is {}", "hello"); // Ghi log ở mức INFO, log message là "The log is hello"
        return "Hello World!";
    }
}
```

## 4. Tạo Log Filter cho các lần gọi Request
Để log ra các thông tin của request như `URI`, `method`, `status`, `time`,... chúng ta tạo một `Filter` để log ra các thông tin này.

Sử dụng `MDC` (Mapped Diagnostic Context) để lưu trữ thông tin trong quá trình xử lý request. Mỗi request sẽ có một `correlationId` riêng để phân biệt các request với nhau. 

> LogUtils.java
```java
package com.didan.forum.users.utils;

import com.didan.forum.users.dto.Status;
import com.didan.forum.users.dto.response.GeneralResponse;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;
import com.fasterxml.jackson.databind.util.StdDateFormat;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import lombok.experimental.UtilityClass;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.util.ContentCachingResponseWrapper;

@Slf4j
@UtilityClass
public class LogUtils {

  private static final List<String> ignorePatterns;

  private final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); // Định dạng ngày tháng

  public static SimpleDateFormat logDateFormat() {
    return DATE_FORMAT; // Trả về định dạng ngày tháng
  }

  public static String now() { // Lấy thời gian hiện tại
    return DATE_FORMAT.format(new Date());
  }

  static {
    ignorePatterns = new ArrayList<>();
    ignorePatterns.add("(?<=\"password\":\")[^\"]+(?=\")"); // Ignore password in request body
    ignorePatterns.add("(?<=\"accessToken\":\")[^\"]+(?=\")"); // Ignore accessToken in request body
    ignorePatterns.add("(?<=\"refreshToken\":\")[^\"]+(?=\")"); // Ignore refreshToken in request body
  }

  public static String hideSensitiveData(String data) {
    data = data.replaceAll("\\\\n", "").replaceAll("\\\\r", "")
        .replaceAll("\\\\", "")
        .replaceAll("\\s*\"(\\w+)\"\\s*:\\s*\"(.*?)\"\\s*", "\"$1\":\"$2\""); // Xóa các ký tự thừa

    for (String pattern : ignorePatterns) {
      data = data.replaceAll(pattern, "*"); // Thay thế các pattern cần ẩn bằng dấu *
    }
    return data;
  }

  public static boolean isIgnoreUri(String uri) {
    return uri.contains("actuator") || uri.contains("swagger") || uri.contains("api-docs"); // Bỏ qua những request đến các uri này
  }

  public static void sendError(ContentCachingResponseWrapper responseWrapper, Status status) {
    try {
      responseWrapper.setStatus(status.getStatusCode());
      responseWrapper.setContentType("application/json; charset=UTF-8");
      GeneralResponse<Object> responseObject = new GeneralResponse<>();
      Status responseStatus = new Status(status.getApiPath(), status.getStatusCode(), status.getMessage(), status.getTimestamp());
      responseObject.setStatus(responseStatus);
      new ObjectMapper()
          .setAnnotationIntrospector(new JacksonAnnotationIntrospector())
          .registerModule(new JavaTimeModule())
          .setDateFormat(new StdDateFormat())
          .disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)
          .setTimeZone(Calendar.getInstance().getTimeZone())
          .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)
          .writeValue(responseWrapper.getWriter(), responseObject);
      responseWrapper.copyBodyToResponse();
    } catch (IOException e) {
      log.info("Error when send error response: {}", e.getMessage());
    }
  }
}
```

> RequestFilter.java 
```java
package com.didan.forum.users.filter;

import com.didan.forum.users.constant.TrackingConstant;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Locale;
import java.util.UUID;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.MDC;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.core.annotation.Order;
import org.springframework.http.HttpHeaders;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

@Configuration
@Order(0) // Sắp xếp thứ tự filter
@Slf4j
public class RequestFilter extends OncePerRequestFilter {

  @Override
  protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
      FilterChain filterChain) throws ServletException, IOException {
    String appVersion = request.getHeader(TrackingConstant.APP_VERSION.getHeaderKey()); // Lấy thông tin app version từ header
    String osVersion = request.getHeader(TrackingConstant.OS_VERSION.getHeaderKey()); // Lấy thông tin OS version từ header
    String typeOS = request.getHeader(TrackingConstant.TYPE_OS.getHeaderKey()); // Lấy thông tin type OS từ header
    String userAgent = request.getHeader(TrackingConstant.USER_AGENT.getHeaderKey()); // Lấy thông tin user agent từ header

    MDC.put(TrackingConstant.APP_VERSION.getHeaderKey(), appVersion); // Set thông tin app version vào MDC  
    MDC.put(TrackingConstant.TYPE_OS.getHeaderKey(), typeOS); // Set thông tin type OS vào MDC
    MDC.put(TrackingConstant.OS_VERSION.getHeaderKey(), osVersion); // Set thông tin OS version vào MDC
    MDC.put(TrackingConstant.USER_AGENT.getHeaderKey(), userAgent); // Set thông tin user agent vào MDC

    String xOriginalForwardFor = request.getHeader(TrackingConstant.X_ORIGINAL_FORWARD_FOR.getHeaderKey()); // Lấy thông tin IP từ header 
    String ip = request.getHeader(TrackingConstant.X_FORWARD_FOR.getHeaderKey()); // Lấy thông tin IP từ header
    if (StringUtils.hasText(xOriginalForwardFor)) { // Nếu có thông tin IP từ header
      try {
        ip = xOriginalForwardFor.split(",")[0]; // Lấy IP đầu tiên
      } catch (Exception e) {
        log.error("Exception when parse IP", e);
      }
    } else {
      String xRealIp = request.getHeader(TrackingConstant.X_REAL_IP.getHeaderKey()); // Lấy thông tin IP từ header
      ip = StringUtils.hasText(xRealIp) ? xRealIp : request.getRemoteAddr(); // Nếu không có IP thì lấy IP từ request
    }
    MDC.put(TrackingConstant.X_REAL_IP.getHeaderKey(), ip); // Set thông tin IP vào MDC

    if (!StringUtils.hasText(request.getHeader(HttpHeaders.ACCEPT_LANGUAGE))) { // Nếu không có thông tin ngôn ngữ từ header
      LocaleContextHolder.setLocale(Locale.of("en")); // Set ngôn ngữ mặc định là en
    }

    generateCorrelationIdIfNotExists(request.getHeader(TrackingConstant.X_REQUEST_ID.getHeaderKey())); // Tạo correlationId nếu không tồn tại
    response.setHeader(TrackingConstant.X_REQUEST_ID.getHeaderKey(),
        MDC.get(TrackingConstant.X_REQUEST_ID.getHeaderKey())); // Set correlationId vào header

    if (StringUtils.hasText(request.getHeader(TrackingConstant.X_USER_ID.getHeaderKey()))) {
      MDC.put(TrackingConstant.X_USER_ID.getHeaderKey(), request.getHeader(TrackingConstant.X_USER_ID.getHeaderKey()));
    } // Set thông tin user id vào MDC nếu có

    RequestContext.setRequest(request); // Set request vào RequestContext

    filterChain.doFilter(request, response); // Tiếp tục xử lý request

    RequestContext.clear(); // Xóa request khỏi RequestContext sau khi xử lý xong request
    MDC.clear(); // Xóa thông tin trong MDC
  }

  private void generateCorrelationIdIfNotExists(String xRequestId) {
    String requestId = StringUtils.hasText(xRequestId) ? xRequestId : UUID.randomUUID().toString().replace("-", "")
        .toLowerCase(); // Tạo correlationId nếu không tồn tại
    MDC.put(TrackingConstant.X_REQUEST_ID.getHeaderKey(), requestId); // Set correlationId vào MDC
  }
}
```

> RequestHttpFilterExtended.java
```java
package com.didan.forum.users.filter;

import com.didan.forum.users.filter.cachehttp.CachedBodyHttpServletRequest;
import com.didan.forum.users.utils.LogUtils;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.annotation.Order;
import org.springframework.web.filter.OncePerRequestFilter;
import org.springframework.web.util.ContentCachingRequestWrapper;
import org.springframework.web.util.ContentCachingResponseWrapper;

@Configuration
@Slf4j
@Order(1) // Sắp xếp thứ tự filter
@ConditionalOnProperty(value = "app.log.request.extended.enabled", havingValue = "true") // Cấu hình log request, nếu app.log.request.extended.enabled = true thì log request
public class RequestHttpFilterExtended extends OncePerRequestFilter { // Filter để log request

  Map<String, String> replaceCharsError = new HashMap<>(); // Map chứa các ký tự cần thay thế
  @Value("#{'${app.log.request.ignoreHeaders}'.split(',')}") 
  private List<String> ignoredHeaders; // Danh sách các header cần ẩn

  public RequestHttpFilterExtended() {
    replaceCharsError.put("\u0000", "");
  } // Thêm ký tự null vào map replaceCharsError

  @Override
  protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
    StringBuilder str = new StringBuilder();

    try {
      String uri = request.getRequestURI(); // Lấy URI của request
      if (LogUtils.isIgnoreUri(uri)) { // Nếu URI nằm trong danh sách URI cần bỏ qua thì không log
        filterChain.doFilter(request, response); 
        return;
      }

      ContentCachingResponseWrapper responseWrapper = new ContentCachingResponseWrapper(response); // Wrap response để lấy thông tin response sau khi xử lý request 
      CachedBodyHttpServletRequest cachedBodyHttpServletRequest = new CachedBodyHttpServletRequest(new ContentCachingRequestWrapper(request)); // Wrap request để lấy thông tin request sau khi xử lý request

      // request
      Map<String, String> headers = cachedBodyHttpServletRequest.getHeaders(); // Lấy thông tin header của request
      for (String ignoredHeader : ignoredHeaders) { // Ẩn các header cần ẩn
        headers.replace(ignoredHeader, "***");
      }

      str.append("Request = ").append(" \n") 
          .append("Request to: ").append(getFullURL(cachedBodyHttpServletRequest)).append(" \n")
          .append("Method    : ").append(cachedBodyHttpServletRequest.getMethod()).append(" \n")
          .append("Header    : ").append(headers).append(" \n")
          .append("Body      : ").append(replaceChars(getBodyRequest(cachedBodyHttpServletRequest, requestWrapper))).append(" \n")
          .append(" \n"); // Tạo thông tin log request 

        filterChain.doFilter(cachedBodyHttpServletRequest, responseWrapper); 

      // response
      str.append("Response = ").append(" \n")
          .append("Status code: ").append(responseWrapper.getStatus()).append(" \n")
          .append("Headers    : ").append(getHeaders(responseWrapper)).append(" \n")
          .append("Body       : ").append(getBodyResponse(responseWrapper)).append(" \n"); // Tạo thông tin log response
      responseWrapper.copyBodyToResponse(); // Copy thông tin response vào response gốc
    } catch (Exception e) {
      log.error(e.getMessage(), e);
      str.insert(0, "Error parsing response. Parseable data: \n");
    } finally {
      if (!StringUtils.isEmpty(str.toString())) {
        log.info(str.toString()); // Ghi log request và response
      }
    }
  }

  public String getBodyRequest(HttpServletRequest request, ContentCachingRequestWrapper requestWrapper) {
    if (LogUtil.isMultipart(request)) {
      try {
        // Lấy form data từ request gốc
        Map<String, String> formData = new HashMap<>();
        Map<String, String> fileData = new HashMap<>();

        // Lấy form data
        request.getParameterMap().forEach((key, value) -> {
          if (value != null && value.length > 0) {
            formData.put(key, value[0]);
          }
        });

        // Lấy file data từ request
        String contentType = request.getContentType();
        if (contentType != null && contentType.contains("multipart/form-data")) {
          fileData.put("file", "FILE");
        }

        StringBuilder result = new StringBuilder();
        if (!formData.isEmpty()) {
          result.append("Form Data: ").append(formData).append("\n");
        }
        if (!fileData.isEmpty()) {
          result.append("File Data: ").append(fileData);
        }
        return result.toString();
      } catch (Exception e) {
        log.error("Error processing multipart request", e);
        return "Error processing multipart request";
      }
    }

    // Xử lý cho application/json và các request khác
    try {
      if (request instanceof CachedBodyHttpServletRequest) {
        CachedBodyHttpServletRequest cachedRequest = (CachedBodyHttpServletRequest) request;
        byte[] body = cachedRequest.getCachedBody();
        if (body != null) {
          return LogUtil.hideSensitiveData(new String(body, StandardCharsets.UTF_8));
        }
      }

      // Sử dụng requestWrapper đã được tạo trong doFilterInternal
      byte[] body = requestWrapper.getContentAsByteArray();
      if (body != null && body.length > 0) {
        return LogUtil.hideSensitiveData(new String(body, StandardCharsets.UTF_8));
      }
    } catch (Exception e) {
      log.error("Error reading request body", e);
    }

    return "";
  }

  public String getBodyResponse(ContentCachingResponseWrapper responseWrapper) { // Lấy body của response
    String body = new String(responseWrapper.getContentAsByteArray()); // Lấy body của response
    return StringUtils.isEmpty(body) ? null : LogUtils.hideSensitiveData(body); // Nếu body không null thì trả về body, ngược lại trả về null
  }

  public Map<String, String> getHeaders(HttpServletResponse response) { // Lấy thông tin header của response
    Map<String, String> map = new HashMap<>(); // Map chứa thông tin header
    Collection<String> headersName = response.getHeaderNames(); // Lấy tên các header
    for (String s : headersName) { // Duyệt qua các header
      map.put(s, response.getHeader(s)); // Thêm thông tin header vào map
    }

    return map;
  }

  public String getFullURL(HttpServletRequest request) { // Lấy URL của request
    StringBuilder requestURL = new StringBuilder(request.getRequestURL().toString()); // Lấy URL của request
    String queryString = request.getQueryString(); // Lấy query string của request

    if (queryString == null) { 
      return requestURL.toString(); // Nếu query string null thì trả về URL của request
    } else {
      return requestURL.append('?').append(queryString).toString(); // Ngược lại trả về URL của request và query string
    }
  }

  public String replaceChars(String str) { // Thay thế các ký tự trong body của request
    if (StringUtils.isEmpty(str)) { // Nếu body của request null thì trả về null
      return null;
    }
    for (Map.Entry<String, String> entry : replaceCharsError.entrySet()) { // Duyệt qua các ký tự cần thay thế
      str = str.replace(entry.getKey(), entry.getValue());
    }
    return str;
  }

  private boolean isMultipart(HttpServletRequest request) { // Kiểm tra request có phải là multipart không 
    return request.getContentType() != null && request.getContentType().startsWith("multipart/"); // Nếu request có content type là multipart thì trả về true, ngược lại trả về false
  }
}
```

> SimpleSecurityFilter.java (VD Filter xử lý các nghiệp vụ sau khi log request)
```java
package com.didan.forum.users.filter;

import com.didan.forum.users.dto.Status;
import com.didan.forum.users.repository.user.UserRepository;
import com.didan.forum.users.utils.LogUtils;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.time.LocalDateTime;
import java.util.Set;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.jetbrains.annotations.NotNull;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.annotation.Order;
import org.springframework.http.HttpStatus;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;
import org.springframework.web.util.ContentCachingResponseWrapper;

@Configuration
@RequiredArgsConstructor
@Slf4j
@Order(3) // Sắp xếp thứ tự filter
public class SimpleSecurityFilter extends OncePerRequestFilter {
  private final UserRepository userRepository;

  @Value("${private.route}")
  private Set<String> privateRoutes; // Danh sách các route cần xác thực

  @Override
  protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
      @NotNull FilterChain filterChain) throws ServletException, IOException {
    log.info("SimpleSecurityFilter: doFilterInternal"); 
    String pathUrl = request.getRequestURI(); // Lấy URI của request
    if (privateRoutes.stream().anyMatch(pathUrl::contains)) { // Nếu URI nằm trong danh sách URI cần xác thực
      String userId = request.getHeader("X-User-Id"); // Lấy thông tin user id từ header
      if (!StringUtils.hasText(userId)) { // Nếu không có thông tin user id thì trả về lỗi
        LogUtils.sendError(new ContentCachingResponseWrapper(response), // Gửi lỗi về client
            new Status(request.getRequestURI(), HttpStatus.FORBIDDEN.value(), "Unauthorized", LocalDateTime.now()));
        return;
      }
      log.info("Verify userId: {}", userId); // Log thông tin user id
      if (!StringUtils.hasText(userId) || !userRepository.existsById(userId)) { // Nếu không có thông tin user id hoặc không tồn tại user id trong database thì trả về lỗi
        LogUtils.sendError(new ContentCachingResponseWrapper(response), // Gửi lỗi về client
            new Status(request.getRequestURI(), HttpStatus.FORBIDDEN.value(), "Unauthorized", LocalDateTime.now()));
        return;
      }
    }
    filterChain.doFilter(request, response); // Tiếp tục xử lý request nếu không có lỗi
  }
}
```

> RequestWrapper.java (VD Wrapper để lấy thông tin request)
```java
package com.didan.forum.users.filter;

import jakarta.servlet.ReadListener;
import jakarta.servlet.ServletInputStream;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletRequestWrapper;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;

@SuppressWarnings("all") // Bỏ qua các cảnh báo không cần thiết
public class RequestWrapper extends HttpServletRequestWrapper {
  private final String body; // Biến lưu body của request

  public RequestWrapper(HttpServletRequest request) throws IOException {
    super(request); // Gọi constructor của lớp cha

    // Nếu request là multipart, không nên đọc trước body vì Spring cần xử lý phần này
    if (isMultipart(request)) {
      body = null; // Với multipart, không cần cache body
    } else {
      StringBuilder stringBuilder = new StringBuilder(); // Tạo StringBuilder để lưu body của request
      try (InputStream inputStream = request.getInputStream(); // Lấy input stream của request
          BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)) // Đọc input stream
          ) {
        char[] charBuffer = new char[128]; // Tạo buffer để đọc dữ liệu
        int bytesRead; // Biến lưu số byte đọc được
        while ((bytesRead = bufferedReader.read(charBuffer)) != -1) { // Đọc dữ liệu từ input stream vào buffer
          stringBuilder.append(charBuffer, 0, bytesRead); // Thêm dữ liệu vào StringBuilder
        }
      }
      body = stringBuilder.toString(); // Lưu body của request vào biến body
    }
  }

  private boolean isMultipart(HttpServletRequest request) { // Kiểm tra request có phải là multipart không
    return request.getContentType() != null && request.getContentType().startsWith("multipart/"); // Nếu request có content type là multipart thì trả về true, ngược lại trả về false
  }

  @Override
  public ServletInputStream getInputStream() throws IOException { 
    // Nếu là multipart, trả về InputStream gốc để Spring xử lý
    if (body == null) {
      return super.getInputStream();
    }

    final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(body.getBytes()); // Tạo ByteArrayInputStream từ body của request 
    return new ServletInputStream() {
      @Override
      public boolean isFinished() {
        return byteArrayInputStream.available() == 0; // Kiểm tra xem InputStream đã kết thúc chưa 
      }

      @Override
      public boolean isReady() { // Kiểm tra xem InputStream đã sẵn sàng chưa
        return true;
      }

      @Override
      public void setReadListener(ReadListener readListener) { 
        // Không sử dụng trong trường hợp này
      }

      @Override
      public int read() throws IOException { // Đọc dữ liệu từ InputStream
        return byteArrayInputStream.read();
      }
    };
  }

  @Override
  public BufferedReader getReader() throws IOException { 
    if (body == null) { // Nếu body của request null thì trả về BufferedReader gốc
      return super.getReader();
    }
    return new BufferedReader(new InputStreamReader(this.getInputStream())); // Đọc dữ liệu từ InputStream 
  } // Đọc dữ liệu từ InputStream

  public String getBody() {
    return this.body;
  }
}
```

> CachedBodyHttpServletRequest.java (VD Wrapper để lưu thông tin body của request)
```java
package com.didan.forum.users.filter.cachehttp;

import jakarta.servlet.ReadListener;
import jakarta.servlet.ServletInputStream;
import jakarta.servlet.http.HttpServletRequest;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import org.springframework.util.StreamUtils;
import org.springframework.web.util.ContentCachingRequestWrapper;

@SuppressWarnings("all") // Bỏ qua các cảnh báo không cần thiết
public class CachedBodyHttpServletRequest extends ContentCachingRequestWrapper {

  private byte[] cachedBody; // Biến lưu body của request

  public CachedBodyHttpServletRequest(HttpServletRequest request) throws IOException {
    super(request); // Gọi constructor của lớp cha
    // Kiểm tra nếu request là multipart thì không cache body
    if (isMultipart(request)) {
      this.cachedBody = null; // Nếu request là multipart thì không cache body (vì sau khi đọc body, request sẽ không thể đọc lại == null)  
    } else {
      InputStream requestInputStream = request.getInputStream(); // Lấy input stream của request
      this.cachedBody = StreamUtils.copyToByteArray(requestInputStream); // Copy dữ liệu từ input stream vào biến cachedBody
    }
  }

  private boolean isMultipart(HttpServletRequest request) { // Kiểm tra request có phải là multipart không
    return request.getContentType() != null && request.getContentType().startsWith("multipart/");
  }

  public byte[] getCachedBody() { // Lấy body của request
    return this.cachedBody;
  }

  public void setCachedBody(byte[] cachedBody) { // Set body của request
    this.cachedBody = cachedBody;
  }

  public Map<String, String> getHeaders() { // Lấy thông tin header của request
    Map<String, String> map = new HashMap<>(); // Map chứa thông tin header
    Enumeration<String> headersName = this.getHeaderNames(); // Lấy tên các header

    while (headersName.hasMoreElements()) { // Duyệt qua các header
      String name = headersName.nextElement();  // Lấy tên header
      map.put(name, this.getHeader(name)); // Thêm thông tin header vào map
    }

    return map;
  }

  @Override
  public ServletInputStream getInputStream() throws IOException { // Lấy input stream của request
    if (this.cachedBody == null || isMultipart(this)) { // Nếu body của request null thì trả về input stream gốc
      return super.getInputStream();
    }

    return new ServletInputStream() { // Tạo ServletInputStream từ body của request
      private final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(cachedBody);

      @Override
      public boolean isFinished() {
        return byteArrayInputStream.available() == 0; // Kiểm tra xem InputStream đã kết thúc chưa
      }

      @Override
      public boolean isReady() {
        return true;
      }

      @Override
      public void setReadListener(ReadListener readListener) {
        // Not implemented
      }

      @Override
      public int read() throws IOException {
        return byteArrayInputStream.read();
      }
    };
  }
}
```

Như vậy, sau khi cấu hình các `Filter` và `Wrapper` như trên, chúng ta đã có thể log ra các thông tin của request như `URI`, `method`, `status`, `time`,... trong ứng dụng Java.

Ví dụ khi gọi API `GET /users`:
```bash
Request =
Request to: http://localhost:8080/users
Method    : GET
Header    : {accept=[*/*], user-agent=[PostmanRuntime/7.26.8], host=[localhost:8080], connection=[keep-alive], postman-token=[b3b3b3b3-3b3b-3b3b-3b3b-3b3b3b3b3b3b], accept-encoding=[gzip, deflate, br], app-version=[1.0.0], type-os=[ios], os-version=[13.3.1]}
Body      : null

Response =
Status code: 200
Headers    : {Content-Type=[application/json], Transfer-Encoding=[chunked], Date=[Thu, 30 Sep 2021 09:00:00 GMT]}
Body       : [{"id":"1","name":"Alice"},{"id":"2","name":"Bob"}]
```


## 5. Tạo Interceptor để log request và response sử dụng `RestTemplate`
Chúng ta cũng có thể tạo một `Interceptor` để log ra các thông tin của request và response khi sử dụng `RestTemplate` gọi qua các API khác. 

Ví dụ khi gọi API `GET /users` trong ứng dụng Spring Boot lại sử dụng `RestTemplate` để gọi API khác. Lúc này, chúng ta cũng muốn log ra các thông tin của request và response.

> TraceInterceptor.java (Tạo `Interceptor` để set vào `RestTemplate`)
```java

import java.io.IOException;
import java.util.Date;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpRequest;
import org.springframework.http.client.ClientHttpRequestExecution;
import org.springframework.http.client.ClientHttpRequestInterceptor;
import org.springframework.http.client.ClientHttpResponse;
import vn.com.viettel.vds.htcmnh.exchange.util.RestTemplateTracer;

/**
 * @author dannd1
 * @since 3/17/2025
 */
@Slf4j
@Configuration
@RequiredArgsConstructor
public class TraceInterceptor implements ClientHttpRequestInterceptor { // Tạo Interceptor để log request và response

  private final RestTemplateTracer restTemplateTracer; // Bean RestTemplateTracer để log request và response

  @Value("${app.log.common.enabled:#{true}}")
  boolean logEnabled; // Cấu hình log request và response

  @Override
  public ClientHttpResponse intercept(
      HttpRequest request,
      byte[] body,
      ClientHttpRequestExecution execution) throws IOException {
    Date startDate = new Date(); // Lấy thời gian bắt đầu gọi API
    ClientHttpResponse httpResponse = execution.execute(request, body); // Thực hiện gọi API
    if (logEnabled) { // Nếu cấu hình log request và response
      restTemplateTracer.trace(request, body, httpResponse, startDate); // Log request và response sử dụng RestTemplateTracer
    }
    return httpResponse; // Trả về response
  }
}
```

> RestTemplateTracer.java (Tạo `RestTemplateTracer` để log request và response)
```java

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpRequest;
import org.springframework.http.client.ClientHttpResponse;

/**
 * @author dannd1
 * @since 3/17/2025
 */
@Configuration
@Slf4j
public class RestTemplateTracer {
  @Value("#{'${app.log-request-http-v2.ignored-headers}'.split(',')}")
  private List<String> ignoredHeaders; // Danh sách các header cần ẩn

  public void trace(HttpRequest request, byte[] body, ClientHttpResponse response, Date startDate) { // Log request và response
    StringBuilder sb = new StringBuilder();  // StringBuilder để lưu thông tin log

    try (InputStream inputStreamBody = response.getBody(); // Lấy input stream của response
        InputStreamReader inputStreamReader = new InputStreamReader(inputStreamBody, StandardCharsets.UTF_8); // Đọc input stream
        BufferedReader bufferedReader = new BufferedReader(inputStreamReader) // Đọc dữ liệu từ input stream
    ) {
      HttpHeaders headers = request.getHeaders(); // Lấy thông tin header của request
      for (String ignoredHeader : ignoredHeaders) {  // Ẩn các header cần ẩn
        headers.replace(ignoredHeader, Collections.singletonList("***"));
      }
      long start = startDate.getTime(); // Lấy thời gian bắt đầu gọi API
      sb.append("Request  : [").append(request.getMethodValue()).append("] ").append(request.getURI()).append(" \n")
          .append("Time     : ").append(LogUtil.logDateFormat().format(startDate)).append(" \n")
          .append("Headers  : ").append(headers).append(" \n")
          .append("Body     : ").append(new String(body, StandardCharsets.UTF_8)).append(" \n")
          .append(" \n"); // Tạo thông tin log request

      headers = response.getHeaders(); // Lấy thông tin header của response
      for (String ignoredHeader : ignoredHeaders) { // Ẩn các header cần ẩn
        headers.replace(ignoredHeader, Collections.singletonList("***")); // Thay thế thông tin header cần ẩn bằng ***
      }
      long end = System.currentTimeMillis(); // Lấy thời gian kết thúc gọi API
      sb.append("Response : ").append(response.getStatusCode()).append(" \n")
          .append("Time     : ").append(LogUtil.now()).append(" \n")
          .append("Duration : ").append(end - start).append(" ms\n")
          .append("Headers  : ").append(headers).append(" \n"); // Tạo thông tin log response

      StringBuilder inputSb = new StringBuilder(); // StringBuilder để lưu body của response

      String line = bufferedReader.readLine(); // Đọc dữ liệu từ input stream
      while (line != null) { // Duyệt qua dữ liệu
        inputSb.append(line); // Thêm dữ liệu vào StringBuilder
        inputSb.append("\n"); // Thêm dấu xuống dòng
        line = bufferedReader.readLine(); // Đọc dữ liệu tiếp theo
      }

      sb.append("Body     : ").append(inputSb); // Thêm body của response vào log

    } catch (Exception ex) {
      log.warn(ex.getMessage(), ex);
      sb.insert(0, "Error parsing response. Parseable data: " + request.getURI() + "\n");
    } finally {
      if (!StringUtils.isEmpty(sb.toString())) {
        log.info(sb.toString()); // Ghi log request và response
      }
    }
  }
}
```

> RestTemplateUtil.java (Tạo `RestTemplateUtil` để set `Interceptor` vào `RestTemplate`)
```java
import java.nio.charset.StandardCharsets;
import java.security.GeneralSecurityException;
import java.util.Collections;
import javax.net.ssl.SSLContext;
import lombok.experimental.UtilityClass;
import org.apache.http.config.Registry;
import org.apache.http.config.RegistryBuilder;
import org.apache.http.conn.socket.ConnectionSocketFactory;
import org.apache.http.conn.socket.PlainConnectionSocketFactory;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.ssl.SSLContextBuilder;
import org.apache.http.ssl.SSLContexts;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.http.client.BufferingClientHttpRequestFactory;
import org.springframework.http.converter.StringHttpMessageConverter;
import org.springframework.web.client.RestTemplate;
import vn.com.viettel.vds.htcmnh.exchange.exception.CustomExceptionHandler;
import vn.com.viettel.vds.htcmnh.exchange.service.IRestTemplateService;
import vn.com.viettel.vds.htcmnh.exchange.service.impl.RestTemplateServiceImpl;

@UtilityClass
public class RestTemplateUtil {
  private static IRestTemplateService restTemplateService; // Bean RestTemplateService
  private static final boolean HOST_NAME_VERIFIER = true; // Verify host name

  public static RestTemplate createRestTemplate(TraceInterceptor traceInterceptor, BufferingClientHttpRequestFactory requestFactory) { // Tạo RestTemplate với Interceptor
    RestTemplate restTemplate = new RestTemplate(); // Tạo RestTemplate
    restTemplate.setInterceptors(Collections.singletonList(traceInterceptor)); // Set Interceptor vào RestTemplate
    restTemplate.getMessageConverters().add(0, new StringHttpMessageConverter(StandardCharsets.UTF_8)); // Set message converter cho RestTemplate với UTF-8 encoding
    restTemplate.setErrorHandler(new DefaultResponseErrorHandler() {
            @Override
            public boolean hasError(@NotNull ClientHttpResponse response) throws IOException {
                HttpStatus.Series series = response.getStatusCode().series(); // Lấy series của status code của response
                return HttpStatus.Series.CLIENT_ERROR.equals(series) || HttpStatus.Series.SERVER_ERROR.equals(series); // Trả về true nếu status code là client error hoặc server error, ngược lại trả về false
            }
        }); // Set error handler cho RestTemplate
    restTemplate.setRequestFactory(requestFactory); // Set request factory cho RestTemplate với BufferingClientHttpRequestFactory
    return restTemplate; // Trả về RestTemplate
  }

  public static void setRestTemplateService(RestTemplateServiceImpl restTemplateService) {
    RestTemplateUtil.restTemplateService = restTemplateService;
  } // Set RestTemplateService cho RestTemplateUtil

  public static Registry<ConnectionSocketFactory> getSocketFactoryRegistry() throws GeneralSecurityException {
    SSLContextBuilder builder = SSLContexts.custom(); // Tạo SSL Context Builder
    builder.loadTrustMaterial(null, (chain, authType) -> true); // Load trust material cho SSL Context Builder với trust all
    SSLContext sslContext = builder.build(); // Build SSL Context
    SSLConnectionSocketFactory sslSocketFactory = new SSLConnectionSocketFactory(sslContext, 
            (s, sslSession) -> isHostNameVerified()); // Tạo SSL Connection Socket Factory với SSL Context và Host Name Verifier
    return RegistryBuilder 
            .<ConnectionSocketFactory>create()
            .register("https", sslSocketFactory)
            .register("http", new PlainConnectionSocketFactory())
            .build(); // Tạo Registry cho RestTemplate với SSL Connection Socket Factory (dùng cho HTTPS connection và HTTP connection)
  } // Tạo Registry cho RestTemplate với SSL Connection Socket Factory (dùng cho HTTPS connection và HTTP connection)

  private static boolean isHostNameVerified() {
    return HOST_NAME_VERIFIER;
  }
}
```

> Core
```java
import com.fasterxml.jackson.databind.ObjectMapper;
import java.security.GeneralSecurityException;
import java.util.concurrent.TimeUnit;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.DefaultHttpRequestRetryHandler;
import org.apache.http.impl.client.HttpClientBuilder;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpHeaders;
import org.springframework.http.client.BufferingClientHttpRequestFactory;
import org.springframework.http.client.HttpComponentsClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;
import vn.com.viettel.vds.htcmnh.exchange.constant.CommonConstant;

@Configuration
@Getter
@Slf4j
@RefreshScope
public class CoreServiceClientConfig {

  private String endpoint;

  private String proxyHost;

  private Integer proxyPort;

  private String channel;

  private int mintConnectionTimeOut;

  public CoreServiceClientConfig(@Value("${rest.core-service.endpoint:#{null}}") String endpoint,
                                 @Value("${rest.core-service.proxy-host:#{null}}") String proxyHost,
                                 @Value("${rest.core-service.proxy-port:#{null}}") Integer proxyPort,
                                 @Value("${end-point.channel}") String channel,
                                 @Value("${connection-time-out}") int mintConnectionTimeOut) {
    this.endpoint = endpoint;
    this.proxyHost = proxyHost;
    this.proxyPort = proxyPort;
    this.channel = channel;
    this.mintConnectionTimeOut = mintConnectionTimeOut;
  }

  @Bean("coreServiceRestTemplate") // Có thể đặt tên cho RestTemplate, vì có thể có nhiều RestTemplate trong ứng dụng, mỗi RestTemplate có một cấu hình khác nhau
  public RestTemplate coreServiceRestTemplate(TraceInterceptor traceInterceptor) throws GeneralSecurityException {
    PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager(RestTemplateUtil.getSocketFactoryRegistry()); // Tạo PoolingHttpClientConnectionManager
    connectionManager.setMaxTotal(2048); // Thiết lập cấu hình tối đa cho tất cả các route
    connectionManager.setDefaultMaxPerRoute(1024); // Thiết lập cấu hình tối đa cho mỗi route

    RequestConfig config = RequestConfig.custom()
      .setConnectTimeout(mintConnectionTimeOut) // Thiết lập thời gian kết nối tối đa
      .setConnectionRequestTimeout(mintConnectionTimeOut) // Thiết lập thời gian chờ kết nối tối đa
      .setSocketTimeout(mintConnectionTimeOut).build(); // Thiết lập thời gian socket tối đa


    HttpClientBuilder builder = HttpClients.custom()
      .setConnectionManager(connectionManager) // Set connection manager cho HttpClient
      .evictExpiredConnections() // Xóa các kết nối hết hạn
      .evictIdleConnections(30L, TimeUnit.SECONDS) // Xóa các kết nối không hoạt động
      .setDefaultRequestConfig(config) // Set cấu hình request mặc định
      .setRetryHandler(new DefaultHttpRequestRetryHandler(0, false)) // Set retry handler
      .disableRedirectHandling(); // Disable redirect handling (do không cần thiết)

    setAuthProxy(builder); // Set proxy cho HttpClient nếu có

    CloseableHttpClient closeableHttpClient = builder.build(); // Build HttpClient
    BufferingClientHttpRequestFactory requestFactory = new BufferingClientHttpRequestFactory(new HttpComponentsClientHttpRequestFactory(closeableHttpClient)); // Tạo BufferingClientHttpRequestFactory với HttpComponentsClientHttpRequestFactory
    return RestTemplateUtil.createRestTemplate(traceInterceptor, requestFactory); // Tạo RestTemplate với Interceptor và BufferingClientHttpRequestFactory
  }

  private void setAuthProxy(HttpClientBuilder builder) {
    if (!StringUtils.isEmpty(proxyHost) && !StringUtils.isEmpty(proxyPort)) {
      builder.setProxy(new HttpHost(proxyHost, proxyPort));
      if (!StringUtils.isEmpty(proxyUsername) && !StringUtils.isEmpty(proxyPassword)) {
        CredentialsProvider credentialsProvider = new BasicCredentialsProvider();
        credentialsProvider.setCredentials(
            new AuthScope(proxyHost, proxyPort),
            new UsernamePasswordCredentials(proxyUsername, proxyPassword)
        );
        builder.setDefaultCredentialsProvider(credentialsProvider).disableCookieManagement();
      }
    }
  }
}
```

Như vậy, sau khi cấu hình các `Interceptor` và `RestTemplate` như trên, chúng ta đã có thể log ra các thông tin của request và response khi sử dụng `RestTemplate` gọi qua các API khác.

Ví dụ khi gọi API `GET /users`:
```bash
Request  : [GET] http://localhost:8080/users
Time     : Thu Sep 30 09:00:00 GMT 2021
Headers  : {Accept=[application/json], Content-Type=[application/json], Authorization
Body     : null

Response : 200
Time     : Thu Sep 30 09:00:00 GMT 2021
Duration : 100 ms
Headers  : {Content-Type=[application/json], Transfer-Encoding=[chunked], Date=[Thu, 30 Sep 2021 09:00:00 GMT]}
Body     : [{"id":"1","name":"Alice"},{"id":"2","name":"Bob"}]
```
