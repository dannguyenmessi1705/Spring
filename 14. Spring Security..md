# Spring Security trong Spring Boot
## 1. Giới thiệu về Spring Security
`Spring Security` là một framework mạnh mẽ và mở rộng để xác thực và kiểm tra quyền truy cập trong ứng dụng Spring. `Spring Security` cung cấp một cách tiếp cận bảo mật mạnh mẽ và linh hoạt cho ứng dụng Spring.

`Spring Security` cung cấp các tính năng sau:
- Xác thực (Authentication): Xác thực người dùng.
- Ủy quyền (Authorization): Kiểm tra quyền truy cập của người dùng.
- Bảo vệ chống tấn công CSRF (Cross-Site Request Forgery).
- Bảo vệ chống tấn công XSS (Cross-Site Scripting).
- Bảo vệ chống tấn công Clickjacking.
- Bảo vệ chống tấn công Session Fixation.
- Bảo vệ chống tấn công Session Management.
- Bảo vệ chống tấn công Brute Force.
- ...

`Spring Security` hỗ trợ nhiều cơ chế xác thực khác nhau như:
- Xác thực dựa trên `LDAP` - Lightweight Directory Access Protocol (Giao thức truy cập thư mục nhẹ).
- Xác thực dựa trên `Database` - Cơ sở dữ liệu.
- Xác thực dựa trên `JWT` - JSON Web Token.
- Xác thực dựa trên `OAuth2` - Open Authorization.
- Xác thực dựa trên `In-Memory` - Lưu trữ trong bộ nhớ tạm.

## 2. Cài đặt Spring Security
### 2.1. Thêm `dependency` vào `pom.xml`
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```
Sau khi thêm `dependency` vào `pom.xml`, chúng ta cần khởi động lại ứng dụng Spring Boot.

Khi khởi động ứng dụng, `Spring Security` sẽ tự động tạo ra một `password` ngẫu nhiên cho chúng ta. Để lấy `password` này, chúng ta cần xem trong `Console` khi khởi động ứng dụng.

```plaintext
Using generated security password: 7b3b3b7b-0b7b-4b7b-8b7b-7b7b7b7b7b7b
```

Khi truy cập vào bất kỳ 1 route nào của ứng dụng, `Spring Security` tự chuyển hướng về `/login` sẽ yêu cầu nhập `username` và `password` để xác thực. Với `username` là `user` và `password` là `password` mặc định ở trong `Console` và được làm mới mỗi lần khởi động ứng dụng.

Đê `logout` khỏi ứng dụng, chúng ta chỉ cần truy cập vào `/logout`.

### 2.2. Thiết lập `application.properties` (RESTAPI: `Basic Authentication`)
Sau khi cho `Spring Security` chạy lần đầu, chúng ta cần thiết lập `username` và `password` mặc định cho ứng dụng. Tránh việc mỗi lần khởi động ứng dụng, `Spring Security` tạo ra `password` mới.
```properties
spring.security.user.name=didannguyen
spring.security.user.password=12345
```

### 2.3. Cấu hình tùy chỉnh `Spring Security`.
Để cấu hình `Spring Security`, chúng ta cần tạo một class với `@Configuration` để cho `Spring Security` biết đây là class cấu hình

>Lưu ý: Annotation `@EnableWebSecurity` không cần thiết nếu chúng ta sử dụng `Spring Boot` vì `Spring Boot` đã tự động cấu hình `Spring Security` cho chúng ta.

## 3. Cấu hình `Spring Security` tạo `User` trong bộ nhớ (In-Memory) (RESTAPI: `Basic Authentication`)
`In-Memory` là cách xác thực người dùng bằng cách lưu trữ thông tin người dùng trong bộ nhớ tạm. Đây là cách xác thực đơn giản và phù hợp cho việc phát triển ứng dụng.

```java
package com.didan.spring_boot_web.securtity;

import java.util.function.Function;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;

@Configuration // Đánh dấu đây là class cấu hình Spring (Bên trong có thể chứa các Bean)
public class SpringSecurityConfiguration {

	@Bean // Bean này sẽ được Spring quản lý
	public PasswordEncoder passwordEncoder() { // Bean này trả về một đối tượng PasswordEncoder, dùng để mã hóa mật khẩu
		return new BCryptPasswordEncoder(); // Trả về một đối tượng BCryptPasswordEncoder
	}

	// Trong Spring Security, có các cách xác thực người dùng như: InMemory,
	// Database, LDAP, ...

	@Bean // Bean này sẽ được Spring quản lý
	public InMemoryUserDetailsManager createUserDetailsManager() { // Bean này trả về một đối tượng
																	// InMemoryUserDetailsManager, dùng để tạo ra một
																	// user trong bộ nhớ
		Function<String, String> passwordEncoderFunction = input -> passwordEncoder().encode(input); // Tạo ra một
																										// đối tượng
																										// Function
																										// để mã hóa
																										// mật khẩu

		UserDetails userDetails = User.builder().passwordEncoder(passwordEncoderFunction).username("didannguyen")
				.password("12345").roles("ADMIN", "USER").build(); // Tạo ra một đối tượng UserDetails với việc được mã
																	// hóa mật khẩu, username là didannguyen, 
																	// password là 12345, và có 2 role là
																	// ADMIN và USER
        // Ngoài ra có thể thêm nhiều user khác, và trả về một đối tượng InMemoryUserDetailsManager với danh sách user đó
        // InMemoryUserDetailsManager(userDetails1, userDetails2, ...)
		return new InMemoryUserDetailsManager(userDetails); // Trả về một đối tượng InMemoryUserDetailsManager với
															// user vừa tạo
	}
}
```
> Mặc định khi cài `Spring Security`, chế độ `In-Memory` được sử dụng. Để tắt chế độ `In-Memory`, chúng ta chỉ cần tạo một `Bean` `UserDetailsService` và trả về `new InMemoryUserDetailsManager()` không có tham số.

## 4. Cấu hình `Spring Security` tạo `User` trong H2-Database, thay vì In-Memory (RESTAPI: `Basic Authentication`)
Để thay vì lưu trữ `User` trong bộ nhớ tạm, chúng ta có thể lưu trữ `User` trong `Database`. Trong ví dụ này, chúng ta sẽ sử dụng `H2-Database` để lưu trữ `User`. Sử dụng `JDBC` để kết nối với `H2-Database`.

### 4.1. Thêm `dependency` vào `pom.xml`
```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-data-jdbc</artifactId>
</dependency>
<dependency>
	<groupId>com.h2database</groupId>
	<artifactId>h2</artifactId>
	<scope>runtime</scope>
</dependency>
```

### 4.2. Cấu hình `Security` để sử dụng `H2-Database`
Trước tiên cần phải config `security` để cho `H2-Database` hoạt động. `H2-Database` sử dụng `frame` để hiển thị giao diện, nên cần phải tắt chức năng `frameOptions` của `Spring Security`. Phần `### 5.1` sẽ giải thích chi tiết.

Tạo 2 `Bean` `DataSource` và `JdbcUserDetailsManager` (thay vì `InMemoryUserDetailsManager)`) để kết nối với `H2-Database` và lưu trữ `User` trong `H2-Database`.

```java
package com.didan.learn_spring_security;

import static org.springframework.security.config.Customizer.withDefaults;

import javax.sql.DataSource;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl; // Import để sử dụng script tạo bảng user
import org.springframework.security.provisioning.JdbcUserDetailsManager;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {
	@Bean
	public SecurityFilterChain filterChain(HttpSecurity http) throws Exception{
		// Authorize Requests
		http.authorizeHttpRequests(req -> req.anyRequest().authenticated())
		.httpBasic(withDefaults())
		.cors(cors -> cors.disable())
		.csrf(csrf -> csrf.disable())
		.headers(headers -> headers.frameOptions(frameOptions -> frameOptions.sameOrigin()));
		
		return http.build();
	}

	@Bean
	public DataSource dataSource() { // Bean này trả về một đối tượng DataSource, dùng để kết nối với H2-Database
		return new EmbeddedDatabaseBuilder() // Trả về một đối tượng EmbeddedDatabaseBuilder
				.setType(EmbeddedDatabaseType.H2) // Chọn loại Database là H2
				.addScript(JdbcDaoImpl.DEFAULT_USER_SCHEMA_DDL_LOCATION) // Thêm script tạo bảng user vào Database (H2)
				.build(); // Tạo ra một đối tượng DataSource
	}
	
	@Bean
	public JdbcUserDetailsManager inMemoryUserDetailsManager(DataSource dataSource) { // Bean này trả về một đối tượng JdbcUserDetailsManager, dùng để tạo ra một user trong H2-Database
		UserDetails user1 = User.withUsername("didan")
				.password("{noop}didan") // password: didan, {noop} is a password encoder that does nothing
				.roles("ADMIN", "USER")
				.build();
		UserDetails user2 = User.withUsername("user")
				.password("{noop}user") // password: user, {noop} is a password encoder that does nothing
				.roles("USER").build();
		UserDetails user3 = User.withUsername("admin")
				.password("{noop}admin") // password: admin, {noop} is a password encoder that does nothing
				.roles("ADMIN").build();
		
		JdbcUserDetailsManager jdbcUserDetailsManager = new JdbcUserDetailsManager(dataSource); // Tạo ra một đối tượng JdbcUserDetailsManager với DataSource
		jdbcUserDetailsManager.createUser(user1); // Tạo ra một user trong H2-Database
		jdbcUserDetailsManager.createUser(user2); // Tạo ra một user trong H2-Database
		jdbcUserDetailsManager.createUser(user3); // Tạo ra một user trong H2-Database
		return jdbcUserDetailsManager; // Trả về một đối tượng JdbcUserDetailsManager
	}
}
```

## 5. Cấu hình CORS (Cross-Origin Resource Sharing) trong Spring Security
`CORS` là một cơ chế cho phép tài nguyên web từ một trang web hoặc miền khác có thể truy cập vào tài nguyên của trang web hiện tại. `CORS` giúp tránh việc chặn các request từ các trang web khác.

Bình thường với `cors` của `SecurityFilterChain` chỉ cho phép `Same-Origin` (cùng nguồn gốc) truy cập vào tài nguyên của trang web hiện tại. 

Để cho phép các trang web khác truy cập vào tài nguyên của trang web hiện tại, chúng ta cần cấu hình `CORS` trong `Spring Security`. Có 2 cách:
- Cấu hình `CORS` chung cho tất cả từ `WebMvcConfigurer`.

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class SpringSecurityConfiguration{
	... 

	@Bean
	public WebMvcConfigurer corsConfigurer() {
		return new WebMvcConfigurer() {
			@Override
			public void addCorsMappings(CorsRegistry registry) {
				registry.addMapping("/**") // Cho phép tất cả các route
						.allowedMethods("*") // Cho phép tất cả các phương thức
						.allowedOrigins("*"); // Cho phép tất cả trang khác gọi được về API của mình
						.allowedHeaders("*"); // Cho phép tất cả các header
						.allowedCredentials(true); // Cho phép gửi cookie
						.maxAge(3600); // Thời gian cache 
			}
		};
	}
}
```

- Cấu hiện `CORS` cho từng `route` nội bộ trong các `Controller`.
```java
import org.springframework.web.bind.annotation.CrossOrigin;
...
@RestController
... 
@CrossOrigin(origins = "*", allowedHeaders = "*", methods = "*") // Cấu hình CORS cho từng route với tất cả các trang, header, phương thức
public class HomeController {
	...
}
```

## 6. Cấu hình `SecurityFilterChain` trong `Spring Security`
`SecurityFilterChain` là một chuỗi các `Filter` mà `Spring Security` sử dụng để xác thực và kiểm tra quyền truy cập của người dùng.

Tại sao cần cấu hình `SecurityFilterChain`?
- `SecurityFilterChain` giúp chúng ta cấu hình các `Filter` mà `Spring Security` sử dụng.
- Khi đi vào một `route` nào đó, `Spring Security` sẽ sử dụng `SecurityFilterChain` để kiểm tra xem người dùng có quyền truy cập không theo các bước sau:
	1. Kiểm tra xem người dùng đã xác thực chưa. 
		```java
		        http.authorizeRequests(authorizeRequests ->
            		authorizeRequests
					.requestMatchers(HttpMethod.GET, "/").permitAll() // Cho phép tất cả các request GET vào route "/" không cần xác thực
					.anyRequest().authenticated() // Tất cả các request khác đều cần phải xác thực mới được truy cập
        		); // Cấu hình cho tất cả các request đều cần phải xác thực mới được truy cập
		```
	2. Nếu chưa xác thực, mặc định sẽ hiển thị form login để xác thực (Web application).
		```java
				import static org.springframework.security.config.Customizer.withDefaults; // Import thêm Customizer.withDefaults để sử dụng withDefaults() lúc cấu hình HttpSecurity
				...
		        http.formLogin(withDefaults()); // Cấu hình cho form login mặc định của Spring Security (username và password), dùng để xác thực người dùng (login)
				http.httpBasic(withDefaults()); // Cấu hình cho Basic Authentication mặc định của Spring Security, dùng để xác thực người dùng (RESTAPI)
		```
	3. Kiểm tra các chính sách bảo mật khác (như CSRF, XSS, Clickjacking, CORS...).
		```java
				http.csrf(csrf -> csrf.disable()); // Tắt chức năng CSRF (Cross-Site Request Forgery) để H2-Database hoạt động
				http.headers(headers -> headers.frameOptions(frame -> frame.disable())); // Tắt chức năng frameOptions
				http.headers(headers -> headers.xssProtection(xss -> xss.disable())); // Tắt chức năng xssProtection
				http.headers(headers -> headers.contentSecurityPolicy(csp -> csp.policyDirectives("default-src 'self'"))); // Cấu hình Content-Security-Policy
				http.cors(cors -> cors.disable()); // Tắt chức năng CORS (Cross-Origin Resource Sharing)
				...
		```
> Ví dụ không cấu hình `SecurityFilterChain`, `Spring Security` sẽ mặc định sử dụng `CSRF` cho các `route` vì thế chúng ta không thể gửi `POST`, `PUT` request từ `Postman` được. Vì vậy cần phải cấu hình `SecurityFilterChain` cho `Spring Security`.

> Cần phải để `SessionCreationPolicy.STATELESS` nếu sử dụng `RESTAPI` để bảo mật tốt hơn.
```java
...
http.sessionManagement(sessionManagement -> sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS)); // Tắt sử dụng Session trong RESTAPI
...
```

Để cấu hình `SecurityFilterChain`, chúng ta cần tạo một class với `@Configuration` và trả về một đối tượng `SecurityFilterChain`.

### 6.1. Cấu hình để `H2-DATABASE` hoạt động với Spring Security
Để `H2-Database` hoạt động với `Spring Security`, chúng ta cần tắt chức năng `CSRF` và `X-Frame-Options` của `Spring Security`.

```java
package com.didan.spring_boot_web.securtity;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import static org.springframework.security.config.Customizer.withDefaults; // Import thêm Customizer.withDefaults để sử dụng withDefaults() lúc cấu hình HttpSecurity

@Configuration
public class SecurityConfiguration {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http.authorizeRequests(authorizeRequests ->
            authorizeRequests.anyRequest().authenticated() // Tất cả các request khác đều cần phải xác thực mới được truy cập
        ); // Cấu hình cho tất cả các request đều cần phải xác thực mới được truy cập

        http.formLogin(withDefaults()); // Cấu hình cho form login mặc định của Spring Security (username và password), dùng để xác thực người dùng (login)

        http.csrf(csrf -> csrf.disable()); // Tắt chức năng CSRF (Cross-Site Request Forgery) để H2-Database hoạt động

        http.headers(headers -> headers.frameOptions(frame -> frame.disable())); // Tắt chức năng frameOptions, do H2-Database sử dụng frame để hiển thị giao diện (nên phải tắt X-Frame-Options)

		// Hoặc muốn bảo mật tốt hơn
		// http.headers(headers -> headers.frameOptions(frame -> frame.sameOrigin())); // Cấu hình cho frameOptions là sameOrigin, chỉ cho phép frame từ cùng một nguồn gốc được hiển thị

        return http.build(); // Trả về một đối tượng SecurityFilterChain
    }
}
```
## 7. Lấy thông tin người dùng hiện tại
Để lấy thông tin người dùng hiện tại, chúng ta sử dụng `SecurityContextHolder` và `Authentication`.

```java
package com.didan.spring_boot_web.controller;

import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HomeController {

    @GetMapping("/")
    public String home() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); // Lấy thông tin của authenticaton từ SecurityContextHolder 
        return "Hello " + authentication.getName(); // Trả về thông tin người dùng hiện tại (username)
    }
}
```
## 8. CSRF (Cross-Site Request Forgery) trong Spring Security
`CSRF` là một kỹ thuật tấn công mà kẻ tấn công tạo ra các request giả mạo từ một trang web khác để thực hiện các hành động không mong muốn trên trang web hiện tại.

Để ngăn chặn `CSRF`, thông thường chúng ta sử dụng `CSRF Token` để xác thực request từ trang web hiện tại. Khi có các yêu cầu từ trang web khác, `Spring Security` sẽ kiểm tra `CSRF Token` trong `Header` của request để xác thực.

Để `CSRFToken` tự động được thêm vào `Form` của `Spring Security`:
- `Spring MVC`: `Web` phải có chế độ `Security` được bật và `Spring MVC` phải có thẻ `form:fomr` hoặc sử dụng `Thymeleaf` để tạo `Form`.
- `RESTAPI`: 
	+ Nên sử dụng `JWT` (JSON Web Token) thay vì `CSRF Token`. Vì `CSRF Token` không phù hợp với `RESTAPI` và `JWT` là một cách tốt hơn.
	+ Hoặc có thể sử dung `Cookie` với `SameSite` là `Strict` hoặc `Lax` để ngăn chặn `CSRF`.
	VD: 
	> `application.properties`
	```
	server.servlet.session.cookie.same-site=strict
	```
 