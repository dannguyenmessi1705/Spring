# Dùng Kubernetes thay thế EurekaServer
## 1. Giới thiệu
`EurekaServer` là một service registry và discovery server của Netflix. Nó giúp các service khác đăng ký và tìm kiếm các service khác thông qua REST API hoặc giao thức `Eureka`. Tuy nhiên, `Eureka` không còn được Netflix phát triển và hỗ trợ nữa, hơn nữa cần phải cài đặt và duy trì một server riêng biệt. Vì vậy, trong bài viết này, chúng ta sẽ thay thế `EurekaServer` bằng `Kubernetes` để làm service registry và discovery server.

### 1.1. Khám phá service và thực hiện cân bằng tải ở phía client (EurekaServer)
Trong việc khám phá các service ở phía `client-side`, các ứng dụng chịu trách nhiệm phải tự đăng ký cho chính nó với `service registry` và sau đó tìm kiếm các service khác thông qua `service registry`. 

Khi một ứng dụng cần giao tiếp với một `backing service` hay các service khác, nó truy vấn đến `server registry` cho thông tin về địa chỉ `IP Adr4ess` được liên kết. Nếu nhiều `instances` của service đó tồn tại, `service registry` sẽ trả về một danh sách các `IP Address` của các `instances` đó. Ứng dụng sẽ chọn một `instance` từ danh sách đó để tạo ra chiến lược cân bằng tải.

### 1.2. Khám phá service và thực hiện cân bằng tải ở phía server (Kubernetes)
Trong việc khám phá các service ở phía `server-side`, `K8s discovery server` sẽ chịu trách nhiệm trong việc quan sát, theo dõi các ứng dụng và giữ thông tin của chúng.

Khi có 1 `microservices` cần giao tiếp với `backing service` hay các service khác, nó đơn giản là gọi tới URL đã được `expose` ra bởi `K8s`. `K8s` sẽ quản lý, thực hiện việc cân bằng tải các request ở tầng `server`. Vì vậy `clients` không cần phải tự xấy dựng chiến lược cân bằng tải.

## 2. Triển khai discovery server bằng Kubernetes
Tham khảo tại link sau: [Spring Cloud Kubernetes](https://docs.spring.io/spring-cloud-kubernetes/reference/)

### 2.1. Tạo file `yaml` để triển khai `K8s discovery server`
Tham khảo tại link sau: [Spring Cloud Kubernetes Discovery Server](https://docs.spring.io/spring-cloud-kubernetes/reference/spring-cloud-kubernetes-discoveryserver.html)

Nội dung của file `yaml`:
> kubernetes-discoveryserver.yaml
```yaml
---
apiVersion: v1
kind: List # Khai báo kiểu resource cần triển khai
items: # Khai báo các resource cần triển khai
  - apiVersion: v1  
    kind: Service # Khai báo kiểu resource là Service
    metadata: 
      labels:
        app: spring-cloud-kubernetes-discoveryserver # Nhãn của resource
      name: spring-cloud-kubernetes-discoveryserver # Tên của resource
    spec: # Khai báo thông tin cấu hình của resource
      ports:
        - name: http
          port: 80
          targetPort: 8761 # Port của container 
      selector: # Chọn các pod có nhãn app=spring-cloud-kubernetes-discoveryserver
        app: spring-cloud-kubernetes-discoveryserver 
      type: ClusterIP # Loại Service là ClusterIP, chỉ có thể truy cập từ trong cluster
  - apiVersion: v1 
    kind: ServiceAccount # Khai báo kiểu resource là ServiceAccount
    metadata: 
      labels:
        app: spring-cloud-kubernetes-discoveryserver # Nhãn của resource
      name: spring-cloud-kubernetes-discoveryserver 
  - apiVersion: rbac.authorization.k8s.io/v1 
    kind: RoleBinding # Khai báo kiểu resource là RoleBinding
    metadata:
      labels:
        app: spring-cloud-kubernetes-discoveryserver # Nhãn của resource
      name: spring-cloud-kubernetes-discoveryserver:view
    roleRef: # Phân quyền cho ServiceAccount
      kind: Role # Kiểu phân quyền
      apiGroup: rbac.authorization.k8s.io # Nhóm API
      name: namespace-reader # Tên của Role
    subjects: # Danh sách các ServiceAccount được phân quyền
      - kind: ServiceAccount  # Kiểu ServiceAccount
        name: spring-cloud-kubernetes-discoveryserver # Tên của ServiceAccount được phân quyền
  - apiVersion: rbac.authorization.k8s.io/v1 # Phiên bản API
    kind: Role # Kiểu resource
    metadata: # Thông tin metadata
      namespace: default # Namespace mà Role này thuộc về
      name: namespace-reader # Tên của Role
    rules: # Quy tắc phân quyền
      - apiGroups: ["", "extensions", "apps"] # Nhóm API
        resources: ["pods", "services", "endpoints"] # Resource được phân quyền
        verbs: ["get", "list", "watch"] # Các hành động được phân quyền 
  - apiVersion: apps/v1 # Phiên bản API
    kind: Deployment # Kiểu resource
    metadata:
      name: spring-cloud-kubernetes-discoveryserver-deployment # Tên của resource
    spec: # Thông tin cấu hình của resource
      selector:
        matchLabels: # Chọn các pod có nhãn app=spring-cloud-kubernetes-discoveryserver
          app: spring-cloud-kubernetes-discoveryserver 
      template: # Template của Pod
        metadata:
          labels:
            app: spring-cloud-kubernetes-discoveryserver  
        spec: # Thông tin cấu hình của Pod
          serviceAccountName: spring-cloud-kubernetes-discoveryserver # Tên của ServiceAccount
          containers: 
          - name: spring-cloud-kubernetes-discoveryserver # Tên của container
            image: springcloud/spring-cloud-kubernetes-discoveryserver:3.1.0 # Image của container, pull từ Docker Hub
            imagePullPolicy: IfNotPresent # Chính sách pull image nếu chưa có trên node
            readinessProbe: # Khai báo endpoint kiểm tra readiness của container, nếu container check fail thì sẽ restart container cho đến khi check pass
              httpGet: # Kiểu kiểm tra HTTP GET
                port: 8761 # Port của container
                path: /actuator/health/readiness # Endpoint kiểm tra readiness
              initialDelaySeconds: 100 # Thời gian chờ trước khi kiểm tra readiness
              periodSeconds: 30 # Chu kỳ kiểm tra readiness trong 30s
            livenessProbe: # Khai báo endpoint kiểm tra liveness của container, nếu container check fail thì sẽ restart container cho đến khi check pass
              httpGet: # Kiểu kiểm tra HTTP GET
                port: 8761 # Port của container
                path: /actuator/health/liveness # Endpoint kiểm tra liveness
              initialDelaySeconds: 100 # Thời gian chờ trước khi kiểm tra liveless
              periodSeconds: 30 # Chu kỳ kiểm tra liveness trong 30s
            ports: 
            - containerPort: 8761 # Port của container
```

### 2.2. Triển khai `K8s discovery server` lên `Kubernetes`
Sử dụng lệnh sau để triển khai `K8s discovery server` lên `Kubernetes`:
```bash
kubectl apply -f kubernetes-discoveryserver.yaml
```

> Nên dùng lệnh này để triển khai lên `Kubernetes` chứ không nên dùng `Helm chart` bởi vì `Helm chart` không hỗ trợ `Spring Cloud Kubernetes`. Hơn nữa, `Spring Cloud Kubernetes` không có sự thay đổi nào trong cấu hình, nó luôn cố định với các cấu hình mặc định.


### 2.3. Sử dụng `K8s discovery server` (Loại bỏ cấu hình liên quan đến `EurekaServer` nếu đã sử dụng trước đó)
#### 2.3.1. Thêm `Spring Cloud Kubernetes` vào `pom.xml`
Thêm dependency `spring-cloud-starter-kubernetes-discoveryclient` vào `pom.xml`. Nếu trước đó đã sử dụng `Spring Cloud Eureka` , hãy loại bỏ dependency `spring-cloud-starter-netflix-eureka-client`
> pom.xml
```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-kubernetes-discoveryclient</artifactId>
</dependency>
```

#### 2.3.2. Thêm các cấu hình liên quan đến `K8s discovery server` vào `application.yml`
##### 2.3.2.1. Đối với các `service` riêng lẻ, thêm các cấu hình sau vào `application.yml`.
> application.yml
```yaml
spring:
 cloud:
  kubernetes:
   discovery:
    all-namespaces: true ## Cho phép tìm kiếm các service ở tất cả các namespace
    discovery-server-url: http://spring-cloud-kubernetes-discoveryserver:80/ # URL của K8s discovery server, tên và port của service chính là tên của service, và port container mà đã định nghĩa trong file `kubernetes-discoveryserver.yaml`
```
> LƯU Ý: Từ `EurekaServer` chuyển sang `K8s discovery server` thì xóa các cấu hình liên quan đến `EurekaServer` trong `application.yml`
```yaml
## Cấu hình Eureka client
eureka:
 instance:
  prefer-ip-address: true # Các service sẽ đăng ký với Eureka dùng IP thay vì dùng dns hoặc hostname
 client:
  fetch-registry: true # Service này sẽ fetch thông tin của các service khác từ Eureka server
  register-with-eureka: true # Service này sẽ đăng ký với Eureka server
  service-url:
    defaultZone: http://localhost:8070/eureka/ # URL của Eureka server
```

##### 2.3.2.2. Đối với `gateway`, thêm các cấu hình sau vào `application.yml`.
> application.yml
```yaml
spring:
 cloud:
  kubernetes:
   discovery:
    enabled: true # Cho phép chuyển tiếp các request từ gateway tới các service khác
    all-namespaces: true # Cho phép tìm kiếm các service ở tất cả các namespace
    discovery-server-url: http://spring-cloud-kubernetes-discoveryserver:80/ ## URL của K8s discovery server, tên và port của service chính là tên của service, và port container mà đã định nghĩa trong file `kubernetes-discoveryserver.yaml`
  discovery:
   client:
    health-indicator:
     enabled: false ## Tắt chức năng health indicator ở client (Chỉ dùng với K8s, phải tắt khi dùng K8s, lỗi chưa fix)
```
> LƯU Ý: Từ `EurekaServer` chuyển sang `K8s discovery server` thì xóa các cấu hình liên quan đến `EurekaServer` trong `application.yml`
```yaml
## Cấu hình Eureka client ở Gateway
spring:
  cloud:
    gateway:
      discovery:
        locator:
          enabled: false # Cho phep Gateway Server su dung Eureka de tim kiem, dinh tuyen cac service
          lower-case-service-id: true # Chuyen ten service thanh chu thuong, tranh loi khi gui service

eureka:
  instance:
    prefer-ip-address: true
  client:
    fetch-registry: true
    register-with-eureka: true
    service-url:
      defaultZone: http://localhost:8070/eureka/
```

#### 2.3.3. Thêm (thay đổi) một số mã code bên trong ứng dụng
- Thêm annotation `@EnableDiscoveryClient` vào class chính của ứng dụng
```java
@SpringBootApplication
@EnableDiscoveryClient
...
```
- Thêm thuộc tính `url` vào annotation `@FeignClient` của các interface `FeignClient`. Mục đích là vì `K8s discovery server` không hỗ trợ `Spring Cloud LoadBalancer` nên cần phải chỉ rõ `url` của service cần gọi. **URL chính là `http://<tên của service>:PORT` trong `K8s`, nếu dùng ở local thì sẽ là `http://localhost:PORT`**
```java
@FeignClient(name = "accounts", url = "http://accounts:8080", fallback = ...)
```

- Đối với `gateway`, trong `Bean` cấu hình `RouteLocator`, thêm `uri` vào `RouteLocatorBuilder` để chỉ rõ `uri` của service cần gọi. **URI chính là `http://<tên của service>:PORT` trong `K8s`, nếu dùng ở local thì sẽ là `http://localhost:PORT`**
```java
...
@Bean // Bean này sẽ được Spring Boot quản lý và sử dụng
  RouteLocator createRouteLocator(RouteLocatorBuilder routeLocatorBuilder) { // RouteLocatorBuilder giúp tạo ra các route
    return routeLocatorBuilder.routes() // Tạo ra các route
        .route(p -> p.path("/didan/accounts/**") // Đường dẫn của route
            .filters(f -> f.rewritePath("/didan/accounts/(?<remaining>.*)", "/${remaining}")  // Rewrite đường dẫn
                .addRequestHeader("X-TIME", LocalTime.now().toString())  // Thêm header vào request
                .circuitBreaker(config -> config.setName("accountsCircuitBreaker") // Sử dụng Circuit Breaker, tên là accountsCircuitBreaker
                    .setFallbackUri("forward:/contactSupport"))) // Nếu có lỗi thì chuyển hướng đến đường dẫn /contactSupport, đã định nghĩa trong Controller
            .uri("http://accounts:8080")) // Đường dẫn của microservices cần gọi
        .build(); // Xây dựng route
  }
...
```
> Lưu ý, trong `EuropeServer`, `uri` sẽ là `lb://<tên của service>` nhưng trong `K8s discovery server`, `uri` sẽ là `http://<tên của service>:PORT` do `K8s discovery server` không hỗ trợ và sử dụng `Spring Cloud LoadBalancer` ở phía client do `K8s` đã thực hiện cân bằng tải ở phía server.

#### 2.3.4. Thêm (thay đổi) cấu hình trong `Helm chart`
Chúng ta thêm các cấu hình liên quan đến `K8s discovery server` vào `values.yaml` của `Helm chart` để triển khai lên `Kubernetes` như thêm biến môi trường là `SPRING_CLOUD_KUBERNETES_DISCOVERY_DISCOVERY-SERVER-URL` với giá trị là `http://spring-cloud-kubernetes-discoveryserver:80/` để chỉ rõ URL của `K8s discovery server`.

Ngoài ra, nếu trước đó đã sử dụng `EurekaServer` thì cần xóa các cấu hình, phụ thuộc liên quan đến `EurekaServer`.

## 3. Cơ chế hoạt động của `Load Balancer` trong `K8s`
`K8s` sử dụng `kube-proxy` để cân bằng tải các request đến các `Pod` của `Service`. `kube-proxy` sẽ tạo ra một `Virtual IP` (VIP) cho `Service` và cân bằng tải các request đến các `Pod` của `Service` thông qua `Round Robin` hoặc `Session Affinity`.

### 3.1. Round Robin
`Round Robin` là một chiến lược cân bằng tải mặc định của `K8s`. `Round Robin` sẽ chuyển tiếp các request đến các `Pod` theo thứ tự từ `Pod` đầu tiên đến `Pod` cuối cùng và sau đó quay lại `Pod` đầu tiên.

### 3.2. Session Affinity
`Session Affinity` là một chiến lược cân bằng tải khác của `K8s`. `Session Affinity` sẽ chuyển tiếp các request đến `Pod` mà đã xử lý request trước đó. `Session Affinity` có thể là `ClientIP` hoặc `None`.

#### 3.2.1. ClientIP
`ClientIP` sẽ chuyển tiếp các request từ cùng một `ClientIP` đến cùng một `Pod` mà đã xử lý request trước đó.

#### 3.2.2. None
`None` sẽ chuyển tiếp các request đến `Pod` theo `Round Robin`.

> Thông thường `K8S` sẽ nhớ phiên `request` từ một trình duyệt trong 1 khoảng thời gian, trong khoảng thời gian đó, nếu có request mới từ trình duyệt đó, `K8S` sẽ chuyển tiếp request đó đến `Pod` đã xử lý request trước đó.