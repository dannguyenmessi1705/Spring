# gRPC trong Spring Boot
## 1. Giới thiệu
gRPC (gRPC Remote Procedure Call) là một framework RPC mã nguồn mở được phát triển bởi Google. gRPC sử dụng HTTP/2 làm giao thức truyền tải và Protobuf (Protocol Buffers) làm định dạng dữ liệu. gRPC hỗ trợ nhiều ngôn ngữ lập trình khác nhau và cho phép các dịch vụ giao tiếp với nhau một cách hiệu quả và nhanh chóng.

gRPC được sử dụng rộng rãi trong các ứng dụng microservices, nơi mà các dịch vụ cần giao tiếp với nhau qua mạng. gRPC cung cấp nhiều tính năng mạnh mẽ như xác thực, mã hóa, truyền tải dữ liệu nhị phân và hỗ trợ streaming (truyền tải dữ liệu liên tục).

## 2. So sánh gRPC với REST
|| Tiêu chí | gRPC | REST |
|---|---|---|---|
| 1 | Giao thức | HTTP/2 | HTTP/1.1 |
| 2 | Định dạng dữ liệu | Protobuf | JSON |
| 3 | Tốc độ | Nhanh hơn | Chậm hơn |
| 4 | Streaming | Hỗ trợ | Không hỗ trợ |

Ưu điểm của gRPC:
- Tốc độ nhanh hơn so với REST nhờ sử dụng HTTP/2 và Protobuf.
- Hỗ trợ streaming (truyền tải dữ liệu liên tục) giúp tiết kiệm băng thông và tăng hiệu suất.
- Hỗ trợ nhiều ngôn ngữ lập trình khác nhau.
- Hỗ trợ xác thực và mã hóa dữ liệu.

Nhược điểm của gRPC:
- Cần cài đặt thêm thư viện gRPC trên client và server.
- Không hỗ trợ trình duyệt web (cần sử dụng gRPC-Web để hỗ trợ trình duyệt).
- Cần có kiến thức về Protobuf để định nghĩa các dịch vụ và thông điệp.

Kết hợp giữa gRPC và REST:
- Có thể sử dụng gRPC cho các dịch vụ backend hoặc microservices giao tiếp với nhau, trong khi sử dụng REST cho các dịch vụ frontend hoặc client giao tiếp với server.

VD: User gọi API REST để lấy thông tin tài khoản, sau đó gọi API gRPC để lấy thông tin chi tiết về tài khoản đó ở dưới backend.

## 3. Cài đặt gRPC trong Spring Boot
### 3.1. Cài đặt gRPC
Chúng ta sẽ dùng Maven chia thành 3 module:
- `grpc-server`: Module chứa server gRPC.
- `grpc-client`: Module chứa client gRPC.
- `proto`: Module chứa các file proto định nghĩa dịch vụ gRPC.

#### 3.1.1. Cấu trúc dự án

Một dự án gRPC Spring Boot thông thường có thể được tổ chức như sau:

```
grpc-spring-boot/
├── pom.xml                  # Pom chính cho dự án
├── proto/                   # Module chứa định nghĩa protobuf
│   ├── pom.xml             
│   └── src/main/proto/      # Thư mục chứa file proto
│       └── schema.proto     # File định nghĩa service và
├── server/                  # Module server gRPC
│   ├── pom.xml
│   └── src/main/java        # Mã nguồn server
└── client-grpc/             # Module client gRPC
    ├── pom.xml
    └── src/main/java        # Mã nguồn client
```

#### 3.1.2. Pom.xml cho dự án cha

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.4.4</version>
    <relativePath/> <!-- lookup parent from repository -->
  </parent>
  <groupId>com.didan</groupId>
  <artifactId>grpc-spring-boot</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <name>grpc-spring-boot</name>
  <description>grpc-spring-boot</description>
  <url/>
  <licenses>
    <license/>
  </licenses>
  <developers>
    <developer/>
  </developers>
  <scm>
    <connection/>
    <developerConnection/>
    <tag/>
    <url/>
  </scm>
  <!-- Lưu ý packaging là pom -->
  <packaging>pom</packaging>
  <!-- Thêm các module con vào đây -->
  <modules>
    <module>proto</module>
    <module>server</module>
    <module>client-grpc</module>
  </modules>
  <properties>
    <java.version>17</java.version>
  </properties>
  <dependencies>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter</artifactId>
    </dependency>

    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-test</artifactId>
      <scope>test</scope>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
      </plugin>
    </plugins>
  </build>

</project>
```

#### 3.1.3. Pom.xml cho module proto

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <parent>
    <groupId>com.didan</groupId>
    <artifactId>grpc-spring-boot</artifactId>
    <version>0.0.1-SNAPSHOT</version>
  </parent>
  <artifactId>proto</artifactId>
  <url/>
  <licenses>
    <license/>
  </licenses>
  <developers>
    <developer/>
  </developers>
  <scm>
    <connection/>
    <developerConnection/>
    <tag/>
    <url/>
  </scm>
  <properties>
    <java.version>17</java.version>
    <grpc.version>1.70.0</grpc.version>
    <protobuf-java.version>3.25.6</protobuf-java.version>
  </properties>
  <dependencies>
    <!--    grpc dependencies -->
    <dependency>
      <groupId>io.grpc</groupId>
      <artifactId>grpc-netty-shaded</artifactId>
      <version>${grpc.version}</version>
    </dependency>
    <dependency>
      <groupId>io.grpc</groupId>
      <artifactId>grpc-protobuf</artifactId>
      <version>${grpc.version}</version>
    </dependency>
    <dependency>
      <groupId>io.grpc</groupId>
      <artifactId>grpc-stub</artifactId>
      <version>${grpc.version}</version>
    </dependency>
    <dependency>
      <groupId>javax.annotation</groupId>
      <artifactId>javax.annotation-api</artifactId>
      <version>1.3.2</version>
    </dependency>
  </dependencies>

  <build>
    <extensions>
      <!--      extension for os-maven-plugin to generate os specific files -->
      <extension>
        <groupId>kr.motd.maven</groupId>
        <artifactId>os-maven-plugin</artifactId>
        <version>1.7.1</version>
      </extension>
    </extensions>
    <plugins>
      <plugin>
        <groupId>org.xolstice.maven.plugins</groupId>
        <artifactId>protobuf-maven-plugin</artifactId>
        <version>0.6.1</version>
        <configuration>
          <protocArtifact>com.google.protobuf:protoc:${protobuf-java.version}:exe:${os.detected.classifier}</protocArtifact>
          <pluginId>grpc-java</pluginId>
          <pluginArtifact>io.grpc:protoc-gen-grpc-java:${grpc.version}:exe:${os.detected.classifier}</pluginArtifact>
          <!-- Định nghĩa thư mục chứa các file proto ở đây -->
          <protoSourceRoot>${project.basedir}/src/main/proto</protoSourceRoot>
        </configuration>
        <executions>
          <execution>
            <goals>
              <goal>compile</goal>
              <goal>compile-custom</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
    </plugins>
  </build>

</project>
```

#### 3.1.4. Pom.xml cho module server

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.4.4</version>
    <relativePath/> <!-- lookup parent from repository -->
  </parent>
  <groupId>com.didan</groupId>
  <artifactId>server</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <name>server</name>
  <description>server</description>
  <url/>
  <licenses>
    <license/>
  </licenses>
  <developers>
    <developer/>
  </developers>
  <scm>
    <connection/>
    <developerConnection/>
    <tag/>
    <url/>
  </scm>
  <properties>
    <java.version>17</java.version>
  </properties>
  <dependencies>
    <dependency>
      <groupId>com.didan</groupId>
      <artifactId>proto</artifactId>
      <version>0.0.1-SNAPSHOT</version>
      <exclusions>
        <exclusion>
          <groupId>io.grpc</groupId>
          <artifactId>grpc-protobuf</artifactId>
        </exclusion>
        <exclusion>
          <groupId>io.grpc</groupId>
          <artifactId>grpc-stub</artifactId>
        </exclusion>
        <exclusion>
          <groupId>io.grpc</groupId>
          <artifactId>grpc-netty-shaded</artifactId>
        </exclusion>
      </exclusions>
    </dependency>
    <dependency>
      <groupId>net.devh</groupId>
      <artifactId>grpc-server-spring-boot-starter</artifactId>
      <version>3.1.0.RELEASE</version>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
      </plugin>
    </plugins>
  </build>

</project>
```
> Lưu ý: Chúng ta cần phải loại bỏ các dependency `grpc-protobuf`, `grpc-stub`, `grpc-netty-shaded` trong module server vì chúng đã được thêm vào module proto, mà module server sẽ chỉ sử dụng các class đã được sinh ra từ module proto.

#### 3.1.5. Pom.xml cho module client

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.4.4</version>
    <relativePath/> <!-- lookup parent from repository -->
  </parent>
  <groupId>com.didan</groupId>
  <artifactId>client-grpc</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <name>client-grpc</name>
  <description>client-grpc</description>
  <url/>
  <licenses>
    <license/>
  </licenses>
  <developers>
    <developer/>
  </developers>
  <scm>
    <connection/>
    <developerConnection/>
    <tag/>
    <url/>
  </scm>
  <properties>
    <java.version>17</java.version>
  </properties>
  <dependencies>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
      <groupId>com.didan</groupId>
      <artifactId>proto</artifactId>
      <version>0.0.1-SNAPSHOT</version>
    </dependency>
    <dependency>
      <groupId>net.devh</groupId>
      <artifactId>grpc-client-spring-boot-starter</artifactId>
      <version>3.1.0.RELEASE</version>
    </dependency>
    <dependency>
      <groupId>org.projectlombok</groupId>
      <artifactId>lombok</artifactId>
      <optional>true</optional>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-test</artifactId>
      <scope>test</scope>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <configuration>
          <annotationProcessorPaths>
            <path>
              <groupId>org.projectlombok</groupId>
              <artifactId>lombok</artifactId>
            </path>
          </annotationProcessorPaths>
        </configuration>
      </plugin>
      <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
        <configuration>
          <excludes>
            <exclude>
              <groupId>org.projectlombok</groupId>
              <artifactId>lombok</artifactId>
            </exclude>
          </excludes>
        </configuration>
      </plugin>
    </plugins>
  </build>

</project>
```

## 3.2. Định nghĩa gRPC Service với Protobuf

### 3.2.1. Tạo file schema.proto

File `.proto` là file định nghĩa giao thức gRPC bằng ngôn ngữ Protocol Buffers. Dưới đây là các bước để tạo một file `.proto` trong dự án Spring Boot:

1. Đầu tiên, tạo thư mục `proto/src/main/proto` trong dự án của bạn.
2. Tạo file `schema.proto` trong thư mục đó với nội dung như sau:

```proto
syntax = "proto3"; // Khai báo sử dụng phiên bản proto3

package com.didan; // Đặt tên package cho file proto

option java_multiple_files = true; // Tạo nhiều file Java từ một file proto

// Định nghĩa message Book
message Book {
  int32 book_id = 1; // ID của sách (số thứ tự 1)
  string title = 2;  // Tiêu đề sách (số thứ tự 2)
  float price = 3;   // Giá sách (số thứ tự 3)
  int32 pages = 4;   // Số trang (số thứ tự 4)
  int32 author_id = 5; // ID tác giả (số thứ tự 5)
}

// Định nghĩa message Author
message Author {
  int32 author_id = 1;  // ID tác giả
  string first_name = 2; // Tên tác giả
  string last_name = 3;  // Họ tác giả
  string gender = 4;     // Giới tính
  int32 book_id = 5;     // ID sách
}

// Định nghĩa service BookAuthorService
service BookAuthorService {
  // Phương thức unary (1 request, 1 response)
  rpc getAuthor(Author) returns(Author) {}
}
```

### 3.2.2. Chi tiết cú pháp file .proto

#### Cú pháp cơ bản

- `syntax = "proto3"`: Khai báo sử dụng phiên bản Protocol Buffers 3.
- `package com.didan`: Định nghĩa namespace để tránh xung đột tên.
- `option java_multiple_files = true`: Tạo file Java riêng cho mỗi message và service.

#### Message

Message là cấu trúc dữ liệu chính trong Protocol Buffers. Mỗi trường trong message được định nghĩa với cú pháp:

```proto
<kiểu_dữ_liệu> <tên_trường> = <số_thứ_tự>;
```

- **Kiểu dữ liệu**: int32, int64, float, double, bool, string, bytes, enum, message khác,...
- **Tên trường**: Tên của trường (nên sử dụng snake_case).
- **Số thứ tự**: Số nguyên dương duy nhất cho mỗi trường trong message, dùng để định danh trường trong quá trình serialize/deserialize.

#### Service

Service định nghĩa các phương thức RPC mà client có thể gọi:

```proto
service <TênService> {
  rpc <TênPhươngThức>(<KiểuRequest>) returns (<KiểuResponse>) {}
}
```

#### Các kiểu RPC

1. **Unary RPC**: Client gửi một request, server trả về một response.
   ```proto
   rpc getAuthor(Author) returns(Author) {}
   ```

2. **Server Streaming RPC**: Client gửi một request, server trả về nhiều response.
   ```proto
   rpc listAuthors(Author) returns(stream Author) {}
   ```

3. **Client Streaming RPC**: Client gửi nhiều request, server trả về một response.
   ```proto
   rpc createAuthors(stream Author) returns(Author) {}
   ```

4. **Bidirectional Streaming RPC**: Client và server đều gửi nhiều message.
   ```proto
   rpc chatWithAuthor(stream Author) returns(stream Author) {}
   ```

### 3.2.3. Cấu hình Maven để compile file .proto

Để biên dịch file `.proto` thành mã Java, bạn cần cấu hình plugin `protobuf-maven-plugin` trong file `pom.xml`:

```xml
<properties>
  <java.version>17</java.version>
  <grpc.version>1.70.0</grpc.version>
  <protobuf-java.version>3.25.6</protobuf-java.version>
</properties>

<dependencies>
  <!-- gRPC dependencies -->
  <dependency>
    <groupId>io.grpc</groupId>
    <artifactId>grpc-netty-shaded</artifactId>
    <version>${grpc.version}</version>
  </dependency>
  <dependency>
    <groupId>io.grpc</groupId>
    <artifactId>grpc-protobuf</artifactId>
    <version>${grpc.version}</version>
  </dependency>
  <dependency>
    <groupId>io.grpc</groupId>
    <artifactId>grpc-stub</artifactId>
    <version>${grpc.version}</version>
  </dependency>
  <dependency>
    <groupId>javax.annotation</groupId>
    <artifactId>javax.annotation-api</artifactId>
    <version>1.3.2</version>
  </dependency>
</dependencies>

<build>
  <extensions>
    <!-- Extension cần thiết để phát hiện hệ điều hành và tạo file phù hợp -->
    <extension>
      <groupId>kr.motd.maven</groupId>
      <artifactId>os-maven-plugin</artifactId>
      <version>1.7.1</version>
    </extension>
  </extensions>
  <plugins>
    <!-- Plugin để biên dịch file .proto thành mã Java -->
    <plugin>
      <groupId>org.xolstice.maven.plugins</groupId>
      <artifactId>protobuf-maven-plugin</artifactId>
      <version>0.6.1</version>
      <configuration>
        <protocArtifact>com.google.protobuf:protoc:${protobuf-java.version}:exe:${os.detected.classifier}</protocArtifact>
        <pluginId>grpc-java</pluginId>
        <pluginArtifact>io.grpc:protoc-gen-grpc-java:${grpc.version}:exe:${os.detected.classifier}</pluginArtifact>
        <protoSourceRoot>${project.basedir}/src/main/proto</protoSourceRoot>
      </configuration>
      <executions>
        <execution>
          <goals>
            <goal>compile</goal>       <!-- Biên dịch message -->
            <goal>compile-custom</goal> <!-- Biên dịch service -->
          </goals>
        </execution>
      </executions>
    </plugin>
  </plugins>
</build>
```

### 3.2.4. Biên dịch file .proto

Sau khi đã cấu hình Maven plugin, bạn có thể biên dịch file `.proto` bằng câu lệnh:

```bash
mvn clean compile
```

Khi chạy lệnh này, Maven sẽ sử dụng protoc compiler để biên dịch file `.proto` thành các class Java tương ứng.

### 3.2.5. Các file Java được tạo ra sau khi biên dịch

Khi biên dịch file `.proto` có nội dung như trên, các file Java sau sẽ được tạo ra trong thư mục `target/generated-sources/protobuf`:

1. **Message classes**:
   - `Book.java`: Class cho message Book.
   - `BookOrBuilder.java`: Interface cho Book builder.
   - `Author.java`: Class cho message Author.
   - `AuthorOrBuilder.java`: Interface cho Author builder.

2. **Service classes**:
   - `BookAuthorServiceGrpc.java`: Class chứa code để gọi service, bao gồm:
     - `BookAuthorServiceImplBase`: Abstract class để implement service trên server.
     - `BookAuthorServiceBlockingStub`: Stub để gọi service một cách đồng bộ.
     - `BookAuthorServiceFutureStub`: Stub để gọi service với Future.
     - `BookAuthorServiceStub`: Stub để gọi service một cách bất đồng bộ.

### 3.2.6. Các kiểu dữ liệu trong Protocol Buffers

| Kiểu Protobuf | Kiểu Java | Mô tả |
|---------------|-----------|-------|
| double | double | Số thực 64-bit |
| float | float | Số thực 32-bit |
| int32 | int | Số nguyên 32-bit |
| int64 | long | Số nguyên 64-bit |
| bool | boolean | Giá trị boolean |
| string | String | Chuỗi UTF-8 |
| bytes | ByteString | Mảng byte |
| enum | enum Java | Kiểu liệt kê |
| message | Class Java | Kiểu phức hợp |

### 3.2.7. Best practices khi viết file .proto

1. **Số thứ tự trường**:
   - Sử dụng số từ 1-15 cho các trường thường xuyên được sử dụng (chỉ tốn 1 byte).
   - Số từ 16-2047 tốn 2 bytes.
   - Không sử dụng lại số thứ tự, ngay cả khi trường đã bị xóa.

2. **Tên trường**:
   - Sử dụng snake_case cho tên trường trong file .proto.
   - Protobuf compiler sẽ tự động chuyển thành camelCase trong code Java.

3. **Phiên bản**:
   - Thêm phiên bản vào tên package để hỗ trợ tương thích ngược.
   - Ví dụ: `package com.didan.v1;`

4. **Reserved Fields**:
   - Khi xóa một trường, đánh dấu số của nó là reserved để tránh tái sử dụng.
   ```proto
   message Book {
     reserved 4, 15, 16 to 20;
     reserved "removed_field";
   }
   ```

5. **Default Values**:
   - Khi một trường không được set, nó sẽ có giá trị mặc định (0, chuỗi rỗng, false).
   - Không thể phân biệt giữa giá trị mặc định và giá trị được set.

### 3.2.8. Ví dụ mở rộng

Ví dụ về việc sử dụng các tính năng nâng cao của Protocol Buffers:

```proto
syntax = "proto3";

package com.didan.v1;

option java_multiple_files = true;
option java_package = "com.didan.model";
option java_outer_classname = "BookProtos";

import "google/protobuf/timestamp.proto";

// Định nghĩa enum cho thể loại sách
enum BookCategory {
  UNKNOWN = 0;
  FICTION = 1;
  SCIENCE = 2;
  BIOGRAPHY = 3;
  TECHNOLOGY = 4;
}

message Book {
  int32 book_id = 1;
  string title = 2;
  float price = 3;
  int32 pages = 4;
  int32 author_id = 5;
  BookCategory category = 6;
  google.protobuf.Timestamp published_date = 7;
  
  // Nested message - Thông tin nhà xuất bản
  message Publisher {
    string name = 1;
    string address = 2;
  }
  
  Publisher publisher = 8;
  
  // Repeated field - Danh sách từ khóa
  repeated string keywords = 9;
}

// Request/Response messages
message GetBookRequest {
  int32 book_id = 1;
}

message GetBookResponse {
  Book book = 1;
  string message = 2;
  int32 status_code = 3;
}

// Service với nhiều phương thức
service BookService {
  // Unary
  rpc GetBook(GetBookRequest) returns(GetBookResponse) {}
  
  // Server streaming
  rpc ListBooks(GetBookRequest) returns(stream Book) {}
  
  // Client streaming
  rpc CreateBooks(stream Book) returns(GetBookResponse) {}
  
  // Bidirectional streaming
  rpc ProcessBooks(stream Book) returns(stream GetBookResponse) {}
}
```

## 4. Tạo server gRPC trong Spring Boot

Sau khi đã định nghĩa các service và message trong file `.proto` và biên dịch thành code Java, bước tiếp theo là triển khai server gRPC trong Spring Boot.

### 4.1. Cấu trúc project server

Một project server gRPC trong Spring Boot thường có cấu trúc như sau:

```
server/
├── src/
│   └── main/
│       ├── java/
│       │   └── com/
│       │       └── didan/
│       │           └── server/
│       │               ├── ServerApplication.java
│       │               ├── service/
│       │               │   └── BookAuthorServerService.java
│       │               └── controller/
│       │                   └── BookAuthorController.java (nếu cần REST API)
│       └── resources/
│           └── application.yml
└── pom.xml
```

### 4.2. Tạo Spring Boot application cho server

```java
package com.didan.server;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(ServerApplication.class, args);
    }
}
```

### 4.3. Cấu hình application.yml

```yaml
server:
  port: 8080  # Port cho REST API (nếu cần)

spring:
  application:
    name: grpc-server

grpc:
  server:
    port: 9090  # Port cho gRPC server
```

### 4.4. Triển khai gRPC Service

Để triển khai một gRPC service, bạn cần tạo một class kế thừa từ abstract class được tự động tạo ra từ file `.proto`. Trong trường hợp này, chúng ta sẽ triển khai `BookAuthorServiceGrpc.BookAuthorServiceImplBase`.

```java
package com.didan.server.service;

import com.didan.Author;
import com.didan.BookAuthorServiceGrpc;
import io.grpc.stub.StreamObserver;
import net.devh.boot.grpc.server.service.GrpcService;

@GrpcService
public class BookAuthorServerService extends BookAuthorServiceGrpc.BookAuthorServiceImplBase {

    @Override
    public void getAuthor(Author request, StreamObserver<Author> responseObserver) {
        // Xử lý yêu cầu và tạo phản hồi
        System.out.println("Server received request for author ID: " + request.getAuthorId());
        
        // Tạo đối tượng Author để trả về
        Author response = Author.newBuilder()
                .setAuthorId(request.getAuthorId())
                .setFirstName("Nguyễn")
                .setLastName("Văn A")
                .setGender("Nam")
                .setBookId(123)
                .build();
        
        // Gửi response về client
        responseObserver.onNext(response);
        
        // Hoàn thành xử lý
        responseObserver.onCompleted();
    }
}
```

Annotation `@GrpcService` đánh dấu class này là một gRPC service và tự động đăng ký nó với gRPC server.

### 4.5. Tạo server streaming service

```java
@GrpcService
public class BookAuthorServerService extends BookAuthorServiceGrpc.BookAuthorServiceImplBase {

    // Phương thức unary đã triển khai ở trên
    // ...
    
    @Override
    public void listAuthors(Author request, StreamObserver<Author> responseObserver) {
        System.out.println("Server received request to list authors with book ID: " + request.getBookId());
        
        // Giả lập việc gửi nhiều author về client
        for (int i = 1; i <= 5; i++) {
            Author author = Author.newBuilder()
                .setAuthorId(100 + i)
                .setFirstName("Tác giả")
                .setLastName("Số " + i)
                .setGender(i % 2 == 0 ? "Nam" : "Nữ")
                .setBookId(request.getBookId())
                .build();
            
            // Gửi từng author về client
            responseObserver.onNext(author);
            
            // Giả lập delay để thấy rõ streaming
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        
        // Hoàn thành stream
        responseObserver.onCompleted();
    }
}
```

Lưu ý: Phương thức `listAuthors` phải được định nghĩa trong file `.proto` trước khi triển khai:

```proto
service BookAuthorService {
  // unary
  rpc getAuthor(Author) returns(Author) {}
  
  // server streaming
  rpc listAuthors(Author) returns(stream Author) {}
}
```

### 4.6. Tạo client streaming service

```java
@GrpcService
public class BookAuthorServerService extends BookAuthorServiceGrpc.BookAuthorServiceImplBase {

    // Các phương thức đã triển khai ở trên
    // ...
    
    @Override
    public StreamObserver<Author> createAuthors(StreamObserver<Author> responseObserver) {
        return new StreamObserver<Author>() {
            private int count = 0;
            private Author lastAuthor = null;
            
            @Override
            public void onNext(Author author) {
                // Xử lý mỗi author được gửi từ client
                count++;
                System.out.println("Received author #" + count + ": " + author.getFirstName() + " " + author.getLastName());
                lastAuthor = author;
            }
            
            @Override
            public void onError(Throwable t) {
                // Xử lý lỗi
                System.err.println("Error in createAuthors: " + t.getMessage());
            }
            
            @Override
            public void onCompleted() {
                // Khi client hoàn thành việc gửi dữ liệu
                System.out.println("Client completed sending data. Total authors received: " + count);
                
                // Gửi response về client
                Author response;
                if (lastAuthor != null) {
                    response = Author.newBuilder(lastAuthor)
                            .setFirstName("Processed " + count + " authors")
                            .build();
                } else {
                    response = Author.newBuilder()
                            .setAuthorId(-1)
                            .setFirstName("No authors received")
                            .build();
                }
                
                responseObserver.onNext(response);
                responseObserver.onCompleted();
            }
        };
    }
}
```

Lưu ý: Phương thức `createAuthors` phải được định nghĩa trong file `.proto`:

```proto
service BookAuthorService {
  // ... other methods
  
  // client streaming
  rpc createAuthors(stream Author) returns(Author) {}
}
```

### 4.7. Tạo bidirectional streaming service

```java
@GrpcService
public class BookAuthorServerService extends BookAuthorServiceGrpc.BookAuthorServiceImplBase {

    // Các phương thức đã triển khai ở trên
    // ...
    
    @Override
    public StreamObserver<Author> processAuthors(StreamObserver<Author> responseObserver) {
        return new StreamObserver<Author>() {
            @Override
            public void onNext(Author author) {
                // Xử lý mỗi author nhận được từ client
                System.out.println("Received author: " + author.getFirstName() + " " + author.getLastName());
                
                // Tạo response và gửi ngay về client
                Author response = Author.newBuilder()
                        .setAuthorId(author.getAuthorId())
                        .setFirstName("Processed: " + author.getFirstName())
                        .setLastName(author.getLastName().toUpperCase())
                        .setGender(author.getGender())
                        .setBookId(author.getBookId())
                        .build();
                
                responseObserver.onNext(response);
            }
            
            @Override
            public void onError(Throwable t) {
                System.err.println("Error in processAuthors: " + t.getMessage());
            }
            
            @Override
            public void onCompleted() {
                System.out.println("Client completed sending authors");
                responseObserver.onCompleted();
            }
        };
    }
}
```

Lưu ý: Phương thức `processAuthors` phải được định nghĩa trong file `.proto`:

```proto
service BookAuthorService {
  // ... other methods
  
  // bidirectional streaming
  rpc processAuthors(stream Author) returns(stream Author) {}
}
```

### 4.8. Tích hợp với Spring Data JPA (Tuỳ chọn)

Nếu bạn muốn tích hợp gRPC service với cơ sở dữ liệu, bạn có thể sử dụng Spring Data JPA.

#### 4.8.1. Thêm dependency vào pom.xml

```xml
<dependencies>
    <!-- Existing dependencies -->
    
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
        <groupId>com.h2database</groupId>
        <artifactId>h2</artifactId>
        <scope>runtime</scope>
    </dependency>
</dependencies>
```

#### 4.8.2. Tạo Entity

```java
package com.didan.server.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AuthorEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    
    private String firstName;
    private String lastName;
    private String gender;
    private Integer bookId;
}
```

#### 4.8.3. Tạo Repository

```java
package com.didan.server.repository;

import com.didan.server.entity.AuthorEntity;
import org.springframework.data.jpa.repository.JpaRepository;

public interface AuthorRepository extends JpaRepository<AuthorEntity, Integer> {
}
```

#### 4.8.4. Cập nhật Service để sử dụng Repository

```java
package com.didan.server.service;

import com.didan.Author;
import com.didan.BookAuthorServiceGrpc;
import com.didan.server.entity.AuthorEntity;
import com.didan.server.repository.AuthorRepository;
import io.grpc.Status;
import io.grpc.stub.StreamObserver;
import net.devh.boot.grpc.server.service.GrpcService;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.Optional;

@GrpcService
public class BookAuthorServerService extends BookAuthorServiceGrpc.BookAuthorServiceImplBase {

    private final AuthorRepository authorRepository;
    
    @Autowired
    public BookAuthorServerService(AuthorRepository authorRepository) {
        this.authorRepository = authorRepository;
    }

    @Override
    public void getAuthor(Author request, StreamObserver<Author> responseObserver) {
        try {
            if (request.getAuthorId() <= 0) {
                // Xử lý lỗi nếu ID không hợp lệ
                responseObserver.onError(
                    Status.INVALID_ARGUMENT
                        .withDescription("Author ID must be positive")
                        .asRuntimeException()
                );
                return;
            }
            
            // Tìm author từ database
            Optional<AuthorEntity> optionalAuthor = authorRepository.findById(request.getAuthorId());
            
            if (optionalAuthor.isPresent()) {
                AuthorEntity entity = optionalAuthor.get();
                
                // Chuyển đổi từ entity sang protobuf message
                Author response = Author.newBuilder()
                        .setAuthorId(entity.getId())
                        .setFirstName(entity.getFirstName())
                        .setLastName(entity.getLastName())
                        .setGender(entity.getGender())
                        .setBookId(entity.getBookId())
                        .build();
                
                // Gửi response về client
                responseObserver.onNext(response);
                responseObserver.onCompleted();
            } else {
                // Xử lý khi không tìm thấy author
                responseObserver.onError(
                    Status.NOT_FOUND
                        .withDescription("Author not found with ID: " + request.getAuthorId())
                        .asRuntimeException()
                );
            }
        } catch (Exception e) {
            // Xử lý ngoại lệ
            responseObserver.onError(
                Status.INTERNAL
                    .withDescription("Internal server error: " + e.getMessage())
                    .asRuntimeException()
            );
        }
    }
}
```

### 4.9. Xử lý lỗi trong gRPC Server

#### 4.9.1. Các mã lỗi gRPC

gRPC định nghĩa các mã lỗi chuẩn qua class `io.grpc.Status`:

| Mã lỗi | Mô tả |
|--------|-------|
| OK | Thành công (mã 0) |
| CANCELLED | Hoạt động bị hủy |
| UNKNOWN | Lỗi không xác định |
| INVALID_ARGUMENT | Tham số không hợp lệ |
| DEADLINE_EXCEEDED | Quá thời gian chờ |
| NOT_FOUND | Không tìm thấy tài nguyên |
| ALREADY_EXISTS | Tài nguyên đã tồn tại |
| PERMISSION_DENIED | Không có quyền truy cập |
| RESOURCE_EXHAUSTED | Hết tài nguyên |
| FAILED_PRECONDITION | Điều kiện tiên quyết không thỏa mãn |
| ABORTED | Hoạt động bị hủy bỏ |
| OUT_OF_RANGE | Ngoài phạm vi |
| UNIMPLEMENTED | Phương thức không được triển khai |
| INTERNAL | Lỗi nội bộ |
| UNAVAILABLE | Dịch vụ không khả dụng |
| DATA_LOSS | Mất dữ liệu |
| UNAUTHENTICATED | Chưa xác thực |

#### 4.9.2. Ví dụ xử lý lỗi

```java
@Override
public void getAuthor(Author request, StreamObserver<Author> responseObserver) {
    try {
        // Validate request
        if (request.getAuthorId() <= 0) {
            responseObserver.onError(
                Status.INVALID_ARGUMENT
                    .withDescription("Author ID must be positive")
                    .asRuntimeException()
            );
            return;
        }
        
        // Check if author exists
        boolean authorExists = /* logic to check if author exists */;
        if (!authorExists) {
            responseObserver.onError(
                Status.NOT_FOUND
                    .withDescription("Author not found with ID: " + request.getAuthorId())
                    .asRuntimeException()
            );
            return;
        }
        
        // Process request and send response
        // ...
        
    } catch (Exception e) {
        responseObserver.onError(
            Status.INTERNAL
                .withDescription("Internal server error: " + e.getMessage())
                .asRuntimeException()
        );
    }
}
```

### 4.10. Bảo mật trong gRPC Server

#### 4.10.1. Cấu hình TLS/SSL

Để bảo mật kết nối giữa client và server, bạn có thể cấu hình TLS/SSL cho gRPC server:

```yaml
# application.yml
grpc:
  server:
    security:
      enabled: true
      certificateChain: classpath:certificates/server.crt
      privateKey: classpath:certificates/server.key
```

#### 4.10.2. Xác thực với Interceptor

Tạo một Interceptor để xác thực các yêu cầu gRPC:

```java
package com.didan.server.interceptor;

import io.grpc.*;
import net.devh.boot.grpc.server.interceptor.GrpcGlobalServerInterceptor;
import org.springframework.stereotype.Component;

@Component
@GrpcGlobalServerInterceptor
public class AuthInterceptor implements ServerInterceptor {

    private static final Metadata.Key<String> AUTH_TOKEN_KEY =
            Metadata.Key.of("Authorization", Metadata.ASCII_STRING_MARSHALLER);

    @Override
    public <ReqT, RespT> ServerCall.Listener<ReqT> interceptCall(
            ServerCall<ReqT, RespT> call,
            Metadata headers,
            ServerCallHandler<ReqT, RespT> next) {
        
        String token = headers.get(AUTH_TOKEN_KEY);
        
        if (token == null || !isValidToken(token)) {
            call.close(Status.UNAUTHENTICATED
                    .withDescription("Invalid or missing token"),
                    new Metadata());
                    
            return new ServerCall.Listener<>() {};
        }
        
        return next.startCall(call, headers);
    }
    
    private boolean isValidToken(String token) {
        // Logic kiểm tra token
        // Trong thực tế, bạn có thể sử dụng JWT hoặc OAuth2
        return token.startsWith("Bearer ") && token.length() > 10;
    }
}
```

### 4.11. Logging và Monitoring

#### 4.11.1. Tạo Logging Interceptor

```java
package com.didan.server.interceptor;

import io.grpc.*;
import net.devh.boot.grpc.server.interceptor.GrpcGlobalServerInterceptor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

@Component
@GrpcGlobalServerInterceptor
public class LoggingInterceptor implements ServerInterceptor {

    private static final Logger logger = LoggerFactory.getLogger(LoggingInterceptor.class);

    @Override
    public <ReqT, RespT> ServerCall.Listener<ReqT> interceptCall(
            ServerCall<ReqT, RespT> call,
            Metadata headers,
            ServerCallHandler<ReqT, RespT> next) {
        
        String methodName = call.getMethodDescriptor().getFullMethodName();
        logger.info("gRPC call received: {}", methodName);
        
        return new ForwardingServerCallListener.SimpleForwardingServerCallListener<>(
                next.startCall(new ForwardingServerCall.SimpleForwardingServerCall<ReqT, RespT>(call) {
                    
                    @Override
                    public void sendMessage(RespT message) {
                        logger.info("Sending response for method: {}", methodName);
                        super.sendMessage(message);
                    }
                    
                    @Override
                    public void close(Status status, Metadata trailers) {
                        logger.info("Closing call for method: {} with status: {}", 
                                methodName, status.getCode());
                        super.close(status, trailers);
                    }
                }, headers)) {
            
            @Override
            public void onMessage(ReqT message) {
                logger.info("Received message: {}", message);
                super.onMessage(message);
            }
            
            @Override
            public void onHalfClose() {
                logger.info("Client finished sending messages for method: {}", methodName);
                super.onHalfClose();
            }
            
            @Override
            public void onComplete() {
                logger.info("Call completed for method: {}", methodName);
                super.onComplete();
            }
            
            @Override
            public void onCancel() {
                logger.info("Call cancelled for method: {}", methodName);
                super.onCancel();
            }
        };
    }
}
```

### 4.12. Testing gRPC Server

#### 4.12.1. Tạo Unit Test

```java
package com.didan.server.service;

import com.didan.Author;
import com.didan.BookAuthorServiceGrpc;
import io.grpc.internal.testing.StreamRecorder;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit.jupiter.SpringExtension;

import java.util.List;
import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.*;

@ExtendWith(SpringExtension.class)
@SpringBootTest
public class BookAuthorServiceTest {

    @Autowired
    private BookAuthorServerService bookAuthorService;

    @Test
    public void testGetAuthor() throws Exception {
        // Tạo request
        Author request = Author.newBuilder()
                .setAuthorId(123)
                .build();
        
        // Tạo StreamRecorder để thu thập response
        StreamRecorder<Author> responseObserver = StreamRecorder.create();
        
        // Gọi service
        bookAuthorService.getAuthor(request, responseObserver);
        
        // Đợi kết quả
        if (!responseObserver.awaitCompletion(5, TimeUnit.SECONDS)) {
            fail("The call did not terminate in time");
        }
        
        // Kiểm tra không có lỗi
        assertNull(responseObserver.getError());
        
        // Kiểm tra có đúng một response
        List<Author> results = responseObserver.getValues();
        assertEquals(1, results.size());
        
        // Kiểm tra nội dung response
        Author response = results.get(0);
        assertEquals(123, response.getAuthorId());
        assertEquals("Nguyễn", response.getFirstName());
        assertEquals("Văn A", response.getLastName());
    }
}
```

#### 4.12.2. Tạo Integration Test

```java
package com.didan.server;

import com.didan.Author;
import com.didan.BookAuthorServiceGrpc;
import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;
import org.springframework.boot.test.web.server.LocalServerPort;
import org.springframework.test.annotation.DirtiesContext;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;

@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@DirtiesContext
public class BookAuthorServiceIntegrationTest {

    @LocalServerPort
    private int port;

    private static ManagedChannel channel;
    private static BookAuthorServiceGrpc.BookAuthorServiceBlockingStub blockingStub;

    @BeforeAll
    public static void setupChannel() {
        // Tạo channel kết nối đến server
        channel = ManagedChannelBuilder.forAddress("localhost", 9090)
                .usePlaintext()
                .build();
        
        blockingStub = BookAuthorServiceGrpc.newBlockingStub(channel);
    }

    @AfterAll
    public static void tearDown() {
        // Đóng channel sau khi test xong
        channel.shutdownNow();
    }

    @Test
    public void testGetAuthor() {
        // Tạo request
        Author request = Author.newBuilder()
                .setAuthorId(123)
                .build();
        
        // Gọi service và nhận response
        Author response = blockingStub.getAuthor(request);
        
        // Kiểm tra response
        assertNotNull(response);
        assertEquals(123, response.getAuthorId());
        assertEquals("Nguyễn", response.getFirstName());
        assertEquals("Văn A", response.getLastName());
    }
}
```

## 5. Tạo client gRPC trong Spring Boot

Sau khi đã triển khai server gRPC, bước tiếp theo là tạo client để gọi các service này. Trong phần này, chúng ta sẽ tìm hiểu cách tạo client gRPC trong Spring Boot.

### 5.1. Cấu trúc project client

Một project client gRPC trong Spring Boot thường có cấu trúc như sau:

```
client-grpc/
├── src/
│   └── main/
│       ├── java/
│       │   └── com/
│       │       └── didan/
│       │           └── client/
│       │               ├── ClientApplication.java
│       │               ├── service/
│       │               │   └── BookAuthorClientService.java
│       │               └── controller/
│       │                   └── BookAuthorController.java
│       └── resources/
│           └── application.yml
└── pom.xml
```

### 5.2. Tạo Spring Boot application cho client

```java
package com.didan.client;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ClientApplication {
    public static void main(String[] args) {
        SpringApplication.run(ClientApplication.class, args);
    }
}
```

### 5.3. Cấu hình application.yml

```yaml
server:
  port: 8081  # Port cho REST API của client

spring:
  application:
    name: grpc-client

grpc:
  client:
    book-author-service:  # Tên của gRPC client
      address: static://localhost:9090  # Địa chỉ của gRPC server
      negotiation-type: plaintext  # Loại kết nối (plaintext hoặc TLS)
```

### 5.4. Tạo Client Service

Để gọi gRPC service từ client, chúng ta sẽ sử dụng @GrpcClient annotation để inject stub được tạo ra từ file `.proto`.

```java
package com.didan.client.service;

import com.didan.Author;
import com.didan.BookAuthorServiceGrpc;
import net.devh.boot.grpc.client.inject.GrpcClient;
import org.springframework.stereotype.Service;

@Service
public class BookAuthorClientService {

    @GrpcClient("book-author-service")
    private BookAuthorServiceGrpc.BookAuthorServiceBlockingStub bookAuthorServiceStub;

    /**
     * Gọi phương thức getAuthor từ server gRPC
     * @param authorId ID của tác giả
     * @return Author từ server
     */
    public Author getAuthor(int authorId) {
        // Tạo request
        Author request = Author.newBuilder()
                .setAuthorId(authorId)
                .build();
        
        // Gọi service và trả về response
        return bookAuthorServiceStub.getAuthor(request);
    }
}
```

### 5.5. Tạo REST Controller để gọi gRPC Service

Để người dùng có thể gọi gRPC service qua REST API, chúng ta có thể tạo một REST controller:

```java
package com.didan.client.controller;

import com.didan.Author;
import com.didan.client.service.BookAuthorClientService;
import io.grpc.StatusRuntimeException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/authors")
public class BookAuthorController {

    private final BookAuthorClientService bookAuthorClientService;

    @Autowired
    public BookAuthorController(BookAuthorClientService bookAuthorClientService) {
        this.bookAuthorClientService = bookAuthorClientService;
    }

    @GetMapping("/{authorId}")
    public ResponseEntity<?> getAuthor(@PathVariable int authorId) {
        try {
            Author author = bookAuthorClientService.getAuthor(authorId);
            return ResponseEntity.ok(author);
        } catch (StatusRuntimeException e) {
            // Xử lý lỗi gRPC và chuyển đổi thành HTTP status
            return switch (e.getStatus().getCode()) {
                case NOT_FOUND -> ResponseEntity.notFound().build();
                case INVALID_ARGUMENT -> ResponseEntity.badRequest().body(e.getStatus().getDescription());
                case PERMISSION_DENIED -> ResponseEntity.status(HttpStatus.FORBIDDEN).build();
                case UNAUTHENTICATED -> ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
                default -> ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Error: " + e.getMessage());
            };
        }
    }
}
```

### 5.6. Tạo client cho server streaming

Để gọi server streaming method, chúng ta cần sử dụng non-blocking stub:

```java
@Service
public class BookAuthorClientService {

    @GrpcClient("book-author-service")
    private BookAuthorServiceGrpc.BookAuthorServiceBlockingStub blockingStub;
    
    @GrpcClient("book-author-service")
    private BookAuthorServiceGrpc.BookAuthorServiceStub asyncStub;

    // Phương thức unary đã triển khai ở trên
    // ...

    /**
     * Gọi phương thức listAuthors từ server gRPC (server streaming)
     * @param bookId ID của sách
     * @param observer Observer để nhận kết quả
     */
    public void listAuthors(int bookId, StreamObserver<Author> observer) {
        // Tạo request
        Author request = Author.newBuilder()
                .setBookId(bookId)
                .build();
        
        // Gọi server streaming method
        asyncStub.listAuthors(request, observer);
    }
    
    /**
     * Gọi phương thức listAuthors và trả về danh sách authors
     * @param bookId ID của sách
     * @return Danh sách authors
     */
    public List<Author> listAuthorsBlocking(int bookId) {
        // Tạo request
        Author request = Author.newBuilder()
                .setBookId(bookId)
                .build();
        
        // Gọi server streaming method với blocking stub
        List<Author> authors = new ArrayList<>();
        blockingStub.listAuthors(request).forEachRemaining(authors::add);
        
        return authors;
    }
}
```

### 5.7. Tạo client cho client streaming

```java
@Service
public class BookAuthorClientService {

    // Stubs đã khai báo ở trên
    // ...

    /**
     * Gọi phương thức createAuthors từ server gRPC (client streaming)
     * @param authors Danh sách authors
     * @return Author response từ server
     */
    public CompletableFuture<Author> createAuthors(List<Author> authors) {
        CompletableFuture<Author> future = new CompletableFuture<>();
        
        StreamObserver<Author> responseObserver = new StreamObserver<>() {
            @Override
            public void onNext(Author author) {
                // Nhận response từ server
                future.complete(author);
            }
            
            @Override
            public void onError(Throwable t) {
                future.completeExceptionally(t);
            }
            
            @Override
            public void onCompleted() {
                // Không cần làm gì vì đã có future.complete trong onNext
            }
        };
        
        // Lấy requestObserver để gửi dữ liệu
        StreamObserver<Author> requestObserver = asyncStub.createAuthors(responseObserver);
        
        try {
            // Gửi từng author đến server
            for (Author author : authors) {
                requestObserver.onNext(author);
            }
            
            // Báo đã hoàn thành việc gửi dữ liệu
            requestObserver.onCompleted();
            
        } catch (Exception e) {
            requestObserver.onError(e);
            future.completeExceptionally(e);
        }
        
        return future;
    }
}
```

### 5.8. Tạo client cho bidirectional streaming

```java
@Service
public class BookAuthorClientService {

    // Stubs đã khai báo ở trên
    // ...

    /**
     * Gọi phương thức processAuthors từ server gRPC (bidirectional streaming)
     * @param authors Danh sách authors
     * @param responseHandler Handler để xử lý mỗi response
     */
    public void processAuthors(List<Author> authors, Consumer<Author> responseHandler) {
        CountDownLatch finishLatch = new CountDownLatch(1);
        
        StreamObserver<Author> responseObserver = new StreamObserver<>() {
            @Override
            public void onNext(Author author) {
                // Xử lý mỗi response nhận được từ server
                responseHandler.accept(author);
            }
            
            @Override
            public void onError(Throwable t) {
                finishLatch.countDown();
            }
            
            @Override
            public void onCompleted() {
                finishLatch.countDown();
            }
        };
        
        StreamObserver<Author> requestObserver = asyncStub.processAuthors(responseObserver);
        
        try {
            // Gửi từng author đến server
            for (Author author : authors) {
                requestObserver.onNext(author);
                Thread.sleep(500); // Delay để demo
            }
            
            // Báo đã hoàn thành việc gửi dữ liệu
            requestObserver.onCompleted();
            
            // Đợi kết quả từ server (hoặc có thể sử dụng Future)
            finishLatch.await(30, TimeUnit.SECONDS);
            
        } catch (Exception e) {
            requestObserver.onError(e);
        }
    }
}
```

### 5.9. Thêm REST Controller cho streaming APIs

```java
@RestController
@RequestMapping("/api/authors")
public class BookAuthorController {

    private final BookAuthorClientService bookAuthorClientService;

    @Autowired
    public BookAuthorController(BookAuthorClientService bookAuthorClientService) {
        this.bookAuthorClientService = bookAuthorClientService;
    }

    // Phương thức getAuthor đã triển khai ở trên
    // ...
    
    @GetMapping("/book/{bookId}")
    public ResponseEntity<List<Author>> listAuthors(@PathVariable int bookId) {
        try {
            List<Author> authors = bookAuthorClientService.listAuthorsBlocking(bookId);
            return ResponseEntity.ok(authors);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    @PostMapping("/bulk")
    public ResponseEntity<Author> createAuthors(@RequestBody List<Author> authors) {
        try {
            Author response = bookAuthorClientService.createAuthors(authors).get(30, TimeUnit.SECONDS);
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
}
```

### 5.10. Xử lý lỗi trong gRPC Client

#### 5.10.1. Sử dụng try-catch

```java
public Author getAuthor(int authorId) {
    try {
        Author request = Author.newBuilder().setAuthorId(authorId).build();
        return bookAuthorServiceStub.getAuthor(request);
    } catch (StatusRuntimeException e) {
        // Xử lý lỗi dựa trên Status.Code
        if (e.getStatus().getCode() == Status.Code.NOT_FOUND) {
            throw new ResourceNotFoundException("Author not found with ID: " + authorId);
        } else if (e.getStatus().getCode() == Status.Code.INVALID_ARGUMENT) {
            throw new IllegalArgumentException("Invalid author ID: " + authorId);
        } else {
            throw new RuntimeException("Error calling gRPC service: " + e.getMessage(), e);
        }
    }
}
```

#### 5.10.2. Sử dụng Client Interceptor để xử lý lỗi

```java
@GrpcGlobalClientInterceptor
public class ErrorHandlingInterceptor implements ClientInterceptor {

    private static final Logger logger = LoggerFactory.getLogger(ErrorHandlingInterceptor.class);

    @Override
    public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall(
            MethodDescriptor<ReqT, RespT> method, 
            CallOptions callOptions, 
            Channel next) {
        
        return new ForwardingClientCall.SimpleForwardingClientCall<>(
                next.newCall(method, callOptions)) {
            
            @Override
            public void start(Listener<RespT> responseListener, Metadata headers) {
                super.start(new ForwardingClientCallListener.SimpleForwardingClientCallListener<>(
                        responseListener) {
                    @Override
                    public void onClose(Status status, Metadata trailers) {
                        if (!status.isOk()) {
                            logger.error("gRPC call failed with status: {} - {}", 
                                    status.getCode(), status.getDescription());
                        }
                        super.onClose(status, trailers);
                    }
                }, headers);
            }
        };
    }
}
```

### 5.11. Timeout và Retry

#### 5.11.1. Cấu hình Timeout

```java
// Cấu hình timeout cho mỗi lần gọi
Author response = bookAuthorServiceStub
        .withDeadlineAfter(5, TimeUnit.SECONDS)
        .getAuthor(request);
```

#### 5.11.2. Cấu hình Retry

```java
// Cấu hình retry policy
ExponentialBackoffPolicy backoffPolicy = ExponentialBackoffPolicy.builder()
        .setInitialBackoffMillis(100)
        .setMaxBackoffMillis(5000)
        .setMultiplier(2)
        .build();

Author response = bookAuthorServiceStub
        .withOption(CallOptions.Key.of("retryPolicy", backoffPolicy))
        .getAuthor(request);
```

### 5.12. Bảo mật trong gRPC Client

#### 5.12.1. Cấu hình TLS/SSL

```yaml
# application.yml
grpc:
  client:
    book-author-service:
      address: static://localhost:9090
      negotiation-type: TLS
      security:
        trust-cert-collection: classpath:certificates/trusted-servers.pem
```

#### 5.12.2. Thêm Authentication với Interceptor

```java
@Component
public class AuthClientInterceptor implements ClientInterceptor {

    private static final Metadata.Key<String> AUTH_TOKEN_KEY =
            Metadata.Key.of("Authorization", Metadata.ASCII_STRING_MARSHALLER);

    private final String jwtToken;

    @Autowired
    public AuthClientInterceptor(@Value("${jwt.token}") String jwtToken) {
        this.jwtToken = jwtToken;
    }

    @Override
    public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall(
            MethodDescriptor<ReqT, RespT> method,
            CallOptions callOptions,
            Channel next) {
        
        return new ForwardingClientCall.SimpleForwardingClientCall<>(
                next.newCall(method, callOptions)) {
            
            @Override
            public void start(Listener<RespT> responseListener, Metadata headers) {
                // Thêm token vào metadata
                headers.put(AUTH_TOKEN_KEY, "Bearer " + jwtToken);
                super.start(responseListener, headers);
            }
        };
    }
}
```

```java
@Configuration
public class GrpcClientConfig {

    @Autowired
    private AuthClientInterceptor authInterceptor;

    @Bean
    public GlobalClientInterceptorConfigurer globalInterceptorConfigurerAdapter() {
        return registry -> registry.addClientInterceptors(authInterceptor);
    }
}
```

### 5.13. Testing gRPC Client

#### 5.13.1. Tạo Mock cho gRPC Client

```java
@ExtendWith(SpringExtension.class)
@SpringBootTest
public class BookAuthorClientServiceTest {

    @MockBean
    private BookAuthorServiceGrpc.BookAuthorServiceBlockingStub blockingStub;
    
    @Autowired
    private BookAuthorClientService clientService;

    @Test
    public void testGetAuthor() {
        // Tạo mock response
        Author mockResponse = Author.newBuilder()
                .setAuthorId(123)
                .setFirstName("Nguyễn")
                .setLastName("Văn A")
                .build();
        
        // Cấu hình mock
        when(blockingStub.getAuthor(any(Author.class))).thenReturn(mockResponse);
        
        // Gọi service
        Author result = clientService.getAuthor(123);
        
        // Kiểm tra kết quả
        assertNotNull(result);
        assertEquals(123, result.getAuthorId());
        assertEquals("Nguyễn", result.getFirstName());
    }
    
    @Test
    public void testGetAuthorNotFound() {
        // Cấu hình mock để ném exception
        Status status = Status.NOT_FOUND.withDescription("Author not found");
        StatusRuntimeException exception = status.asRuntimeException();
        when(blockingStub.getAuthor(any(Author.class))).thenThrow(exception);
        
        // Gọi service và kiểm tra exception
        Exception thrown = assertThrows(
                ResourceNotFoundException.class,
                () -> clientService.getAuthor(999)
        );
        
        assertTrue(thrown.getMessage().contains("Author not found"));
    }
}
```

#### 5.13.2. Tạo Integration Test với gRPC Server thật

```java
@SpringBootTest
@TestPropertySource(properties = {
    "grpc.client.book-author-service.address=static://localhost:9090",
    "grpc.client.book-author-service.negotiation-type=plaintext"
})
public class BookAuthorClientServiceIntegrationTest {

    @Autowired
    private BookAuthorClientService clientService;
    
    @Test
    public void testGetAuthor() {
        Author author = clientService.getAuthor(123);
        
        assertNotNull(author);
        assertEquals(123, author.getAuthorId());
        assertEquals("Nguyễn", author.getFirstName());
    }
}
```

## 6. So sánh các phương thức gRPC

| Kiểu RPC | Mô tả | Use cases |
|----------|-------|-----------|
| Unary | Client gửi một request và nhận về một response | Hầu hết các API thông thường, như get/update/delete |
| Server Streaming | Client gửi một request và nhận về nhiều response | Lấy dữ liệu lớn, real-time updates, streaming data |
| Client Streaming | Client gửi nhiều request và nhận về một response | Tải lên dữ liệu lớn, real-time data collection |
| Bidirectional Streaming | Client và server gửi và nhận nhiều message | Chat applications, real-time collaboration, monitoring |

### 6.1. Ví dụ Unary RPC

**Schema.proto**:
```proto
rpc GetAuthor(AuthorRequest) returns (Author) {}
```

**Server implementation**:
```java
@Override
public void getAuthor(AuthorRequest request, StreamObserver<Author> responseObserver) {
    Author author = // ... logic to get author
    responseObserver.onNext(author);
    responseObserver.onCompleted();
}
```

**Client implementation**:
```java
AuthorRequest request = AuthorRequest.newBuilder().setAuthorId(123).build();
Author response = stub.getAuthor(request);
```

### 6.2. Ví dụ Server Streaming RPC

**Schema.proto**:
```proto
rpc ListAuthors(BookRequest) returns (stream Author) {}
```

**Server implementation**:
```java
@Override
public void listAuthors(BookRequest request, StreamObserver<Author> responseObserver) {
    // Gửi nhiều authors
    for (Author author : getAuthorsForBook(request.getBookId())) {
        responseObserver.onNext(author);
    }
    responseObserver.onCompleted();
}
```

**Client implementation**:
```java
BookRequest request = BookRequest.newBuilder().setBookId(456).build();
stub.listAuthors(request).forEachRemaining(author -> {
    System.out.println("Received: " + author.getFirstName() + " " + author.getLastName());
});
```

### 6.3. Ví dụ Client Streaming RPC

**Schema.proto**:
```proto
rpc CreateAuthors(stream Author) returns (CreateAuthorsResponse) {}
```

**Server implementation**:
```java
@Override
public StreamObserver<Author> createAuthors(StreamObserver<CreateAuthorsResponse> responseObserver) {
    return new StreamObserver<Author>() {
        private List<Author> authors = new ArrayList<>();
        
        @Override
        public void onNext(Author author) {
            authors.add(author);
        }
        
        @Override
        public void onError(Throwable t) {
            // Xử lý lỗi
        }
        
        @Override
        public void onCompleted() {
            // Lưu tất cả authors đã nhận được và trả về response
            CreateAuthorsResponse response = CreateAuthorsResponse.newBuilder()
                    .setCount(authors.size())
                    .build();
                    
            responseObserver.onNext(response);
            responseObserver.onCompleted();
        }
    };
}
```

**Client implementation**:
```java
StreamObserver<CreateAuthorsResponse> responseObserver = new StreamObserver<CreateAuthorsResponse>() {
    @Override
    public void onNext(CreateAuthorsResponse response) {
        System.out.println("Created " + response.getCount() + " authors");
    }
    
    @Override
    public void onError(Throwable t) {
        System.err.println("Error: " + t.getMessage());
    }
    
    @Override
    public void onCompleted() {
        System.out.println("Completed");
    }
};

StreamObserver<Author> requestObserver = asyncStub.createAuthors(responseObserver);

// Gửi nhiều authors
for (Author author : authorsList) {
    requestObserver.onNext(author);
}

requestObserver.onCompleted();
```

### 6.4. Ví dụ Bidirectional Streaming RPC

**Schema.proto**:
```proto
rpc ProcessAuthors(stream Author) returns (stream AuthorProcessingResult) {}
```

**Server implementation**:
```java
@Override
public StreamObserver<Author> processAuthors(StreamObserver<AuthorProcessingResult> responseObserver) {
    return new StreamObserver<Author>() {
        @Override
        public void onNext(Author author) {
            // Xử lý mỗi author và trả về kết quả ngay lập tức
            AuthorProcessingResult result = processAuthor(author);
            responseObserver.onNext(result);
        }
        
        @Override
        public void onError(Throwable t) {
            // Xử lý lỗi
        }
        
        @Override
        public void onCompleted() {
            // Khi client hoàn thành việc gửi dữ liệu
            responseObserver.onCompleted();
        }
    };
}
```

**Client implementation**:
```java
StreamObserver<AuthorProcessingResult> responseObserver = new StreamObserver<AuthorProcessingResult>() {
    @Override
    public void onNext(AuthorProcessingResult result) {
        System.out.println("Received result for author: " + result.getAuthorId());
    }
    
    @Override
    public void onError(Throwable t) {
        System.err.println("Error: " + t.getMessage());
    }
    
    @Override
    public void onCompleted() {
        System.out.println("Server completed sending results");
    }
};

StreamObserver<Author> requestObserver = asyncStub.processAuthors(responseObserver);

// Gửi nhiều authors và nhận kết quả cho mỗi author
for (Author author : authorsList) {
    requestObserver.onNext(author);
    Thread.sleep(500); // Đợi một chút để xem kết quả
}

requestObserver.onCompleted();
```

## 7. Best Practices và Optimization

### 7.1. Hiệu suất

1. **Reuse gRPC channels**: Channel tạo ra nhiều kết nối TCP persistent, nên tái sử dụng chúng.
   ```java
   // Đúng - tạo một channel và sử dụng lại
   ManagedChannel channel = ManagedChannelBuilder.forAddress(host, port).build();
   Stub stub1 = ServiceGrpc.newStub(channel);
   Stub stub2 = ServiceGrpc.newStub(channel);
   ```

2. **Batching requests**: Gom nhóm các request nhỏ thành một request lớn.
   ```java
   // Thay vì gọi N lần với 1 item
   for (Item item : items) {
       saveItem(item);
   }
   
   // Gọi 1 lần với N items
   saveItems(items);
   ```

3. **Sử dụng streaming thay vì unary** cho dữ liệu lớn.

4. **Compression**: Bật compression để giảm kích thước dữ liệu.
   ```java
   ManagedChannel channel = ManagedChannelBuilder.forAddress(host, port)
           .enableFullStreamDecompression()
           .build();
   ```

### 7.2. Reliability

1. **Timeout**: Luôn đặt timeout cho mọi RPC call.
   ```java
   stub.withDeadlineAfter(5, TimeUnit.SECONDS).myMethod(request);
   ```

2. **Retry**: Cấu hình retry cho các lỗi tạm thời.

3. **Circuit Breaking**: Ngăn chặn gọi đến các service không khả dụng.
   ```java
   // Sử dụng thư viện resilience4j
   CircuitBreaker circuitBreaker = CircuitBreaker.ofDefaults("backendService");
   Supplier<Response> decoratedSupplier = CircuitBreaker
           .decorateSupplier(circuitBreaker, () -> stub.myMethod(request));
   ```

### 7.3. Security

1. **TLS/SSL**: Luôn bật TLS/SSL trong môi trường production.

2. **Authentication**: Sử dụng interceptor để thêm token vào mọi request.

3. **Authorization**: Kiểm tra quyền truy cập ở server.

### 7.4. Monitoring

1. **Logging**: Log tất cả các gRPC calls và errors.

2. **Metrics**: Thu thập metrics như số lượng calls, latency, error rates.

3. **Tracing**: Sử dụng distributed tracing để theo dõi request qua nhiều services.
   ```java
   // Sử dụng OpenTelemetry
   Tracer tracer = openTelemetry.getTracer("my-service");
   Span span = tracer.spanBuilder("grpc-call").startSpan();
   try (Scope scope = span.makeCurrent()) {
       // Gọi gRPC
       stub.myMethod(request);
   } finally {
       span.end();
   }
   ```

### 7.5. Versioning

1. **Package versioning**: Thêm phiên bản vào tên package.
   ```proto
   package com.didan.v1;
   ```

2. **Field evolution**: Thêm trường mới với reserved field numbers.

3. **Backward compatibility**: Luôn bảo đảm backward compatibility khi thay đổi API.

## 8. Tích hợp gRPC trong Microservices

### 8.1. Service Discovery

```yaml
# application.yml
spring:
  cloud:
    consul:
      host: localhost
      port: 8500
      discovery:
        enabled: true

grpc:
  client:
    book-author-service:
      address: discovery:consul/book-author-service
      negotiation-type: plaintext
```

### 8.2. Load Balancing

```yaml
# application.yml
grpc:
  client:
    book-author-service:
      address: discovery:consul/book-author-service
      negotiation-type: plaintext
      load-balancing-policy: round_robin
```

### 8.3. API Gateway

```java
@Controller
public class GrpcGatewayController {

    @Autowired
    private BookAuthorClientService bookAuthorClientService;

    @GetMapping("/api/authors/{id}")
    public ResponseEntity<Map<String, Object>> getAuthor(@PathVariable int id) {
        Author author = bookAuthorClientService.getAuthor(id);
        
        // Convert Author protobuf message to JSON
        Map<String, Object> response = new HashMap<>();
        response.put("authorId", author.getAuthorId());
        response.put("firstName", author.getFirstName());
        response.put("lastName", author.getLastName());
        response.put("gender", author.getGender());
        
        return ResponseEntity.ok(response);
    }
}
```


## 9. Cấu hình GRPC Client và GRPC Server nâng cao
Không cần sử dụng đến `net.devh` chúng ta có thể tự cấu hình kêt nôi grpc như thư mục config của source code grpc.grpc-custom-connect.
## 10. Kết luận

gRPC là một công nghệ hiện đại và mạnh mẽ cho phép triển khai các API hiệu suất cao trong môi trường phân tán. Với sự hỗ trợ mạnh mẽ từ Spring Boot, việc tích hợp gRPC vào các ứng dụng Java trở nên dễ dàng và hiệu quả.

Ưu điểm của việc sử dụng gRPC trong Spring Boot:
- Hiệu suất cao với HTTP/2 và Protocol Buffers
- Định nghĩa API rõ ràng với contract-first approach
- Hỗ trợ streaming hai chiều
- Tích hợp dễ dàng với Spring Boot ecosystem

Một số thách thức:
- Đường cong học tập dốc hơn so với REST
- Khả năng interoperability với web browsers hạn chế
- Tooling chưa phổ biến như REST

Tuy nhiên, với những ưu điểm vượt trội, gRPC là một lựa chọn tuyệt vời cho giao tiếp giữa các services trong các hệ thống microservices hiện đại.
