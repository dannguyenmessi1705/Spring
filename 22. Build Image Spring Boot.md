# Build Image Spring Boot App.
## 1. Giới thiệu
Sau khi chúng ta đã viết xong ứng dụng `Spring Boot`, chúng ta cần `build` ứng dụng thành một file thực thi `(jar)` để chạy trên môi trường khác nhau.

Đặc biệt với `Microservice`, chúng ta cần `build` ứng dụng thành một `image` để chạy trên `Docker`.

Có 3 cách chính để `build` ứng dụng `Spring Boot`:
    - Sử dụng `Dockfile` để `build` ứng dụng thành `image`.
    - Sử dụng `Buildpacks` để `build` ứng dụng thành `image` (Maven và Gradle) Mặc định từ `Spring Boot 2.3`.
    - Sử dụng `Google Jib` để `build` ứng dụng thành `image`.

## 2. Build Image Spring Boot App
### 2.1. Sử dụng Dockerfile
Đầu tiên, chúng ta `build` ứng dụng `Spring Boot` thành một file `jar` bằng lệnh `mvn clean install`. File `jar` sẽ được lưu trong thư mục `target`.

Sau đó, chúng ta cần tạo một file `Dockerfile` trong thư mục gốc của ứng dụng `Spring Boot`.

```Dockerfile
# Dockerfile
FROM openjdk:21-jdk-slim

COPY target/demo-0.0.1-SNAPSHOT.jar app.jar

ENTRYPOINT ["java","-jar","/app.jar"]
```

Trong đưong dẫn `project` chạy lệnh sau để `build` ứng dụng thành `image`.

```shell
docker build -t demo-spring-boot .
```

Chạy lệnh sau để chạy `image`.

```shell
docker run -p 8080:8080 demo-spring-boot
```

Chúng ta có thể tạo `Dockfile` làm cả 2 việc `build` ứng dụng thành `jar` và `image`...

### 2.2. Sử dụng Buildpacks
Từ `Spring Boot 2.3`, chúng ta có thể sử dụng `Buildpacks` để `build` ứng dụng thành `image` với `Maven` và `Gradle`.

Chúng ta cần thêm các thành phần sau vào file `pom.xml`.

> Thêm tag `<packaging>jar</packaging>` để `build` thành file `jar`.
```xml
<packaging>jar</packaging> <!-- Để build thành file jar -->
```
> Thêm tag `image và name` vào `spring-boot-maven-plugin` để đặt tên cho `image`.
```xml
<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
				<configuration>
					<image>
						<name>dannguyenmessi/${project.artifactId}-bank:v1</name>
					</image>
                </configuration>
            </plugin>
        </plugins>
</build>
```

Sau đó, chúng ta chạy lệnh sau để `build` ứng dụng thành `image`.

```shell
mvn spring-boot:build-image
# hoặc với máy chưa có mvn, sử dụng ./mvnw có sẵn trong project
./mvnw spring-boot:build-image
```
Sau khi chạy lệnh trên, chúng ta sẽ thấy `image` được tạo trong `Docker`. Image này sẽ tối ưu hóa và nhỏ gọn hơn so với `Dockerfile`.

### 2.3. Sử dụng Google Jib
`Google Jib` là một công cụ giúp chúng ta `build` ứng dụng `Spring Boot` nhanh chóng và dễ dàng thành `image`.

Chúng ta cần thêm các thành phần sau vào file `pom.xml`.

> Thêm tag `<packaging>jar</packaging>` để `build` thành file `jar`.
```xml
<packaging>jar</packaging> <!-- Để build thành file jar -->
```

> Thêm `plugin` vào file `pom.xml` ở phần `build` để sử dụng `Google Jib`.
```xml
<buid>
        <plugins>
            <plugin>
                <groupId>com.google.cloud.tools</groupId> <!-- GroupId của Jib -->
                <artifactId>jib-maven-plugin</artifactId> <!-- Plugin Jib -->
                <version>3.4.3</version> <!-- Phiên bản Jib -->
                <configuration>
                    <to>
                        <image>myimage</image> <!-- Đặt tên cho image -->
                    </to>
                </configuration>
            </plugin>
        </plugins>
</build>
```

Sau đó, chúng ta chạy lệnh sau để `build` ứng dụng thành `image`.

```shell
mvn compile jib:dockerBuild
# hoặc với máy chưa có mvn, sử dụng ./mvnw có sẵn trong project
./mvnw compile jib:dockerBuild
```

Sau khi chạy lệnh trên, chúng ta sẽ thấy `image` được tạo trong `Docker`. Image này sẽ tối ưu hóa và nhỏ gọn hơn so với `Dockerfile`. Sử dụng `Google Jib` giúp chúng ta có thể `build` image mà không cần cài đặt `Docker`. Hướng dẫn chi tiết về `Google Jib` với link sau: [Google Jib](https://github.com/GoogleContainerTools/jib)

## 3. So sánh 3 cách `build` ứng dụng `Spring Boot` thành `image`
- `Dockerfile`: 
    + Cách này không phù hợp với người mới bắt đầu với `Docker` vì cần phải viết `Dockerfile` và chạy nhiều lệnh, tối ưu hóa `image` không cao.
    + Cách này phù hợp với người muốn tùy chỉnh `image` theo ý muốn.
    
- `Buildpacks`: 
    + Cách này phù hợp với người mới bắt đầu với `Docker` vì không cần viết `Dockerfile` và chạy nhiều lệnh.
    + Ngoài ra, `Buildpacks` còn hỗ trợ tối ưu hóa `image` khi `build`.
    + Hỗ trợ `Cache` giúp tăng tốc độ `build` ứng dụng.
    + Hỗ trợ nhiều ngôn ngữ lập trình khác nhau.
    + Tuy nhiên, cách này không phù hợp với người muốn tùy chỉnh `image` theo ý muốn vì nó bắt buộc phải tuân thủ theo quy tắc của `Buildpacks`.

- `Google Jib`: 
    + Cách này phù hợp với người mới bắt đầu với `Docker` vì không cần cài đặt `Docker`, không cần viết `Dockerfile` và chạy nhiều lệnh.
    + Ngoài ra, `Google Jib` còn hỗ trợ tối ưu hóa `image` khi `build`.
    + Tuy nhiên, cách này không phù hợp với người muốn tùy chỉnh `image` theo ý muốn vì nó bắt buộc phải tuân thủ theo quy tắc của `Google Jib`.

## 4. Chạy nhiều `services` với Docker Compose
Với việc sử dụng `Google Jib` hoặc `Buildpacks` chúng ta không thể có file `Dockerfile` để build offline với `Docke Compose`. Vì thế cần phải `push` image lên `Docker Hub` hoặc `Registry` khác hoặc phải build image trước khi chạy `Docker Compose`.

> Lệnh `push` image lên `Docker Hub` (Lưu ý tên image phải đúng chuẩn `Docker Hub`: `{account}/{image}:{tag}`).
```shell
docker push {account}/{image}:{tag}
```
> Khi tạo các `services` trong file `docker-compose.yml`, chúng ta cần cho các `services` sử dụng chung một `network` để có thể giao tiếp với nhau.
```yml
services:
  service1:
    image: {account}/{image}:{tag}
    ports:
      - "8080:8080"
    networks:
      - my-network
  service2:
    image: {account}/{image}:{tag}
    ports:
      - "8081:8081"
    networks:
      - my-network
networks:
    my-network:
        driver: bridge
```
> Chạy lệnh sau để chạy `Docker Compose`.
```shell
docker-compose up -d
```
> Lưu ý: Khi chạy `Docker Compose` cần phải chạy lệnh `docker login` để đăng nhập vào `Docker Hub` hoặc `Registry` khác để `pull` image về máy.