# Sử dụng Unit Test và Mockito trong Spring Boot
## 1. Giới thiệu    
`Unit Test` là một loại kiểm thử phần mềm mà ở đó các đơn vị hoặc thành phần của phần mềm được kiểm tra một cách riêng lẻ. Mục tiêu của `Unit Test` là kiểm tra xem mỗi đơn vị hoặc thành phần của phần mềm hoạt động đúng như mong đợi hay không. `Unit Test` giúp đảm bảo rằng mã nguồn của bạn hoạt động đúng và không bị lỗi.

`Mockito` là một thư viện giúp chúng ta tạo ra các đối tượng giả mạo (mock object) để kiểm tra các phương thức của đối tượng đó. `Mockito` giúp chúng ta kiểm tra xem một phương thức được gọi hay không, số lần gọi, tham số truyền vào, giá trị trả về,...

## 2. Sử dụng Unit Test
Trong `Spring Boot`, chúng ta có thể sử dụng `JUnit` để viết các `Unit Test`.

`JUnit` là một framework giúp chúng ta viết các `Unit Test` một cách dễ dàng. `JUnit` giúp chúng ta kiểm tra xem một phương thức hoạt động đúng như mong đợi hay không. 

Ví dụ ta có 1 phươn thức `add` trong class `Calculator`. Junits giúp chúng ta kiểm tra xem phương thức `add` có hoạt động đúng như mong đợi hay không.

Chúng ta sử dụng `JUnit Jupiter`, phiên bản `JUnit 5` để viết các `Unit Test`.

> Lưu ý: Cần phải tạo `Source Folder` mới để chứa các `Unit Test`, không nên viết `Unit Test` trong `Source Folder` chứa mã nguồn.
> Lưu ý: `File test` cần được đặt trong `cùng package` với `file cần test`.
> Lưu ý: `Unit Test` không nên phụ thuộc vào nhau, mỗi `Unit Test` nên kiểm tra một phần nhỏ của mã nguồn.

Các Annotation sử dụng trong `JUnit 5`:
- `@Test` được sử dụng để đánh dấu một phương thức là một `Unit Test`.
- `@BeforeAll` được sử dụng để đánh dấu một phương thức sẽ chạy trước tất cả các `Unit Test`. Phương thức này phải là `static`.
- `@BeforeEach` được sử dụng để đánh dấu một phương thức sẽ chạy trước mỗi `Unit Test` trong class Test.
- `@AfterEach` được sử dụng để đánh dấu một phương thức sẽ chạy sau mỗi `Unit Test` trong class Test.
- `@AfterAll` được sử dụng để đánh dấu một phương thức sẽ chạy sau tất cả các `Unit Test`. Phương thức này phải là `static`.
- `@DisplayName` được sử dụng để đặt tên cho `Unit Test`. VD `@DisplayName("Test add method")`.
- `@Disabled` được sử dụng để tạm thời vô hiệu hóa một `Unit Test`. VD `@Disabled("Not yet implemented")`.
- `@Nested` được sử dụng để nhóm các `Unit Test` lại với nhau. VD `@Nested`.
- `@Tag` được sử dụng để gắn tag cho `Unit Test`. VD `@Tag("add")`.
- `@Timeout` được sử dụng để đặt thời gian chạy cho một `Unit Test`. VD `@Timeout(1000)`.

Các phương thức hay sử dụng trong `JUnit 5`:
- `assertEquals`: So sánh giá trị mong đợi với giá trị thực tế. Nếu giá trị mong đợi khác với giá trị thực tế, `Unit Test` sẽ báo lỗi. VD `assertEquals(5, calculator.add(2, 3));`. Nó có thể truyền thêm một tham số `message` để hiển thị thông báo lỗi. VD `assertEquals(5, calculator.add(2, 3), "Error: 2 + 3 != 5");`
- `assertTrue`: Kiểm tra xem một điều kiện có đúng hay không. Nếu điều kiện đúng, `Unit Test` sẽ chạy thành công. VD `assertTrue(calculator.add(2, 3) == 5);`
- `assertFalse`: Kiểm tra xem một điều kiện có sai hay không. Nếu điều kiện sai, `Unit Test` sẽ chạy thành công. VD `assertFalse(calculator.add(2, 3) == 6);`
- `assertThrows`: Kiểm tra xem một ngoại lệ có được ném ra hay không. VD `assertThrows(ArithmeticException.class, () -> calculator.divide(1, 0));`
- `assertTimeout`: Kiểm tra xem một phương thức có chạy quá thời gian cho phép hay không. VD `assertTimeout(Duration.ofMillis(100), () -> calculator.add(2, 3));`
- `assertArrayEquals`: So sánh hai mảng. VD `assertArrayEquals(new int[] {1, 2, 3}, new int[] {1, 2, 3});`
- `assertIterableEquals`: So sánh hai danh sách. VD `assertIterableEquals(Arrays.asList(1, 2, 3), Arrays.asList(1, 2, 3));`
- `assertLinesMatch`: So sánh hai danh sách chuỗi. VD `assertLinesMatch(Arrays.asList("a", "b", "c"), Arrays.asList("a", "b", "c"));`
- `assertAll`: Kiểm tra nhiều điều kiện cùng một lúc. VD `assertAll(() -> assertEquals(1, 1), () -> assertEquals(2, 2));`
- `fail`: Phương thức này sẽ báo lỗi ngay lập tức. VD `fail("Not yet implemented");`
> Nếu trong `Unit Test` có phương thức `fail`, `Unit Test` sẽ báo lỗi. Mặc định nếu không có phương thức `fail`, `Unit Test` sẽ chạy thành công.

>Calculator.java
```java
package com.example.demo;

public class Calculator {
    public int add(Integer... numbers) { // Tham số đầu vào là một các dãy số nguyên phân cách bởi dấu phẩy
		int sum = 0;
		for (int i : numbers) {
			sum += i;
		}
		return sum; // Trả về tổng của các số
	}
}
```
>CalculatorTest.java
```java
package com.example.demo;

import static org.junit.jupiter.api.Assertions.*; // Import các phương thức kiểm tra của JUnit 5

import org.junit.jupiter.api.Test; // Import annotation @Test

class CalculateTest {

	@BeforeAll // Đánh dấu phương thức setUpAll() là một phương thức thiết lập trước tất cả test case
	static void setUpAll() { // Bắt buộc phải là phương thức static
		System.out.println("Before All test case");
	}
	
	@BeforeEach // Đánh dấu phương thức setUp() là một phương thức thiết lập trước mỗi test case
	void setUp() throws Exception {
		System.out.println("Before Each test case");
	}

	@Test // Đánh dấu phương thức testAddCalculate1() là một test case
	void testAddCalculate1() {
		Calculate calculate = new Calculate();
		int actual = calculate.add(1, 2, 3, 4);
		int expected = 10;
		
		assertEquals(expected, actual); // Phuong thuc assertEquals() so sanh ket qua mong doi voi ket qua thuc te, nếu khác nhau thì hiển thị thông báo lỗi
		
//		fail("Not yet implemented"); // Phuong thuc fail() luôn fail test case và hiển thị thông báo lỗi
	}
	
	@Test // Đánh dấu phương thức testAddCalculate2() là một test case
	void testAddCalculate2() {
		Calculate calculate = new Calculate();
		int actual = calculate.add(7, 8, 9, 10);
		int expected = 34;
		
		assertEquals(expected, actual); // Phuong thuc assertEquals() so sanh ket qua mong doi voi ket qua thuc te, nếu khác nhau thì hiển thị thông báo lỗi
		
//		fail("Not yet implemented"); // Phuong thuc fail() luôn fail test case và hiển thị thông báo lỗi
	}
	
	@AfterEach // Đánh dấu phương thức tearDown() là một phương thức thiết lập sau mỗi test case
	void tearDown() throws Exception {
		System.out.println("After Each test case");
	}

	@AfterAll // Đánh dấu phương thức tearDownAll() là một phương thức thiết lập sau tất cả test case
	static void tearDownAll() { // Bắt buộc phải là phương thức static
		System.out.println("After All test case");
	}

}
```

## 3. Sử dụng Mockito (Thực hiện Mocks trong Unit Test)
Thông thường trong kiến trúc `Web` chúng ta sẽ sử dụng `Service` để xử lý logic và `Repository` để xử lý dữ liệu (truy cập vào database). Khi viết `Unit Test` cho `Service`, chúng ta không muốn phụ thuộc vào `Repository` vì `Repository` có thể gây ra lỗi hoặc không thể truy cập được. Để giải quyết vấn đề này, chúng ta sử dụng `Mockito` để tạo ra các đối tượng giả mạo (mock object) để kiểm tra các phương thức của đối tượng đó.

### 3.1. Cài đặt Mockito
Mặc định khi khởi tạo một project `Spring Boot`, `Spring Boot` đã tích hợp sẵn `Mockito` vào dependencies `spring-boot-starter-test`.

Thiết lập các class ở trong Source Folder `test/java` có sẵn trong `maven` khi tạo project `Spring Boot`.

Tương tự như `JUnit`, chúng ta cần các file `test` nằm trong `cùng package` với `file cần test`, nhưng phải khác `source folder`.

### 3.2. So sánh Stub và Mock
- `Stub`: Là một đối tượng giả mạo mà chúng ta cung cấp giá trị trả về cố định cho phương thức của đối tượng đó. `Stub` không kiểm tra xem phương thức được gọi hay không, số lần gọi, tham số truyền vào, giá trị trả về,...
- `Mock`: Là một đối tượng giả mạo mà chúng ta kiểm tra xem phương thức được gọi hay không, số lần gọi, tham số truyền vào, giá trị trả về,...
- Nên sử dụng `Mock` thay vì `Stub` vì `Stub` khá giống với việc viết mã cứng cố định, khó mở rộng và bảo trì.

### 3.3. Sử dụng `Stub` 
>Business.java (Source Folder `main/java`)
```java
package com.example.demo;
public class Business {
	private DataService dataService; // Inject DataService vào Business

	public Business(DataService dataService) {
		super();
		this.dataService = dataService;
	}

	public int findTheGreatestFromAllData() { // Phương thức tìm số lớn nhất trong mảng số nguyên
		int[] data = dataService.retrieveAllData(); 
		int greatest = Integer.MIN_VALUE;
		for (int value : data) {
			if (value > greatest) {
				greatest = value;
			}
		}
		return greatest;
	}
}

interface DataService {
	int[] retrieveAllData();
} // Interface DataService chứa phương thức retrieveAllData() trả về một mảng số nguyên
```

>StubBusiness.java (Source Folder `test/java`)
```java
package com.example.demo;

import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.api.Test;

public class StubBusiness {
	
	@Test
	public void testFinMax_1() { // Test với mảng số nguyên {10, 20, 30}
		StubDataService stubDataService = new StubDataService();
		Business business = new Business(stubDataService);
		int result = business.findMax();
		int expected = 30;
		assertEquals(expected, result);
	}
	
	@Test
	public void testFinMax_2() { // Test với mảng số nguyên {20}
		StubDataService1 stubDataService = new StubDataService1();
		Business business = new Business(stubDataService);
		int result = business.findMax();
		int expected = 20;
		assertEquals(expected, result);
	}
	
}

class StubDataService implements DataService { // Mã cứng cố định trả về mảng số nguyên {10, 20, 30}
	@Override 
	public int[] getAllDatas() {
		return new int[] {10, 20, 30};
	}
}

class StubDataService1 implements DataService { // Mã cứng cố định trả về mảng số nguyên {20}
	@Override
	public int[] getAllDatas() {
		return new int[] { 20 };
	}
}
```
Chúng ta có thể thấy dùng `Stub` khá giống với việc viết mã cứng cố định, khó mở rộng và bảo trì. Mỗi lần mã nguồn thay đổi, chúng ta phải sửa lại mã cứng trong `Stub`. Và mỗi lần muốn test một mảng số nguyên khác, chúng ta phải tạo một class `Stub` mới.

### 3.4. Sử dụng `Mock`
Các phương thức hay sử dụng trong `Mockito`:
- `when`: Được sử dụng để thiết lập giá trị trả về cho phương thức của đối tượng giả mạo. VD:
	+ `when(dataService.retrieveAllData()).thenReturn(new int[] {10, 20, 30});` // Thiết lập giá trị trả về cho phương thức retrieveAllData() trả về mảng số nguyên {10, 20, 30}. Có thể thiết lập nhiều giá trị trả về cho phương thức retrieveAllData() bằng cách sử dụng `thenReturn` nhiều lần. Lúc này `assertEquals` sẽ kiểm tra giá trị bất kỳ nào trong các giá trị trả về đó.
	+ `when(dataService.retrieveAllData()).thenThrow(new RuntimeException("Exception"));` // Thiết lập ngoại lệ cho phương thức retrieveAllData().
- `verify`: Được sử dụng để kiểm tra xem phương thức của đối tượng giả mạo có được gọi hay không, số lần gọi, tham số truyền vào, giá trị trả về,... VD:
	+ `verify(dataService).retrieveAllData();` // Kiểm tra xem phương thức retrieveAllData() có được gọi hay không.
	+ `verify(dataService, times(1)).retrieveAllData();` // Kiểm tra xem phương thức retrieveAllData() có được gọi 1 lần hay không.
	+ `verify(dataService, never()).retrieveAllData();` // Kiểm tra xem phương thức retrieveAllData() không được gọi.
	+ `verify(dataService, atLeast(1)).retrieveAllData();` // Kiểm tra xem phương thức retrieveAllData() được gọi ít nhất 1 lần.
	+ `verify(dataService, atMost(1)).retrieveAllData();` // Kiểm tra xem phương thức retrieveAllData() được gọi nhiều nhất 1 lần.
- `any`: Được sử dụng để thiết lập giá trị trả về cho phương thức của đối tượng giả mạo với tham số truyền vào là bất kỳ giá trị nào. VD:
	+ `when(dataService.retrieveAllData(any())).thenReturn(new int[] {10, 20, 30});` // Thiết lập giá trị trả về cho phương thức retrieveAllData() trả về mảng số nguyên {10, 20, 30} với bất kỳ tham số truyền vào nào.
- `ArgumentMatchers`: Được sử dụng để kiểm tra xem tham số truyền vào của phương thức của đối tượng giả mạo có đúng hay không. VD:
	+ `when(dataService.retrieveAllData(ArgumentMatchers.anyInt())).thenReturn(new int[] {10, 20, 30});` // Thiết lập giá trị trả về cho phương thức retrieveAllData() trả về mảng số nguyên {10, 20, 30} với tham số truyền vào là bất kỳ số nguyên nào.
- `@Mock`: Được sử dụng để tạo ra một đối tượng giả mạo. VD:
	+ `@Mock private DataService dataService;` // Tạo ra một đối tượng giả mạo dataService.
- `@InjectMocks`: Được sử dụng để inject các đối tượng giả mạo vào đối tượng cần test. VD:
	+ `@InjectMocks private Business business;` // Inject đối tượng giả mạo dataService vào đối tượng cần test business.
- `Mockito.any...()`: Được sử dụng để kiểm tra xem tham số truyền vào của phương thức của đối tượng giả mạo có đúng hay không. VD:
	+ `when(dataService.retrieveAllData(Mockito.anyInt())).thenReturn(new int[] {10, 20, 30});` // Thiết lập giá trị trả về cho phương thức retrieveAllData() trả về mảng số nguyên {10, 20, 30} với tham số truyền vào là bất kỳ số nguyên nào.
- `Mockito.eq()`: Được sử dụng để kiểm tra xem tham số truyền vào của phương thức của đối tượng giả mạo có đúng hay không. VD:
	+ `when(dataService.retrieveAllData(Mockito.eq(1))).thenReturn(new int[] {10, 20, 30});` // Thiết lập giá trị trả về cho phương thức retrieveAllData() trả về mảng số nguyên {10, 20, 30} với tham số truyền vào là số nguyên 1.

> Lưu ý: Trước khi `dataService` được sử dụng, chúng ta cần phải khởi tạo `Mockito` bằng cách sử dụng `mock`. Ví dụ:
```java
DataServie dataService = mock(DataService.class); // Khởi tạo đối tượng giả mạo dataService từ DataService. Bất kỳ class, interface nào cũng có thể được tạo ra một đối tượng giả mạo.
```

>Business.java (Source Folder `main/java`) không thay đổi.

>MockBusiness.java (Source Folder `test/java`)
```java
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import org.junit.jupiter.api.Test;

class MockBusiness {

	@Test
	void testFindMax_1() {
		DataService mockDataService = mock(DataService.class); // Khởi tạo một đối tượng giả mạo mockDataService từ DataService.
		when(mockDataService.getAllDatas()).thenReturn(new int[] {10, 20, 30}); // Thiết lập giá trị trả về cho phương thức getAllDatas() trả về mảng số nguyên {10, 20, 30}.
		Business mockBusiness = new Business(mockDataService); // Khởi tạo đối tượng mockBusiness từ Business với đối tượng giả mạo mockDataService.
		int result = mockBusiness.findMax(); // Gọi phương thức findMax() của mockBusiness.
		int expected = 30; // Kết quả mong đợi là 30.
		assertEquals(expected, result); // So sánh kết quả mong đợi với kết quả thực tế.
	}
	
	@Test
	void testFindMax_2() {
		DataService mockDataService = mock(DataService.class); // Khởi tạo một đối tượng giả mạo mockDataService từ DataService.
		when(mockDataService.getAllDatas()).thenReturn(new int[] {20}); // Thiết lập giá trị trả về cho phương thức getAllDatas() trả về mảng số nguyên {20}.
		Business mockBusiness = new Business(mockDataService);
		int result = mockBusiness.findMax();
		int expected = 20;
		assertEquals(expected, result);
	}
}
```
Có thể thấy việc sử dụng `Mock` giúp chúng ta linh hoạt hơn, không cần phải tạo thêm class `Stub` mỗi khi muốn test một mảng số nguyên khác.

### 3.5. Sử dụng `Mock Annotation` thay cho `Mockito.mock()`
Chúng ta có thể sử dụng `Mockito` annotation `@Mock` để tạo ra một đối tượng giả mạo thay cho phương thức `Mockito.mock()`.

Sử dụng các annotation `@Mock`, `@InjectMocks` giúp chúng ta viết mã ngắn gọn hơn, dễ đọc hơn.
- `@Mock`: Được sử dụng để tạo ra một đối tượng giả mạo.
- `@InjectMocks`: Được sử dụng để inject các đối tượng giả mạo vào đối tượng cần test. Java sẽ tự động inject các đối tượng giả mạo vào đối tượng cần test.

Để sử dụng chúng ta phải thêm `MockitoExtension.class` vào `@ExtendWith` đặt trước class Test.

Ví dụ:
>MockAnnotationBusiness.java (Source Folder `test/java`)
```java
package com.example.demo;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.when;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class) // Sử dụng MockitoExtension.class để sử dụng @Mock, @InjectMocks
class MockAnnotationBusiness {

	@Mock // Tạo ra một đối tượng giả mạo mockDataService từ DataService.
	private DataService mockDataService;
	
	@InjectMocks // Inject các đối tượng giả mạo vào đối tượng cần test, Java sẽ tự động inject các đối tượng giả mạo vào đối tượng cần test. Như trong trường hợp này là Business mockBusiness = new Business(mockDataService);
	private Business mockBusiness;
	
	@Test
	void test() {
		when(mockDataService.getAllDatas()).thenReturn(new int[] {10, 20, 30});
		int result = mockBusiness.findMax();
		int expected = 30;
		assertEquals(expected, result);
	}
	
	@Test 
	void test_2() {
		when(mockDataService.getAllDatas()).thenReturn(new int[] {});
        int result = mockBusiness.findMax();
        int expected = Integer.MIN_VALUE;
        assertEquals(expected, result);
	}

}
```