# Giao tiếp giữa các Service trong Microservices
## 1. Giới thiệu
Trong mô hình `microservices`, các `service` thường được phân `chia` thành các `service nhỏ`, mỗi service đảm nhiệm một chức năng cụ thể. Để hoạt động hiệu quả, `các service` cần phải `giao tiếp với nhau`. Có nhiều cách để giao tiếp giữa các service trong microservices, trong bài viết này chúng ta sẽ tìm hiểu về các cách giao tiếp giữa các service trong microservices.

Thông thường, các services được bao bởi 1 lớp mạng để giao tiếp với nhau, gọi là `Microservices Network`. Các services giao tiếp với nhau thông qua `HTTP` hoặc `message broker`. (`Internal Communication`)

Các giao tiếp bên ngoài của `microservices` thường được thực hiện thông qua `API Gateway`. `API Gateway` là một lớp trung gian giữa client và các services, nó nhận request từ client và chuyển tiếp request đó đến các services phù hợp. Nó còn có chức năng `authentication`, `authorization`, `rate limiting`, `logging`, `monitoring`, `load balancing`, `caching`, `request shaping`, `response aggregation`, `request and response transformation`, `static response handling`,... (`External Communication`)

Trong phần này, chúng ta sẽ tìm hiểu cách mà 1 `service` có thể khám phá và giao tiếp với các `service` khác, và cách 1 `service` có thể đăng ký vào `Microservices Network`.

## 2. Service Discovery & Registration
Trong mô hình kiến trúc microservices, việc biết chính xác `địa chỉ mạng` của một ứng dụng là 1 vấn đề hết sức phức tạp cho `client` vì các `service instances` có thể được gán `địa chỉ IP động`. Hơn thế nữa `số lượng instances` của một `service` có thể thay đổi theo thời gian.

`Microservices Discovery và Registration` là 1 cách để cho các `app` và `microservices` có thể tìm được nhau trong mạng, giải quyết vấn đề về cách các `microservices` giao tiếp với nhau, tức là thực hiện các lệnh gọi API. điều này bao gồm:
- **Một máy chủ trung tâm (hoặc các máy chủ)** duy trì chế độ xem toàn bộ về các `địa chỉ` của các `service instances`.
- Các `Microservices/clients` kết nối với `máy chủ trung tâm` để `đăng ký địa chỉ của chúng` khi chúng ở trong trạng thái `bắt đầu hoặc sẵn sàng`.
- Các `Microservices/clients` cần gửi `nhịp tim` (trạng thái hoạt động) của họ đều đặn đến `máy chủ trung tâm` về sức khỏe của họ để `máy chủ trung tâm` có thể cập nhật thông tin về trạng thái của các `service instances`.
- Các `Microservices/clients` kết nối với máy chủ trung tâm để `hủy đăng ký` địa chỉ khi chúng chuẩn bị `dừng hoặc bị hủy bỏ`.

`Khám phá dịch vụ phía máy khách` và `khám phá dịch vụ phía máy` chủ là những cách tiếp cận riêng biệt nhằm giải quyết vấn đề khám phá dịch vụ trong các bối cảnh khác nhau:
- `Khám phá dịch vụ phía máy khách` là khi `máy khách` tự mình tìm kiếm và kết nối với các `service instances` mà nó cần giao tiếp (Sử dụng Ribbon, Feign, WebClient, ...).
- `Khám phá dịch vụ phía máy chủ` là khi `máy chủ` cung cấp thông tin về các `service instances` mà nó quản lý cho các `máy khách` cần giao tiếp (Sử dụng Kubernetes, Consul, Eureka, Zookeeper, ...).

## 3. Client-side Service Discovery (Khám phá dịch vụ phía máy khách) + Load Balancing
Trong khám phá dịch vụ phía máy khách, các `ứng dụng` có trách nhiệm `tự đăng ký với sổ đăng ký dịch` vụ trong khi `khởi động` và `hủy đăng ký khi tắt`. 

Khi một ứng dụng cần liên lạc với `một dịch vụ hỗ trợ`, nó sẽ `truy vấn sổ đăng ký dịch vụ` để biết `địa chỉ IP` được liên kết. `Nếu có nhiều phiên bản của dịch vụ`, `sổ đăng ký sẽ trả về danh sách địa chỉ IP`. Sau đó, `ứng dụng khách` sẽ `chọn một ứng dụng dựa trên chiến lược cân bằng tải` được xác định của riêng nó.

### 3.1. Sử dụng `Spring Cloud` để triển khai `Client-side Service Discovery`
Với sự hỗ trợ của `Spring Cloud`, việc triển khai `Client-side Service Discovery` trở nên dễ dàng hơn bao giờ hết. `Spring Cloud` cung cấp các thư viện và công cụ để giúp chúng ta triển khai các `microservices` một cách dễ dàng và hiệu quả. Bao gồm:
- `Spring Cloud Netflix Eureka` là một `service registry` cho các `microservices` được phát triển bởi `Netflix`. Nó cung cấp một `REST API` chịu trách nhiệm đăng ký và tìm kiếm các `service instances`. [Link](https://spring.io/projects/spring-cloud-netflix)
- `Spring Cloud Load Balancer` là một `client-side load balancer` được thiết kế để hoạt động với `service discovery` của `Spring Cloud`. Ổn định hơn so với `Ribbon Netflix` và `Spring Cloud Load Balancer` cung cấp một cách tiếp cận `Spring-native` cho việc cân bằng tải `client-side`.
- `Netflix Feign Client` là một thư viện `REST client` được phát triển bởi `Netflix` để giúp chúng ta giao tiếp với các `service instances` một cách dễ dàng. [Link](https://spring.io/projects/spring-cloud-openfeign)

> Ngoài `Eureka`, chúng ta còn có thể sử dụng các công cụ khác như `Consul`, `Apache Zookeeper`, `Kubernetes`, ... để triển khai `Client-side Service Discovery`.

### 3.2. Lợi ích của `Client-side Service Discovery`
- Không có giới hạn về tính khả dụng của `service registry`. Có thể có nhiều nút khám phá dịch vụ phía máy chủ.
- Giao tiếp ngang hàng giữa các `service discovery agents`.
- IPs, các cấu hình, cân bằng tải được `quản lý động`.
- Có khả năng chịu lỗi, chịu tải và phục hồi.

## 4. Sử dụng `Eureka` để triển khai `Client-side Service Discovery`.
### 4.1. Tạo 1 agent khám phá các dịch vụ (`Máy chủ Eureka`)
#### 4.1.1. Các `dependency` cần thiết
Cài đặt phiên bản `Spring Cloud` (Đối cới Spring Boot 3 thì sử dụng bản 2022 trở lên)
```xml
<properties>
    <spring-cloud.version>2023.0.2</spring-cloud.version>
</properties>
```
Dependence `Spring Config Client` để đọc cấu hình từ `Spring Config Server`
```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-config</artifactId>
</dependency>
```
Thêm `quản lý dependency của Spring Cloud`
```xml
<dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-dependencies</artifactId>
				<version>${spring-cloud.version}</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>
		</dependencies>
</dependencyManagement>
```
Đặc biệt, dependences `Spring Cloud Netflix Eureka` để triển khai `Client-side Service Discovery`. Lưu ý ta đang cần tạo 1 agent để khám phá các dịch vụ, nên sẽ cần `Euereka Server`
```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
</dependency>
```

#### 4.1.2. Cấu hình `Eureka Server`
Tạo `Eureka Server` bằng cách thêm `@EnableEurekaServer` vào `Spring Boot Application`
```java
@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class, args);
    }
}
```

Cấu hình `Eureka Server` trong `application.yml`. **Lưu ý**: cần thêm `spring.application.name` để định danh `Eureka Server` trong `Microservices Network`, cũng như `Spring Cloud Config Server` để đọc cấu hình từ `Spring Config Server`
```yml
spring:
  application:
    name: "eurekaserver"
  config:
    import: optional:configserver:http://localhost:8071
  profiles:
    active: "default"

## Bật actuators và health check
management:
  endpoints:
    web:
      exposure:
        include: "*"
  health:
    readiness-state:
      enabled: true
    liveness-state:
      enabled: true
  endpoint:
    health:
      probes:
        enabled: true

# Config ở Spring Cloud Config Server
server:
 port: 8070

eureka:
 instance:
   hostname: localhost # Nói cho Eureka Server xem xét địa chỉ IP hoặc tên máy chủ mà nó sẽ sử dụng để truy cập nó
 client:
   fetch-registry: false # Đặt giá trị này thành false nếu bạn không muốn Eureka Server truy cập vào chính nó, chỉ true với các ứng dụng khác
   register-with-eureka: false # Đặt giá trị này thành false nếu bạn không muốn đăng ký với chính mình, chỉ true với các ứng dụng khác
   service-url:
     defaultZone: http://${eureka.instance.hostname}:${server.port}/euraka/ # Địa chỉ URL mà các ứng dụng khác sẽ sử dụng để truy cập Eureka Server
```

> Sau khi chạy service này, truy cập vào `http://localhost:8070` để xem giao diện quản lý của `Eureka Server`. Đây là giao diện hiển thị thông số chi tiết tất cả các `service instances` đã đăng ký vào `Eureka Server`.

### 4.2. Cấu hình `Eureka Client` để đăng ký vào `Eureka Server`
#### 4.2.1. Các `dependency` cần thiết
Giống như `Eureka Server`, chỉ khác thay vì sử dụng `Eureka Server` thì sử dụng `Eureka Discovery Client`
```xml
<dependency>
  <groupId>org.springframework.cloud</groupId>
  <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```

#### 4.2.2. Cấu hình `Eureka Client` (Chỉ cấu hình ở các `Service` con, không cấu hình trên `Spring Cloud Config Server`)
Thêm cấu hình `Eureka Client` trong `application.yml`
```yml
eureka:
 instance:
  prefer-ip-address: true # Các service sẽ đăng ký với Eureka dùng IP thay vì dùng dns hoặc hostname
 client:
  fetch-registry: true # Service này sẽ fetch thông tin của các service khác từ Eureka server
  register-with-eureka: true # Service này sẽ đăng ký với Eureka server
  service-url:
    defaultZone: http://localhost:8070/eureka/ # URL của Eureka server

### Ngoài ra, chúng ta cần đăng ký và khai báo endpoint để cho phép Eureka Server kiểm tra sức khỏe của service cũng như để shutdown service 1 cách an toàn, tránh shutdown đột ngột như cách bấm nút tắt máy
management:
 endpoints:
  web:
   exposure:
    include: "*"
 endpoint:
   shutdown:
    enabled: true # Cho phép dùng endpoint /actuator/shutdown để tắt service mà không cần tắt container
 info:
   env:
    enabled: true # Cho phép dùng endpoint /actuator/info để xem thông tin về service

## Cấu hình Eureka client
eureka:
 instance:
  prefer-ip-address: true # Các service sẽ đăng ký với Eureka dùng IP thay vì dùng dns hoặc hostname
 client:
  fetch-registry: true # Service này sẽ fetch thông tin của các service khác từ Eureka server
  register-with-eureka: true # Service này sẽ đăng ký với Eureka server
  service-url:
    defaultZone: http://localhost:8070/eureka/ # URL của Eureka server

## Thông tin về service hiển thị trên Eureka dashboard
info:
  app:
   name: "accounts"
   description: "Bank account application"
   version: "1.0.0" 
```
Sau khi chạy `Spring Cloud Config Server`, `Eureka Server` và `Service` con, truy cập vào `http://localhost:8070` để xem giao diện quản lý của `Eureka Server`, nếu `Service` con đã đăng ký thành công, thì sẽ hiển thị thông tin state là `UP`

Khi bấm vào đường dẫn `Instances`, sẽ hiển thị thông tin chi tiết về `Service` con đã đăng ký vào `Eureka Server` (ipaddress:port/actuator/info)

Để `tắt` (gradually shutdown) `Service` con, thực hiện 1 `POST request` tới `http://ipaddress:port/actuator/shutdown` (Ví dụ: `http://localhost:8080/actuator/shutdown`) và `Service` con sẽ `tắt` mà không cần phải `tắt container` (shutdown immediately)

Khi các `microservices` đã đăng ký vào `Eureka Server`, mỗi 30s `Eureka Client` sẽ gửi `heartbeat` đến `Eureka Server` để thông báo rằng `service` vẫn còn hoạt động. Nếu `Eureka Server` không nhận được `heartbeat` trong 90s, nó sẽ xem `service` đó là `DOWN` và `service` đó sẽ không còn hiển thị trên `Eureka Dashboard`.

### 4.3. Sử dụng `Feign Client` để giao tiếp giữa các `microservices` (Client-side Load Balancing)
Khi các `microservices` đã đăng ký vào `Eureka Server`, chúng ta có thể sử dụng `Feign Client` để giao tiếp giữa các `microservices` một cách dễ dàng. `Feign Client` sẽ tự động `load balancing` giữa các `service instances` đã đăng ký vào `Eureka Server`.

Chỉ cần cài đặt `Feign Client` và tạo `Feign Client` ở các `service` mà nó muốn giao tiếp với các `service` khác.

#### 4.3.1. Cài đặt `Feign Client`
Thêm `dependency` `Spring Cloud OpenFeign` vào `pom.xml`
> Lưu ý: Vì là dependences của `Spring Cloud`, nên cần phải cài thêm `Spring Cloud` và `quản lý dependency của Spring Cloud`
```xml
...
<dependency>
  <groupId>org.springframework.cloud</groupId>
  <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```

#### 4.3.2. Sử dụng `Feign Client` để giao tiếp giữa các `microservices`
Thêm `@EnableFeignClients` vào `Spring Boot Application` để sử dụng `Feign Client`
```java
@SpringBootApplication
@EnableFeignClients
public class AccountsApplication {
    public static void main(String[] args) {
        SpringApplication.run(AccountsApplication.class, args);
    }
}
```

Tạo `Feign Client` để giao tiếp với các `microservices` khác. Với `Feign Client`, chúng ta chỉ cần tạo `interface` và `annotation` để giao tiếp với các `microservices` khác.
>VD: `LoansFeignClient.java`
```java
...
@FeignClient("loans") // Gọi đến Microservices có name là loans, hiển thị ở Eureka Server
public interface LoansFeignClient { // Chỉ là Interface, không cần implement
  // Chỉ cần khai báo abstract method, và có signature giống với function cần gọi ở Controller loans
  @GetMapping(value = "/api/fetch", consumes = MediaType.APPLICATION_JSON_VALUE) // Api phải giống với API ở Controller loans
  public ResponseEntity<LoansDto> fetchLoanDetails(@RequestParam String mobileNumber); // LoansDto phải tạo giống với LoansDto ở Loans Service
}
```
> Lưu ý: `Feign Client` sẽ tự động `load balancing` giữa các `service instances` đã đăng ký vào `Eureka Server`. Nếu có nhiều `service instances`, `Feign Client` sẽ tự động chọn `service instance` phù hợp để giao tiếp.

Gọi `Feign Client` trong `Controller` của `Service` hiện tại
>VD: `AccountsController.java`
```java
...
@Autowired
private LoansFeignClient loansFeignClient;

@GetMapping("/fetch")
public ResponseEntity<LoansDto> fetchLoanDetails(@RequestParam String mobileNumber) {
  return loansFeignClient.fetchLoanDetails(mobileNumber);
}
```
> Từ đây, nó có thể gọi đến `Loans Service` thông qua `Feign Client` mà không cần phải biết `địa chỉ IP` của `Loans Service`. Và thực hiện `API Request` tới `Loans Service` thông qua `Feign Client` mà không cần đi vào `Loans Service` trực tiếp.

## 5. Chế độ tự bảo quản (`Self-Preservation Mode`) của `Eureka Server`
`Self-Preservation Mode` là một chế độ tự bảo quản của `Eureka Server` để ngăn chặn việc xóa các `service instances` khỏi `Eureka Server` mà không cần thiết. Khi `Eureka Server` ở trong chế độ `Self-Preservation Mode`, nó sẽ tự động `bảo quản` các `service instances` mà nó không nhận được `heartbeat` trong một khoảng thời gian nhất định (có thể gây ra bởi việc sự cố mạng hoặc lỗi phần cứng).

Mặc định khi truy cập vào `Eureka Dashboard`, chúng ta sẽ thấy dòng cảnh báo sau: **EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY'RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.** Điều này có nghĩa là `Eureka Server` đang ở trong chế độ `Self-Preservation Mode`.

Các cấu hình tác động trực tiếp hoặc gián tiếp đến hành vi `tự bảo quản` của `Eureka Server`:
- `eureka.instance.lease-renewal-interval-in-seconds = 30`: Cho biết tần suất máy khách gửi nhịp tim đến máy chủ để cho biết rằng nó vẫn còn hoạt động.
- `eureka.instance.lease-expiration-duration-in-seconds = 90`: Cho biết khoảng thời gian máy chủ chờ kể từ khi nhận được nhịp tim cuối cùng trước khi có thể trục xuất một phiên bản.
- `eureka.server.eviction-interval-timer-in-ms=60*1000`: Một bộ lập lịch (EvictionTask) được chạy ở tần suất này sẽ loại bỏ các phiên bản khỏi cơ quan đăng ký nếu hợp đồng thuê phiên bản đó đã hết hạn như được định cấu hình theo least-expiration-duration-in-seconds. Nó cũng sẽ kiểm tra xem hệ thống đã đạt đến chế độ tự bảo quản hay chưa (bằng cách so sánh nhịp tim thực tế và nhịp tim dự kiến) trước khi loại bỏ.
- `eureka.server.renewal-percent-threshold = 0.85`: Giá trị này được sử dụng để tính % nhịp tim dự kiến ​​mỗi phút mà eureka đang mong đợi.
- `eureka.server.renewal-threshold-update-interval-ms = 15*60*1000`: Một bộ lập lịch chạy ở tần số này để tính toán nhịp tim dự kiến ​​mỗi phút.
- `eureka.server.enable-self-preservation = true`: Theo mặc định, chế độ tự bảo quản được bật nhưng nếu cần tắt nó, bạn có thể thay đổi thành 'false'

## 6. Tạo file `Docker Compose` để triển khai `Eureka Server` và `Service` con
Tham khảo cách tạo `Image` và thiết lập các cấu hình ở phần `22. Build Image Spring Boot.md` và ở phần `## 5. Tạo Docker Compose cho `Spring Cloud Config Server` + `Service` con` của `24. Spring Cloud Config.md`

Sau khi tạo các `image`. Tạo file `docker-compose.yml` để triển khai `Eureka Server` trong `Microservices`
```yml
services:
  configserver:
    image: dannguyenmessi/configserver:v1
    container_name: configserver
    ports:
      - "8071:8071"
    healthcheck:
      test: "curl --fail --silent http://configserver:8071/actuator/health/readiness | grep UP || exit 1"
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 10s
    networks:
      - didan
    environment:
      SPRING_APPLICATION_NAME: "configserver"

  eurekaserver:
    image: dannguyenmessi/eurekaserver:v1
    container_name: eurekaserver
    ports:
      - "8070:8070"
    healthcheck:
      test: "curl --fail --silent http://configserver:8070/actuator/health/readiness | grep UP || exit 1"
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 10s
    networks:
      - didan
    environment:
      SPRING_APPLICATION_NAME: "eurekaserver"
      SPRING_PROFILES_ACTIVE: "default"
      SPRING_CONFIG_IMPORT: "configserver:http://configserver:8071"
    depends_on:
      configserver:
        condition: service_healthy
  
  accounts:
    image: dannguyenmessi/accounts:v1
    container_name: accounts
    ports:
      - "8080:8080"
    networks:
      - didan
    depends_on:
      configserver:
        condition: service_healthy
      eurekaserver:
        condition: service_healthy
    environment:
      SPRING_APPLICATION_NAME: "accounts"
      SPRING_PROFILES_ACTIVE: "prod"
      SPRING_CONFIG_IMPORT: "configserver:http://configserver:8071"
      EUREKA_CLIENT_SERVICEURL_DEFAULTZONE: http://eurekaserver:8070/eureka/


  loans:
    image: dannguyenmessi/loans:v1
    container_name: loans
    ports:
      - "8090:8090"
    networks:
      - didan
    depends_on:
      configserver:
        condition: service_healthy
      eurekaserver:
        condition: service_healthy
    environment:
      SPRING_APPLICATION_NAME: "loans"
      SPRING_PROFILES_ACTIVE: "prod"
      SPRING_CONFIG_IMPORT: "configserver:http://configserver:8071"
      EUREKA_CLIENT_SERVICEURL_DEFAULTZONE: http://eurekaserver:8070/eureka/
  
  cards:
    image: dannguyenmessi/cards:v1
    container_name: cards
    ports:
      - "9000:9000"
    networks:
      - didan
    depends_on:
      configserver:
        condition: service_healthy
      eurekaserver:
        condition: service_healthy
    environment:
      SPRING_APPLICATION_NAME: "cards"
      SPRING_PROFILES_ACTIVE: "prod"
      SPRING_CONFIG_IMPORT: "configserver:http://configserver:8071"
      EUREKA_CLIENT_SERVICEURL_DEFAULTZONE: http://eurekaserver:8070/eureka/

networks:
  didan:
    driver: bridge
```