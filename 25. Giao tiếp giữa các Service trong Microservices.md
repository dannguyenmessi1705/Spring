# Giao tiếp giữa các Service trong Microservices
## 1. Giới thiệu
Trong mô hình `microservices`, các `service` thường được phân `chia` thành các `service nhỏ`, mỗi service đảm nhiệm một chức năng cụ thể. Để hoạt động hiệu quả, `các service` cần phải `giao tiếp với nhau`. Có nhiều cách để giao tiếp giữa các service trong microservices, trong bài viết này chúng ta sẽ tìm hiểu về các cách giao tiếp giữa các service trong microservices.

Thông thường, các services được bao bởi 1 lớp mạng để giao tiếp với nhau, gọi là `Microservices Network`. Các services giao tiếp với nhau thông qua `HTTP` hoặc `message broker`. (`Internal Communication`)

Các giao tiếp bên ngoài của `microservices` thường được thực hiện thông qua `API Gateway`. `API Gateway` là một lớp trung gian giữa client và các services, nó nhận request từ client và chuyển tiếp request đó đến các services phù hợp. Nó còn có chức năng `authentication`, `authorization`, `rate limiting`, `logging`, `monitoring`, `load balancing`, `caching`, `request shaping`, `response aggregation`, `request and response transformation`, `static response handling`,... (`External Communication`)

Trong phần này, chúng ta sẽ tìm hiểu cách mà 1 `service` có thể khám phá và giao tiếp với các `service` khác, và cách 1 `service` có thể đăng ký vào `Microservices Network`.

## 2. Service Discovery & Registration
Trong mô hình kiến trúc microservices, việc biết chính xác `địa chỉ mạng` của một ứng dụng là 1 vấn đề hết sức phức tạp cho `client` vì các `service instances` có thể được gán `địa chỉ IP động`. Hơn thế nữa `số lượng instances` của một `service` có thể thay đổi theo thời gian.

`Microservices Discovery và Registration` là 1 cách để cho các `app` và `microservices` có thể tìm được nhau trong mạng, giải quyết vấn đề về cách các `microservices` giao tiếp với nhau, tức là thực hiện các lệnh gọi API. điều này bao gồm:
- **Một máy chủ trung tâm (hoặc các máy chủ)** duy trì chế độ xem toàn bộ về các `địa chỉ` của các `service instances`.
- Các `Microservices/clients` kết nối với `máy chủ trung tâm` để `đăng ký địa chỉ của chúng` khi chúng ở trong trạng thái `bắt đầu hoặc sẵn sàng`.
- Các `Microservices/clients` cần gửi `nhịp tim` (trạng thái hoạt động) của họ đều đặn đến `máy chủ trung tâm` về sức khỏe của họ để `máy chủ trung tâm` có thể cập nhật thông tin về trạng thái của các `service instances`.
- Các `Microservices/clients` kết nối với máy chủ trung tâm để `hủy đăng ký` địa chỉ khi chúng chuẩn bị `dừng hoặc bị hủy bỏ`.

`Khám phá dịch vụ phía máy khách` và `khám phá dịch vụ phía máy` chủ là những cách tiếp cận riêng biệt nhằm giải quyết vấn đề khám phá dịch vụ trong các bối cảnh khác nhau:
- `Khám phá dịch vụ phía máy khách` là khi `máy khách` tự mình tìm kiếm và kết nối với các `service instances` mà nó cần giao tiếp (Sử dụng Ribbon, Feign, WebClient, ...).
- `Khám phá dịch vụ phía máy chủ` là khi `máy chủ` cung cấp thông tin về các `service instances` mà nó quản lý cho các `máy khách` cần giao tiếp (Sử dụng Kubernetes, Consul, Eureka, Zookeeper, ...).

## 3. Client-side Service Discovery (Khám phá dịch vụ phía máy khách) + Load Balancing
Trong khám phá dịch vụ phía máy khách, các `ứng dụng` có trách nhiệm `tự đăng ký với sổ đăng ký dịch` vụ trong khi `khởi động` và `hủy đăng ký khi tắt`. 

Khi một ứng dụng cần liên lạc với `một dịch vụ hỗ trợ`, nó sẽ `truy vấn sổ đăng ký dịch vụ` để biết `địa chỉ IP` được liên kết. `Nếu có nhiều phiên bản của dịch vụ`, `sổ đăng ký sẽ trả về danh sách địa chỉ IP`. Sau đó, `ứng dụng khách` sẽ `chọn một ứng dụng dựa trên chiến lược cân bằng tải` được xác định của riêng nó.

### 3.1. Sử dụng `Spring Cloud` để triển khai `Client-side Service Discovery`
Với sự hỗ trợ của `Spring Cloud`, việc triển khai `Client-side Service Discovery` trở nên dễ dàng hơn bao giờ hết. `Spring Cloud` cung cấp các thư viện và công cụ để giúp chúng ta triển khai các `microservices` một cách dễ dàng và hiệu quả. Bao gồm:
- `Spring Cloud Netflix Eureka` là một `service registry` cho các `microservices` được phát triển bởi `Netflix`. Nó cung cấp một `REST API` chịu trách nhiệm đăng ký và tìm kiếm các `service instances`. [Link](https://spring.io/projects/spring-cloud-netflix)
- `Spring Cloud Load Balancer` là một `client-side load balancer` được thiết kế để hoạt động với `service discovery` của `Spring Cloud`. Ổn định hơn so với `Ribbon Netflix` và `Spring Cloud Load Balancer` cung cấp một cách tiếp cận `Spring-native` cho việc cân bằng tải `client-side`.
- `Netflix Feign Client` là một thư viện `REST client` được phát triển bởi `Netflix` để giúp chúng ta giao tiếp với các `service instances` một cách dễ dàng. [Link](https://spring.io/projects/spring-cloud-openfeign)

> Ngoài `Eureka`, chúng ta còn có thể sử dụng các công cụ khác như `Consul`, `Apache Zookeeper`, `Kubernetes`, ... để triển khai `Client-side Service Discovery`.

### 3.2. Lợi ích của `Client-side Service Discovery`
- Không có giới hạn về tính khả dụng của `service registry`. Có thể có nhiều nút khám phá dịch vụ phía máy chủ.
- Giao tiếp ngang hàng giữa các `service discovery agents`.
- IPs, các cấu hình, cân bằng tải được `quản lý động`.
- Có khả năng chịu lỗi, chịu tải và phục hồi.

