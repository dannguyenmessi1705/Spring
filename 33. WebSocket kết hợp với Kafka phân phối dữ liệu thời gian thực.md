# Sử dụng Kafka để phân phối dữ liệu thời gian thực từ WebSocket\
## 1. Giới thiệu
Trong bài viết này, chúng ta sẽ tìm hiểu cách sử dụng Kafka để phân phối dữ liệu thời gian thực từ WebSocket.

## 2. Cài đặt Kafka và Zookeeper
#### 2.1. Cài đặt Kafka và Zookeeper bằng file tải về
Để bắt đầu, chúng ta cần cài đặt Kafka và Zookeeper. Bạn có thể tìm hiểu cách cài đặt Kafka và Zookeeper tại [đây](https://kafka.apache.org/quickstart).

Cụ thể:
1. Tải file `kafka.tgz` từ trang tải [Kafka Download](https://kafka.apache.org/downloads).
2. Giải nén file `kafka.tgz` bằng lệnh `tar -xzf kafka.tgz`.
3. Di chuyển vào thư mục `kafka` bằng lệnh `cd kafka`.
4. Sử dụng `Kafka with KRaft` để chạy `Kafka`
>Generate a Cluster UUID
```bash
KAFKA_CLUSTER_ID="$(bin/kafka-storage.sh random-uuid)"
```
>Format Log Directories
```bash
bin/kafka-storage.sh format -t $KAFKA_CLUSTER_ID -c config/kraft/server.properties
```
>Start the Kafka Server
```bash
bin/kafka-server-start.sh config/kraft/server.properties
```

#### 2.2. Cài đặt Kafka và Zookeeper bằng Docker
Để cài đặt Kafka và Zookeeper bằng Docker, chúng ta sử dụng file `docker-compose.yml` sau:
```yaml
services:
  zookeeper:
    image: confluentinc/cp-zookeeper:7.3.2
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181
      ZOOKEEPER_TICK_TIME: 2000
  kafka:
    image: confluentinc/cp-kafka:7.3.2
    ports:
      - "9092:9092"
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:29092,PLAINTEXT_HOST://localhost:9092
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT
      KAFKA_INTER_BROKER_LISTENER_NAME: PLAINTEXT
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
      
```
Sau đó, chạy lệnh sau:
```bash
docker-compose up -d
```

## 3. Cấu hình ở phía Backend
### 3.1. Cài đặt các thư viện
Chúng ta cần cài đặt các thư viện sau:
- `spring-kafka`: Thư viện hỗ trợ tích hợp Kafka với Spring.
- `spring-boot-starter-websocket`: Thư viện hỗ trợ tích hợp WebSocket với Spring Boot.
- `spring-boot-starter-web`: Thư viện hỗ trợ tích hợp Web với Spring Boot.
- `lombok`: Thư viện hỗ trợ tạo các phương thức getter, setter, constructor, ... một cách tự động.

Thêm các dependency sau vào file `pom.xml`:
```xml
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-websocket</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.kafka</groupId>
      <artifactId>spring-kafka</artifactId>
    </dependency>
    <dependency>
      <groupId>org.projectlombok</groupId>
      <artifactId>lombok</artifactId>
      <optional>true</optional>
    </dependency>
    <dependency>
      <groupId>org.springframework.kafka</groupId>
      <artifactId>spring-kafka-test</artifactId>
      <scope>test</scope>
    </dependency>
```

### 3.2. Cấu hình Kafka
Chúng ta tạo 2 file config Kafka cho `Producer` và `Consumer`:

#### 3.2.1. Producer
> config/KafkaProducerConfig.java
```java
package com.example.websocket.config;

import com.example.websocket.dto.Message;
import java.util.HashMap;
import java.util.Map;
import org.apache.kafka.clients.producer.ProducerConfig;
import org.apache.kafka.common.serialization.StringSerializer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.core.DefaultKafkaProducerFactory;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.core.ProducerFactory;
import org.springframework.kafka.support.serializer.JsonSerializer;

@Configuration
public class KafkaProducerConfig {
  @Bean
  public ProducerFactory<String, Message> producerFactory() { // Tạo ra một ProducerFactory để tạo ra một Producer với khóa kiểu String và giá trị kiểu Message (DTO cần gửi)
    Map<String, Object> configProps = new HashMap<>();
    configProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092"); // Cấu hình Kafka server
    configProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class); // Cấu hình key serializer dùng để serialize key của message từ Object về bytes trước khi gửi tới Kafka
    configProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class); // Cấu hình value serializer dùng để serialize value của message từ Object về bytes trước khi gửi tới Kafka
    return new DefaultKafkaProducerFactory<>(configProps);
  }

  @Bean
  public KafkaTemplate<String, Message> kafkaTemplate() { // Tạo ra một KafkaTemplate để gửi message tới Kafka
    return new KafkaTemplate<>(producerFactory()); // Tạo ra một KafkaTemplate với ProducerFactory đã được cấu hình ở trên
  }
}
```

#### 3.2.2. Consumer
> config/KafkaConsumerConfig.java
```java
package com.example.websocket.config;

import com.example.websocket.dto.Message;
import java.util.HashMap;
import java.util.Map;
import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.common.serialization.StringDeserializer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;
import org.springframework.kafka.core.ConsumerFactory;
import org.springframework.kafka.core.DefaultKafkaConsumerFactory;
import org.springframework.kafka.support.serializer.JsonDeserializer;

@Configuration
public class KafkaConsumerConfig {
  @Bean
  public ConsumerFactory<String, Message> consumerFactory() { // Tạo ra một ConsumerFactory để tạo ra một Consumer với khóa kiểu String và giá trị kiểu Message (DTO cần nhận)
    Map<String, Object> configProps = new HashMap<>();
    configProps.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092"); // Cấu hình Kafka server
    configProps.put(ConsumerConfig.GROUP_ID_CONFIG, "chat"); // Cấu hình group id
    configProps.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); // Cấu hình key deserializer dùng để deserialize key của message (bytes) từ Kafka về Object
    configProps.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, JsonDeserializer.class); // Cấu hình value deserializer dùng để deserialize value của message (bytes) từ Kafka về Object
    return new DefaultKafkaConsumerFactory<>(configProps, new StringDeserializer(), new JsonDeserializer<>(Message.class)); // Tạo ra một ConsumerFactory với cấu hình và deserializer đã được cấu hình
  }

  @Bean
  public ConcurrentKafkaListenerContainerFactory<String, Message> kafkaListenerContainerFactory() { // Tạo ra một KafkaListenerContainerFactory để tạo ra một KafkaListenerContainer
    ConcurrentKafkaListenerContainerFactory<String, Message> factory = new ConcurrentKafkaListenerContainerFactory<>();
    factory.setConsumerFactory(consumerFactory()); // Cấu hình ConsumerFactory cho KafkaListenerContainerFactory
    return factory;
  }
}
```

### 3.3. Tạo các `Service` để thực hiện gửi và nhận message từ Kafka
#### 3.3.1. Service gửi message
> service/Sender.java
```java
package com.example.websocket.service;

import com.example.websocket.dto.Message;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Service;

@Service
@AllArgsConstructor
@Slf4j
public class Sender {
  private final KafkaTemplate<String, Message> kafkaTemplate; // Đối tượng này giúp gửi message tới Kafka

  public void send(String topic, Message message) {
    log.info("Message sent to Kafka: {}", message);
    kafkaTemplate.send(topic, message); // Gửi message tới Kafka với topic và message cần gửi
  }

}
```

#### 3.3.2. Service nhận message
> service/Receiver.java
```java
package com.example.websocket.service;

import com.example.websocket.dto.Message;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.messaging.simp.SimpMessageSendingOperations;
import org.springframework.messaging.simp.user.SimpSession;
import org.springframework.messaging.simp.user.SimpUser;
import org.springframework.messaging.simp.user.SimpUserRegistry;
import org.springframework.stereotype.Service;

@Service
@AllArgsConstructor
@Slf4j
public class Receiver {

  private final SimpMessageSendingOperations messagingTemplate; // Đối tượng này giúp gửi message tới client subscribe tới /topic/*
  private final SimpUserRegistry simpUserRegistry; // Đối tượng này chứa thông tin về tất cả user đang kết nối tới server

  @KafkaListener(topics = "messaging", groupId = "chat") // Lắng nghe message từ Kafka với topic là "messaging" và groupId là "chat"
  public void consume(Message chatMessage) {
    log.info("Received message from Kafka: {}", chatMessage);
    for (SimpUser user : simpUserRegistry.getUsers()) { // Duyệt qua tất cả user đang kết nối tới server
      for (SimpSession simpSession : user.getSessions()) { // Duyệt qua tất cả session của user
        if (!simpSession.getId().equals(chatMessage.getSessionId())) { // Nếu sessionId của message không trùng với sessionId của session thì gửi message tới session đó, mục đích là không gửi lại message tới chính session đã gửi message
          messagingTemplate.convertAndSendToUser(simpSession.getId(), "/topic/public", chatMessage);
        }
      }
    }
  }
}
```

### 3.4. Tạo DTO để định nghĩa message
> dto/Message.java
```java
package com.example.websocket.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@AllArgsConstructor
@NoArgsConstructor
@Data
@Builder
public class Message {
  private MessageType messageType;
  private String content;
  private String sender;
  private String sessionId;

  public static enum MessageType {
    CHAT,
    CONNECT,
    DISCONNECT
  }
}
```

### 3.5. Cấu hình WebSocket 
#### 3.5.1. Cấu hình các endpoint WebSocket
> config/WebSocketConfig.java
```java
package com.example.websocket.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;

@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

  @Override
  public void configureMessageBroker(MessageBrokerRegistry registry) {
    registry.enableSimpleBroker("/topic"); // Client sẽ subscribe tới route bắt đầu từ /topic/* để lắng nghe và nhận message từ server
    registry.setApplicationDestinationPrefixes("/app"); // Client sẽ gửi message tới route bắt đầu bằng /app/*
  }

  @Override
  public void registerStompEndpoints(StompEndpointRegistry registry) {
    registry.addEndpoint("/ws") // Endpoint để client kết nối tới socket
        .setAllowedOriginPatterns("*") // Cho phép tất cả các origin kết nối tới
        .withSockJS(); // Sử dụng SockJS nếu client không hỗ trợ WebSocket
  }
}
```
#### 3.5.2. Cấu hình các `EventListener` để lắng nghe các sự kiện từ WebSocket
> event/WebSocketEventListener.java
```java
package com.example.websocket.config;

import com.example.websocket.dto.Message;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.event.EventListener;
import org.springframework.messaging.simp.SimpMessageSendingOperations;
import org.springframework.messaging.simp.stomp.StompHeaderAccessor;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.messaging.SessionConnectedEvent;
import org.springframework.web.socket.messaging.SessionDisconnectEvent;

@Component
@AllArgsConstructor
@Slf4j
public class WebSocketEventListener {
  private final SimpMessageSendingOperations messagingTemplate;

  // Hàm này sẽ được gọi khi có client kết nối tới server
  @EventListener
  public void handleWebSocketConnectListener(SessionConnectedEvent event) {
    log.info("Received a new web socket connection");
  }

  // Hàm này sẽ được gọi khi có client ngắt kết nối tới server
  @EventListener
  public void handleWebSocketDisconnectListener(SessionDisconnectEvent event) {
    StompHeaderAccessor headerAccessor = StompHeaderAccessor.wrap(event.getMessage()); // Lấy thông tin từ event
    String username = (String) headerAccessor.getSessionAttributes().get("username"); // Lấy username từ session đã được tạo từ Controller
    if (username != null) { // Nếu username tồn tại (Client đã gửi message "/app/chat.add-user")
      log.info("User Disconnected {}", username);
      Message chatMessage = Message.builder()
          .messageType(Message.MessageType.DISCONNECT)
          .sender(username)
          .build(); // Tạo message DISCONNECT
      messagingTemplate.convertAndSend("/topic/public", chatMessage); // Gửi message tới tất cả client subscribe tới /topic/public
    }
  }
}
```

### 3.6. Tạo Controller để xử lý các request từ client
Trước tiên đi vào ví dụ, chúng ta hiểu các hàm, biến sau để xử lý:
- `@MessageMapping("/")`: Annotation để xác định route mà client gửi message tới WebSocket.
- `@SendTo("/topic/public")`: Annotation để xác định route mà server gửi message tới client. (Nếu client subscribe tới route này thì sẽ nhận được message từ server). Khi để annotation này ở trên hàm, nghĩa là server sẽ sử dụng `MessageBroker` trong bộ nhớ chứ không sử dụng Kafka.
- `@Payload`: Annotation để xác định đối tượng được gửi từ client tới server. Đóng vai trò như `@RequestBody` trong REST API.
- `SimpMessageSendingOperations`: Đối tượng này giúp gửi message tới client subscribe tới `route` mà server đã cấu hình làm `MessageBroker`. Không cần sử dụng annotation `@SendTo`.
- `SimpUserRegistry`: Đối tượng này chứa thông tin về tất cả user đang kết nối tới server.
- `SimpMessageHeaderAccessor`: Đối tượng này giúp lấy thông tin từ message như sessionId, ... để xử lý.

> controller/MessageController.java
```java
package com.example.websocket.controller;

import com.example.websocket.dto.Message;
import com.example.websocket.service.Sender;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.messaging.handler.annotation.Payload;
import org.springframework.messaging.handler.annotation.SendTo;
import org.springframework.messaging.simp.SimpMessageHeaderAccessor;
import org.springframework.messaging.simp.SimpMessageSendingOperations;
import org.springframework.stereotype.Controller;

@Controller // Với WebSocket, ta sẽ sử dụng @Controller thay vì @RestController
@AllArgsConstructor
@Slf4j
public class MessageController {
  private final Sender sender; // Đối tượng này giúp gửi message tới Kafka
  private final SimpMessageSendingOperations messagingTemplate; // Đối tượng này giúp gửi message tới client

  @MessageMapping("/chat.send-message") // Khi client gửi message tới /app/chat.send-message, phương thức này sẽ được gọi
  public void sendMessage(
      @Payload Message chatMessage, // Message được gửi từ client (Sử dụng @Payload để lấy message từ body)
      SimpMessageHeaderAccessor headerAccessor // HeaderAccessor chứa thông tin về message (ví dụ: sessionId, username, ...)
  ) {
    chatMessage.setSessionId(headerAccessor.getSessionId()); // Set sessionId cho message
    sender.send("messaging", chatMessage); // Gửi message tới Kafka
    log.info("Sending message to /topic/public: {}", chatMessage);
    messagingTemplate.convertAndSend("/topic/public", chatMessage); // Gửi message tới tất cả client subscribe tới /topic/public
    log.info("Message sent to /topic/public: {}", chatMessage);
  }

  @MessageMapping("/chat.add-user") // Khi client gửi message tới /app/chat.add-user, phương thức này sẽ được gọi
  @SendTo("/topic/public") // Khi phương thức này được gọi, message sẽ được gửi tới /topic/public thay vì sử dụng SimpMessageSendingOperations
  public Message addUser(
      @Payload Message chatMessage, // Message được gửi từ client (Sử dụng @Payload để lấy message từ body)
      SimpMessageHeaderAccessor headerAccessor // HeaderAccessor chứa thông tin về message (ví dụ: sessionId, username, ...)
  ) {
    if (headerAccessor.getSessionAttributes() != null) { // Nếu session đã được tạo
      headerAccessor.getSessionAttributes().put("username", chatMessage.getSender()); // Set username cho session
    }
    return chatMessage; // Trả về message cho client subscribe tới /topic/public
  }
}
```

## 4. Cấu hình ở phía Frontend (React)
### 4.1. Cài đặt các thư viện
Chúng ta cần cài đặt các thư viện sau:
- `sockjs-client`: Thư viện hỗ trợ kết nối tới WebSocket nếu client không hỗ trợ WebSocket.
- `@types/sockjs-client`: Thư viện hỗ trợ kiểu dữ liệu cho `sockjs-client` cho TypeScript.
- `@stomp/stompjs`: Thư viện hỗ trợ giao tiếp với WebSocket.

### 4.2. Tạo các function để gửi và nhận message từ WebSocket
Để kết nối tới WebSocket, chúng ta cần tạo một client và kết nối tới server qua `Client` của `@stomp/stompjs`. Sau đó, chúng ta sẽ gửi message tới server qua `client.publish` và nhận message từ server qua `client.subscribe`.

Ngoài ra đối tượng `Client` còn cung cấp các callback để xử lý các sự kiện như:
- `onConnect`: Callback được gọi khi kết nối thành công.
- `onDisconnect`: Callback được gọi khi client bị ngắt kết nối.
- `onWebSocketClose`: Callback được gọi khi websocket bị đóng từ server.
- `onWebSocketError`: Callback được gọi khi có lỗi xảy ra với websocket.
- `onStompError`: Callback được gọi khi có lỗi xảy ra với STOMP.

Sau đó sử dụng các hàm như `activate` để kết nối tới server, `deactivate` để ngắt kết nối, `publish` để gửi message, `subscribe` để nhận message.
> ChatPage.tsx
```tsx
import {useEffect, useRef, useState} from "react";
import {Client} from "@stomp/stompjs";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-expect-error
import SockJS from 'sockjs-client/dist/sockjs.js';
import {Box, Button, Container, TextField} from "@mui/material";

import ChatMessage from "./ChatMessage.tsx";

type ChatPageProps = {
  username: string;
}
type Message = {
  sender: string;
  type: string;
}
type Chat = {
  sender: string;
  content: string;
  type: string;
}
function ChatPage({ username } : ChatPageProps) {
  const [messages, setMessage] = useState<Chat[]>([]);
  const [client, setClient] = useState<Client | null>(null);
  const [connectionStatus, setConnectionStatus] = useState<string>("Connecting...");
  const messageInputRef = useRef<HTMLInputElement>(null);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const newClient = new Client({ // Tạo một client mới
      webSocketFactory: () => new SockJS("http://localhost:8080/ws"), // Kết nối đến server qua websocket
      onConnect: () => { // Callback được gọi khi kết nối thành công
        console.log("Connected to server");
        const joinMessage: Message = {
          sender: username,
          type: "CONNECT"
        };
        newClient.publish({ // Gửi message lên server
          destination: "/app/chat.addUser",
          body: JSON.stringify(joinMessage)
        });
        newClient.subscribe("/topic/public", (message) => { // Đăng ký để nhận message từ server
          const newMessage = JSON.parse(message.body);
          console.log("new message: ", newMessage);
          setMessage(prev => [...prev, newMessage])
        });
        setConnectionStatus("Connected");
      },
      onDisconnect: () => { // Callback được gọi khi client bị ngắt kết nối
        console.log("Disconnected from server");
        if (newClient.connected) {
          const leaveMessage: Message = {
            sender: username,
            type: "DISCONNECT"
          };
          newClient.publish({ // Gửi message lên server
            destination: "/app/chat.addUser",
            body: JSON.stringify(leaveMessage)
          });
        }
        setConnectionStatus("Disconnected");
      },
      onWebSocketClose: () => { // Callback được gọi khi websocket bị đóng
        setConnectionStatus('Disconnected');
      },
      onWebSocketError: (error) => { // Callback được gọi khi có lỗi xảy ra với websocket
        console.error('WebSocket error: ', error);
        setConnectionStatus('Failed to connect');
      },
      onStompError: (frame) => { // Callback được gọi khi có lỗi xảy ra với STOMP
        console.log('Broker reported error: ' + frame.headers['message']);
        console.log('Additional details: ' + frame.body);
      },
    });

    newClient.activate(); // Bắt đầu kết nối với server
    setClient(newClient); // Lưu lại client để sử dụng ở các lifecycle hooks khác

    return () => {
      newClient.deactivate(); // Ngắt kết nối khi component bị unmount
    };
  }, [username]);

  useEffect(() => {
    // Scroll to the bottom whenever messages update
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  const sendMessage = () => {
    if (messageInputRef.current!.value && client) {
      const chatMessage: Chat = {
        sender: username,
        content: messageInputRef.current!.value,
        type: "CHAT"
      };
      console.log(chatMessage);
      client.publish({
        destination: "/app/chat.send-message",
        body: JSON.stringify(chatMessage)
      }); // Gửi message lên server
      messageInputRef.current!.value = ""; // Xóa nội dung trong input sau khi gửi
    } else {
      console.log("Unable to send message");
    }
  };
  const handleKeyDown = (event: React.KeyboardEvent<HTMLDivElement>) => {
    if (event.key === 'Enter' && !event.shiftKey) {
      sendMessage();
      event.preventDefault(); // Prevent form submission
    }
  };


  return (
      <Container>
        <h2>{connectionStatus}</h2>
        <Box display="flex" flexDirection="column" justifyContent="center" alignItems="center" mt={2}>
          <Box sx={{height: '500px', overflow: 'auto', width: '100%'}}>
            {messages.map((message, index) => (
                <ChatMessage key={index} message={message} username={username} />
            ))}
            <div ref={messagesEndRef}/>
          </Box>
          <Box display="flex" justifyContent="center" alignItems="stretch" mt={2}>
            <TextField
                sx={{
                  color: 'white', '& .MuiOutlinedInput-notchedOutline': {borderColor: 'gray'},
                  width: '300px',
                  height: '10px',
                  '& .MuiOutlinedInput-root': {
                    borderRadius: '36px',
                    '& fieldset': {
                      borderColor: 'gray',
                    },
                    '& input': {
                      height: '10px',
                    },
                  },
                }}
                inputProps={{style: {color: 'white'}}}
                inputRef={messageInputRef}
                variant="outlined"
                placeholder="Type a message..."
                onKeyDown={handleKeyDown}
            />
            <Box marginLeft={2}>
              <Button
                  variant="contained"
                  color="primary"
                  sx={{
                    width: '94px',
                    height: '42px',
                    borderRadius: '36px',
                  }}
                  onClick={sendMessage}>
                Send
              </Button>
            </Box>
          </Box>
        </Box>
      </Container>
  )
}

export default ChatPage;
```

### 4.3. Tạo component để hiển thị message
> ChatMessage.tsx
```tsx
import {Box} from "@mui/material";
import Avatar from "react-avatar";

type Chat = {
  sender: string;
  content: string;
  type: string;
}
function ChatMessage({ message, username }: { message: Chat, username: string }) {
  if (message.type === 'CONNECT' || message.type === 'DISCONNECT') {
    return (
        <Box sx={{display: 'flex', justifyContent: 'center', alignItems: 'center', width: '100%', margin: '10px 0'}}>
          <p style={{color: message.type === 'CONNECT' ? 'lime' : 'orangered'}}>{message.sender + " " + message.type.toLowerCase() + "ed"}</p>
        </Box>
    );
  }
  return (
      <Box sx={{
        display: 'flex',
        flexDirection: 'column',
        alignItems: message.sender === username ? 'flex-end' : 'flex-start', margin: '10px 0' }}>
        <Box sx={{ marginRight: message.sender === username ? '8px' : 'auto', display: 'flex', flexDirection: message.sender === username ? 'row-reverse' : 'row', alignItems: 'center', gap: 1 }}>
          <Avatar name={message.sender} size="35" round={true} />
          <h4>{message.sender}</h4>
        </Box>
        <Box sx={{
          marginRight: message.sender === username ? '8px' : 'auto',
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          maxWidth: '60%',
          height: '16px',
          padding: '10px',
          borderRadius: '16px',
          backgroundColor: 'primary.main',
          wordWrap: 'break-word',
        }}>
          <p>{message.content}</p>
        </Box>
      </Box>
  );
}
export default ChatMessage;
```

