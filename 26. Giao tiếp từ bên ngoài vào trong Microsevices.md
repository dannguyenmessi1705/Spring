# Giao tiếp từ bên ngoài vào trong Microsevices
## 1. Giới thiệu
Trong chủ đề này, chúng ta sẽ tìm hiểu về các khái niệm như:
- `Gateway`: là một dịch vụ đầu vào của hệ thống, nó nhận các request từ `bên ngoài` và `chuyển tiếp` đến các dịch vụ khác `trong hệ thống microservices`.
- `Routing`: là quá trình xác định cách mà một request sẽ được chuyển tiếp từ `gateway` đến `dịch vụ` trong `microservices` cụ thể.
- `Cross-cutting concerns`: là các vấn đề mà mọi dịch vụ trong hệ thống đều cần xử lý, như `logging`, `security`, `monitoring`, `rate limiting`, `caching`, `etc`.

Tất cả những việc này cấu thành `Edge Server/ API Gateway` đóng vai trò như một máy chủ quản lý các request từ bên ngoài và chuyển tiếp đến các dịch vụ khác trong hệ thống.

> Để xây dựng `Edge Server/ API Gateway`, chúng ta có thể sử dụng các công nghệ như `Spring Cloud Gateway`, `Jewel`, `Zuul`, `Kong`, `Nginx`, `Traefik`, `Envoy`, `etc`.

## 2. Spring Cloud Gateway
### 2.1. Giới thiệu
`Spring Cloud Gateway` hợp lý hóa việc tạo các `dịch vụ biên` bằng cách nhấn mạnh vào tính dễ dàng và hiệu quả. Hơn nữa, do sử dụng react framework, nó có thể `mở rộng liền mạch` để xử lý khối lượng công việc đáng kể thường `phát sinh ở rìa hệ thống` trong khi vẫn `duy trì khả năng mở rộng tối ưu`.

Dưới đây là các khía cạnh chính của `Spring Cloud Gateway`:
- `Cổng dịch vụ` đóng vai trò là `người gác cổng - gatekeeper` cho tất cả lưu lượng truy cập đến các API microservices trong ứng dụng của chúng ta. Khi có cổng dịch vụ, khách hàng dịch vụ `không bao giờ` `calls trực tiếp` URL của một dịch vụ riêng lẻ mà thay vào đó thực hiện tất cả các `cuộc gọi đến cổng dịch vụ`.
- `Spring Cloud Gateway` là một thư viện để `xây dựng một cổng API` nên nó trông giống như bất kỳ ứng dụng Spring Boot nào khác.
- `Spring Cloud Gateway` được thiết kế để đặt `giữa` `người yêu cầu` và `tài nguyên đang được yêu cầu`, nơi nó `chặn`, `phân tích` và `sửa đổi` mọi yêu cầu. Điều đó có nghĩa là bạn có thể định tuyến các yêu cầu dựa trên ngữ cảnh của chúng. Yêu cầu có bao gồm tiêu đề cho biết phiên bản API không? Chúng tôi có thể định tuyến yêu cầu đó đến phần phụ trợ được phiên bản phù hợp. Yêu cầu có yêu cầu phiên cố định không? Cổng có thể theo dõi phiên của từng người dùng.

`Cổng dịch vụ` nằm `giữa` tất cả các `cuộc gọi từ máy khách đến các dịch vụ riêng lẻ` và` hoạt động như một Điểm thực thi chính sách (PEP)` trung tâm như:
- Định tuyến (Cả tĩnh và động)
- Bảo mật (Xác thực & Ủy quyền)
- Ghi nhật ký, kiểm tra và số liệu

[Spring Cloud Gateway](https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/)

### 2.2. Cài đặt
#### 2.2.1. Tạo dự án Spring Boot với Spring Cloud Gateway
Để cài đặt `Gateway Server` chúng ta sử dụng các `dependency` sau:
- `Spring Cloud Gateway`: là thư viện chính của `Gateway Server`, dùng để xử lý các request từ bên ngoài và chuyển tiếp đến các dịch vụ khác trong hệ thống. (Lưu ý: Chọn `Reactive Gateway` trong `Spring Initializr`).
>pom.xml
```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-gateway</artifactId>
</dependency>
```
- `Spring Cloud Config Client`: là thư viện dùng để cấu hình `Gateway Server` từ `Config Server`.
>pom.xml
```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-config</artifactId>
</dependency>
```
- `Spring Cloud Eureka Client`: là thư viện dùng để đăng ký `Gateway Server` lên `Eureka Server`.
>pom.xml
```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```
- `Spring Boot Actuator`: là thư viện dùng để quản lý và giám sát `Gateway Server`.
>pom.xml
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```
- Ngoài ra nên thêm `DevTools` để tiện cho việc phát triển.
> Lưu ý: Cần cấu hình `Config Server` và `Eureka Server` trước khi cấu hình `Gateway Server`. Và cần phải thêm các `tag` của `Spring Cloud` như `<properties></properties>`, `<dependencyManagement></dependencyManagement>`.

### 2.2. Cấu hình Spring Cloud Gateway, kết nối tới `Config Server` và `Eureka Server`
>application.yml
```yml
spring:
  application:
    name: "gatewayserver"
  config:
    import: optional:configserver:http://localhost:8071
  cloud:
    gateway:
      discovery:
        locator:
          enabled: true # Cho phép Gateway Server sử dụng Eureka để tìm kiếm, định tuyến các service (nên chọn false để loại bỏ các service không cần thiết)
          lowerCaseServiceId: true # Chuyển tên service thành chữ thường, tránh lỗi khi gọi service

management:
  endpoints:
    web:
      exposure:
        include: "*" # Cho phép hiển thị tất cả các endpoint
  endpoint:
    gateway:
      enabled: true # Cho phép dùng endpoint /actuator/gateway để xem thông tin về các route
  info:
    env:
      enabled: true # Cho phép dùng endpoint /actuator/info để xem thông tin về service

info: # Thông tin về service hiển thị trên Eureka dashboard
  app:
    name: "gatewayserver"
    description: "Bank Gateway Server Application Microservices"
    version: "1.0.0"

# Cấu hình ở Config Server
server:
  port: 8072

eureka:
  instance:
    prefer-ip-address: true
  client:
    fetch-registry: true
    register-with-eureka: true
    service-url:
      defaultZone: http://localhost:8070/eureka/
```

Sau khi cấu hình xong, chạy lần lượt `Config Server`, `Eureka Server`, `Microservices` và cuối cùng là `Gateway Server`. Sau đó, truy cập vào đường dẫn `http://localhost:8072/actuator/gateway/routes` để xem thông tin về các route.

### 2.3. Request từ bên ngoài vào trong Microservices
Sau khi cấu hình xong, chúng ta sẽ thực hiện các request từ bên ngoài vào trong `Microservices` thông qua `Gateway Server`.

Để thực hiện việc này, chúng ta thay vì truy cập vào trực tiếp từng `Microservices` (sẽ bị giấu) thì sẽ truy cập vào `Gateway Server` và `Gateway Server` sẽ chuyển tiếp request đó đến `Microservices` tương ứng bằng cách: `http://localhost:8072/{service-name}/{path}`. Trong đó:
- `service-name`: là tên của `Microservices`. Để xem tên của `Microservices` chúng ta có thể truy cập vào `Eureka Dashboard`. (Lưu ý thêm `lowerCaseServiceId: true` trong cấu hình `Gateway Server` để chuyển tên service thành chữ thường).
- `path`: là đường dẫn của `Microservices`.
> Ví dụ: `Get Accounts` của `Account Service` có `spring.application.name` là `accounts` sẽ là `http://localhost:8080/api/fetch?mobileNumber=0258920585`.
> Truy cập vào `Gateway Server` sẽ là `http://localhost:8072/accounts/api/fetch?mobileNumber=0258920585`.

### 2.4. Tùy chỉnh định tuyến URL (Custom Routing) trong Spring Cloud Gateway
Mặc định, `Spring Cloud Gateway` sẽ tự động tạo ra các route dựa trên `Eureka Server`. Chúng ta truy cập vào các `Microservices` thông qua `Gateway Server` bằng cách: `http://localhost:8072/{service-name}/{path}`.

Tuy nhiên chúng ta có thể tùy chỉnh định tuyến URL bằng cách đưa lên `Bean` `RouteLocator` trong `Spring Cloud Gateway`. Ví dụ
>Application.java
```java
@SpringBootApplication
public class GatewayServerApplication {

    public static void main(String[] args) {
        SpringApplication.run(GatewayServerApplication.class, args);
    }

  // Tạo các route cho các microservices
  @Bean // Bean này sẽ được Spring Boot quản lý và sử dụng 
  RouteLocator createRouteLocator(RouteLocatorBuilder routeLocatorBuilder) { // RouteLocatorBuilder giúp tạo ra các route
    return routeLocatorBuilder.routes() // Tạo ra các route
        .route(p -> p.path("/didan/accounts/**") // Đường dẫn của route
            .filters(f -> f.rewritePath("/didan/accounts/(?<remaining>.*)", "/${remaining}")) // Rewrite đường dẫn
            .uri("lb://ACCOUNTS")) // Đường dẫn của microservices cần gọi, lưu ý phải trùng với tên service trong Eureka Server (lb: load balancer, sau dấu // là tên service)
        .build();
  }
}
```
Ngoài ra trong `filters` ngoài `rewritePath` chúng ta còn có thể sử dụng đồng thời các `filter` khác như:
- `addRequestHeader`: thêm header vào request.
- `addResponseHeader`: thêm header vào response.
- `addRequestParameter`: thêm parameter vào request.
- `addResponseHeader`: thêm header vào response.
- `cacheRequestBody`: dùng để cache request body để sử dụng lại.
- `changeRequestUri`: thay đổi URI của request (đường dẫn).
- `ciruitBreaker`: sử dụng để ngắt mạch khi có lỗi.
- `fallbackHeaders`: sử dụng để xác định header khi có lỗi.

### 2.5. Cross-cutting concerns trong Spring Cloud Gateway
`Cross-cutting concerns` là các vấn đề mà mọi dịch vụ trong hệ thống đều cần xử lý, như `logging`, `security`, `monitoring`, `rate limiting`, `caching`, `etc`. Trong `Spring Cloud Gateway` chúng ta có thể xử lý các `Cross-cutting concerns` bằng cách sử dụng các `filter`.

Chúng ta sẽ sử dụng `GlobalFilter` để xử lý các `Cross-cutting concerns` trong `Spring Cloud Gateway`, kết hợp với `correlationId` để theo dõi mỗi request.

Với việc sử dụng `correlationId` chúng ta có thể theo dõi các request từ bên ngoài vào trong `Microservices` và ngược lại từ trong `Microservices` ra bên ngoài. Giúp bảo mật và có thể `log` được mỗi request bởi vì bên trong hệ thống `Microservices` có thể có nhiều `Microservices` khác nhau. Sử dụng `correlationId` giúp chúng ta theo dõi mỗi request sẽ đi đến `Microservices` nào.

Quy trình xử lý request trong `Spring Cloud Gateway`:
- `RequestTraceFilter`: lọc và tạo `correlationId` cho mỗi request. (Lưu ý: `correlationId` là một `unique id` dùng để theo dõi mỗi request).
- `FilterUtility`: lớp tiện ích dùng để xử lý logic của `RequestTraceFilter` và `ResponseTraceFilter` như tạo `correlationId`, lưu `correlationId` vào `Header` của `Request`.
- `ResponseTraceFilter`: lọc và ghi log thông tin của mỗi request. (Lưu ý: `correlationId` sẽ được lấy từ `Header` của `Request`).

#### 2.5.1. Đầu tiên, tạo các `Filter` trong `Gateway Server`.
>`Gateway Server`: FilterUtility.java
```java
package com.didan.microservices.gatewaysever.filter;

import java.util.List;
import org.springframework.http.HttpHeaders;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;

@Component // Thêm Bean vào Spring IoC container
public class FilterUtility {  // Lớp FilterUtility chứa các phương thức xử lý logic
  public static final String CORRELATION_ID = "bank-correlation-id"; // id của correlation trong header
  public String getCorrelationId(HttpHeaders requestHeaders) { // Phương thức lấy ra correlation-id từ headers
    if (requestHeaders.get(CORRELATION_ID) != null) { // Kiểm tra xem trường correlation-id đã tồn tại trong headers hay chưa
      List<String> requestHeaderList = requestHeaders.get(CORRELATION_ID); // Lấy ra giá trị của trường correlation-id
      return requestHeaderList.stream().findFirst().get(); // Trả về giá trị của trường correlation-id
    } else {
      return null; // Nếu trường correlation-id chưa tồn tại thì trả về null
    }
  }

  public ServerWebExchange setRequestHeader(ServerWebExchange exchange, String name, String value) {
    return exchange.mutate()
        .request(exchange.getRequest().mutate().header(name, value).build()) // Tạo lại request với header mới
        .build(); // Xây dựng exchange mới
  } // Phương thức setRequestHeader giúp thêm một header vào request

  public ServerWebExchange setCorrelationId(ServerWebExchange exchange, String correlationId) {
    return this.setRequestHeader(exchange, CORRELATION_ID, correlationId);
  } // Phương thức setCorrelationId giúp thêm correlation-id vào request

}
```
>`Gateway Server`: RequestTraceFilter.java
```java
package com.didan.microservices.gatewaysever.filter;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.annotation.Order;
import org.springframework.http.HttpHeaders;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

@Order(1) // Annotation thông báo, filter này sẽ được thực thi đầu tiên
@Component // Tạo ra một bean cho Spring Boot quản lý
public class RequestTraceFilter implements GlobalFilter { // GlobalFilter là một interface của Spring Cloud Gateway

  private static final Logger logger = LoggerFactory.getLogger(RequestTraceFilter.class);

  @Autowired
  FilterUtility filterUtility; // Inject FilterUtility vào RequestTraceFilter

  @Override // Ghi đè phương thức filter của interface GlobalFilter
  // Mono<Void> là một kiểu dữ liệu của Reactor, giúp xử lý bất đồng bộ và trả về một giá trị void
  // ServerWebExchange là một interface của Spring WebFlux, giúp lấy thông tin của request và response
  // GatewayFilterChain là một interface của Spring Cloud Gateway, giúp chuyển tiếp request đến các filter khác
  public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
    HttpHeaders requestHeaders = exchange.getRequest().getHeaders(); // Lấy ra các headers của request
    if (isCorrelationIdPresent(requestHeaders)) { // Kiểm tra xem correlation-id đã tồn tại hay chưa
      logger.debug("Bank-correlation-id found in RequestTraceFilter : {}",
          filterUtility.getCorrelationId(requestHeaders)); // In ra log correlation-id đã tồn tại
    } else { // Nếu correlation-id chưa tồn tại
      String correlationID = generateCorrelationId(); // Tạo ra một correlation-id mới
      exchange = filterUtility.setCorrelationId(exchange, correlationID); // Set correlation-id vào request
      logger.debug("Bank-correlation-id generated in RequestTraceFilter : {}", correlationID); // In ra log correlation-id đã tạo
    }
    return chain.filter(exchange); // Chuyển tiếp request đến các filter khác
  }

  private boolean isCorrelationIdPresent(HttpHeaders requestHeaders) {
    if (filterUtility.getCorrelationId(requestHeaders) != null) { // Lấy ra correlation-id từ headers
      return true; // Nếu correlation-id đã tồn tại thì trả về true
    } else {
      return false; // Nếu correlation-id chưa tồn tại thì trả về false
    }
  } // Kiểm tra xem correlation-id đã tồn tại hay chưa

  private String generateCorrelationId() {
    return java.util.UUID.randomUUID().toString(); // Tạo ra một correlation-id mới
  }

}
```
>`Gateway Server`: ResponseTraceFilter.java
```java
package com.didan.microservices.gatewaysever.filter;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpHeaders;
import reactor.core.publisher.Mono;

@Configuration // Annotation thông báo, đây là một class cấu hình
public class ResponseTraceFilter { // Class ResponseTraceFilter chứa các phương thức xử lý logic

  private static final Logger logger = LoggerFactory.getLogger(ResponseTraceFilter.class);

  @Autowired
  FilterUtility filterUtility; // Inject FilterUtility vào ResponseTraceFilter

  @Bean // Annotation thông báo, phương thức này sẽ tạo ra một Bean
  public GlobalFilter postGlobalFilter() { // Tạo ra một GlobalFilter để xử lý logic
    return (exchange, chain) -> { // Lambda expression, xử lý logic
      return chain.filter(exchange).then(Mono.fromRunnable(() -> { // Xử lý logic bất đồng bộ
        HttpHeaders requestHeaders = exchange.getRequest().getHeaders(); // Lấy ra các headers của request
        String correlationId = filterUtility.getCorrelationId(requestHeaders); // Lấy ra correlation-id từ headers
        logger.debug("Updated the correlation id to the outbound headers: {}", correlationId); // In ra log correlation-id đã được cập nhật
        exchange.getResponse().getHeaders().add(filterUtility.CORRELATION_ID, correlationId); // Thêm correlation-id vào headers của response
      }));
    };
  }
}
```
#### 2.5.2. Tiếp theo, chọn các `service` cần xử lý `Cross-cutting concerns`. Ý là `api` của `service` này sẽ `giao tiếp` với `api` của `service` khác bởi `OpenFeign`, qua `Gateway Server`.
Để thêm, xử lý `Cross-cutting concerns` chúng ta sẽ thêm `correlationId` vào `header` của `request` và `response` trong `service` cần xử lý. Ví dụ:

>`Accounts`: CustomerDetailsController.java
```java
....
@GetMapping("/fetch")
public ResponseEntity<CustomerDetails> fetchCustomerDetails(
  @RequestHeader("bank-correlation-id") String correlationId, // Lấy ra correlation-id từ headers, key là bank-correlation-id đã được set trong Gateway Server
  @RequestParam String mobileNumber) {
  return new ResponseEntity<>(customerDetailsService.fetchCustomerDetails(correlationId, mobileNumber), headers, HttpStatus.OK); // Trả về response
}
....
```
>`Accounts`: CustomerDetailsService.java
```java
....
  @Autowired
  LoansFeignClient loansFeignClient; // Inject LoansFeignClient vào CustomerDetailsService
  CardsFeignClient cardsFeignClient; // Inject CardsFeignClient vào CustomerDetailsService

  public CustomerDetails fetchCustomerDetails(String correlationId, String mobileNumber) { // Phương thức fetchCustomerDetails
    CustomerDetails customerDetails = new CustomerDetails(); // Tạo ra một đối tượng CustomerDetails
    customerDetails.setCustomerName("John Doe"); // Set tên khách hàng
    customerDetails.setMobileNumber(mobileNumber); // Set số điện thoại
    customerDetails.setLoans(loansFeignClient.fetchLoans(correlation, mobileNumber)); // Gọi api từ LoansFeignClient với việc truyền correlationId, để giúp đồng bộ với Gateway Server, định danh mỗi request
    customerDetails.setCards(cardsFeignClient.fetchCards(correlation, mobileNumber)); // Gọi api từ CardsFeignClient với việc truyền correlationId, để giúp đồng bộ với Gateway Server, định danh mỗi request
    return customerDetails; // Trả về đối tượng CustomerDetails
  }

....
```

Trong `service` loans và cards cũng cần thêm `correlationId` vào `header` của `request` tương tự như `accounts: CustomerDetailsController`. (Vì `OpenFeign` yêu cầu phải giống `signature method` giữa `OpenFeign` và `service` cần gọi). Không cần thêm `correlationId` vào `Service` vì chúng ta chỉ cần `correlationId` trong `Request` trừ khi muốn `OpenFeign` trả về `correlationId` cho các `service` khác.

> Như vậy, chúng ta đã xử lý `Cross-cutting concerns` trong `Spring Cloud Gateway` và `Microservices` thông qua `correlationId`. Khi có một request từ bên ngoài vào trong `Microservices` thông qua `Gateway Server` thì mỗi request sẽ được đánh dấu bởi `correlationId` giúp theo dõi mỗi request nó sẽ đi đến `Microservices` nào.

### 2.6. Tạo file `Docker Compose` để chạy `Gateway Server` và các `Microservices` + `Config Server` + `Eureka Server`
Tham khảo cách tạo `Image` và thiết lập các cấu hình ở phần `22. Build Image Spring Boot.md` và ở phần `## 5. Tạo Docker Compose cho `Spring Cloud Config Server` + `Service` con` của `24. Spring Cloud Config.md`

> Lưu ý: Cần phải bật `Liveness State` và `Readiness State` trong các `Service con` để `Gateway Server` phụ thuộc vào và có thể gọi được các `Service con`. Tránh bị `timeout` khi `Gateway Server` gọi các `Service con`.
>application.yml
```yml
management:
 endpoints:
  web:
   exposure:
    include: "*"
  health:
   readiness-state:
    enabled: true
   liveness-state:
    enabled: true
 endpoint:
  health:
   probes:
    enabled: true
```

Sau khi tạo các `image`. Tạo file `docker-compose.yml` để triển khai.
>docker-compose.yml
```yml
