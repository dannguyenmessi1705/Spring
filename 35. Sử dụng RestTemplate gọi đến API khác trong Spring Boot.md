# Sử dụng RestTemplate gọi đến API khác trong Spring Boot

## 1. Giới thiệu
Trong Spring Boot, ngoài việc sử dụng `OpenFeign`, chúng ta cũng có thể sử dụng `RestTemplate` để gọi đến các API khác. Tuy nhiên, với `RestTemplate` chúng ta cần phải tự cấu hình và sử dụng nó một cách thủ công hơn so với `OpenFeign`. Trong bài viết này, mình sẽ hướng dẫn các bạn cách sử dụng `RestTemplate` để gọi đến các API khác trong Spring Boot.

## 2. So sánh giữa RestTemplate và OpenFeign
### 2.1. RestTemplate
- `RestTemplate` là một HTTP client được cung cấp bởi Spring.
- `RestTemplate` không cung cấp annotation để định nghĩa các API endpoint như `OpenFeign`.
- `RestTemplate` cần phải được cấu hình thủ công (như Header, Body, Timeout, Method, …).

### 2.2. OpenFeign
- `OpenFeign` là một HTTP client được cung cấp bởi Netflix.
- `OpenFeign` cung cấp annotation để định nghĩa các API endpoint.
- `OpenFeign` chỉ cần định nghĩa interface và sử dụng annotation để định nghĩa các API endpoint. Các request sẽ được tự động tạo ra.
- `OpenFeign` hạn chế về việc cấu hình (như Header, Body, Timeout, Method, …). Hạn chế tính linh hoạt do không thể cấu hình một cách tùy biến mà phụ thuộc vào `controller` của service client được gọi đến.

## 3. Sử dụng RestTemplate
### 3.1. Thêm dependency
Để sử dụng `RestTemplate`, chúng ta cần phải thêm dependency `spring-boot-starter-web` vào file `pom.xml`.

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
</dependency>
```

### 3.2. Cấu hình RestTemplate
#### 3.2.1. Cấu hình RestTemplate bean, đinh nghĩa RestTemplate bean trong file `@Configuration`.
> `RestTemplateConfig.java`
```java
package com.didan.spring_payment.config;

import com.didan.spring_payment.exception.GlobalException;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.HttpComponentsClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;

@Configuration
@Slf4j
@Data
public class RestTemplateConfig {

  @Bean
  public RestTemplate clientRequestRestTemplate(){
    HttpComponentsClientHttpRequestFactory factory = new HttpComponentsClientHttpRequestFactory(); // Tạo một factory để cấu hình RestTemplate
    factory.setConnectTimeout(5000); // Thời gian kết nối tối đa là 5s
    factory.setConnectionRequestTimeout(5000); // Thời gian chờ kết nối tối đa là 5s
    RestTemplate restTemplate = new RestTemplate(factory); // Tạo RestTemplate với factory đã cấu hình
    restTemplate.setErrorHandler(new GlobalException()); // Xử lý exception khi gọi API (nếu có định nghĩa các Error Handler) đã trình bày ở bài 15, mục #4.4
    return restTemplate; // Trả về RestTemplate đã cấu hình
  }
}
```

#### 3.2.2. Sử dụng RestTemplate cho việc gọi API với Response là một Class đơn giản
Nếu API trả về một `Class` đơn giản, các trường chỉ đơn thuần là các kiểu dữ liệu nguyên thủy, chúng ta có thể sử dụng `RestTemplate` với hàm `exchange` để gọi API như sau:
> `RestTemplateServiceImpl.java`
```java
package com.didan.spring_payment.service.impl;

import com.didan.spring_payment.exception.ResourceNotFound;
import com.didan.spring_payment.service.IRestTemplateService;
import java.util.List;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.HttpServerErrorException;
import org.springframework.web.client.ResourceAccessException;
import org.springframework.web.client.RestTemplate;

@Service
@Slf4j
@RequiredArgsConstructor
public class RestTemplateServiceImpl implements IRestTemplateService {
  private final RestTemplate restTemplate;

    // Hàm gọi API với Response là một Class đơn giản
  @Override 
  public <T> ResponseEntity<T> process(HttpMethod httpMethod, String url, HttpHeaders httpHeaders,
      Object requestBody, Class<T> responseType) {
    if(httpHeaders == null) { // Nếu không có Header thì tạo mới
      httpHeaders = new HttpHeaders(); // Tạo mới Header
      httpHeaders.put("Content-Type", List.of("application/json")); // Thêm Content-Type vào Header
      httpHeaders.put("Accept", List.of("application/json")); // Thêm Accept vào Header
    }
    try { // Thực hiện gọi API
      ResponseEntity<T> responseEntity = restTemplate.exchange(url, httpMethod, new HttpEntity<>(requestBody, httpHeaders), responseType); // Gọi API, sử dụng hàm exchange của RestTemplate
      return responseEntity; // Trả về kết quả
    } catch (HttpClientErrorException | HttpServerErrorException ex) { // Bắt exception khi gọi API
      throw new ResourceNotFound(ex.getMessage()); // Ném ra exception ResourceNotFound
    } catch (ResourceAccessException ex) { // Bắt exception khi kết nối bị timeout
      log.error("Connection timeout"); // Log lỗi
      throw new ResourceNotFound(ex.getMessage()); // Ném ra exception ResourceNotFound
    }
  }
}
```

Kết quả trả về sẽ là một `ResponseEntity<T>`, trong đó `T` là kiểu dữ liệu của `responseType`.

#### 3.2.3. Sử dụng RestTemplate cho việc gọi API với Response là một ParameterizedTypeReference (List, Map, Class phức tạp)
Nếu API trả về một `List`, `Map`, hoặc `Class` phức tạp, chúng ta cần sử dụng `ParameterizedTypeReference` để xử lý.
> `RestTemplateServiceImpl.java`
```java
package com.didan.spring_payment.service.impl;

import com.didan.spring_payment.exception.ResourceNotFound;
import com.didan.spring_payment.service.IRestTemplateService;
import java.util.List;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.HttpServerErrorException;
import org.springframework.web.client.ResourceAccessException;
import org.springframework.web.client.RestTemplate;

@Service
@Slf4j
@RequiredArgsConstructor
public class RestTemplateServiceImpl implements IRestTemplateService {
  private final RestTemplate restTemplate;

    // Hàm gọi API với Response là một ParameterizedTypeReference

  @Override
  public <T> ResponseEntity<T> processParameterizedType(HttpMethod httpMethod, String url,
      HttpHeaders httpHeaders, Object requestBody,
      ParameterizedTypeReference<T> parameterizedTypeReference) {
    if (httpHeaders == null) { // Nếu không có Header thì tạo mới
      httpHeaders = new HttpHeaders();
      httpHeaders.put("Content-Type", List.of("application/json"));
      httpHeaders.put("Accept", List.of("application/json"));
    }
    try { // Thực hiện gọi API
        ResponseEntity<T> responseEntity = restTemplate.exchange(url, httpMethod, new HttpEntity<>(requestBody, httpHeaders), parameterizedTypeReference); // Gọi API, sử dụng hàm exchange của RestTemplate
        return responseEntity; // Trả về kết quả
    } catch (HttpClientErrorException | HttpServerErrorException ex) { // Bắt exception khi gọi API
      throw new ResourceNotFound(ex.getMessage()); // Ném ra exception ResourceNotFound
    } catch (ResourceAccessException ex) { // Bắt exception khi kết nối bị timeout
      log.error("Connection timeout"); // Log lỗi
      throw new ResourceNotFound(ex.getMessage()); // Ném ra exception ResourceNotFound
    }
  }
}
```

Kết quả trả về sẽ là một `ResponseEntity<T>`, trong đó `T` là kiểu dữ liệu của `parameterizedTypeReference`.

## 3.3. Dùng RestTemplate để gọi API
### 3.3.1. Gọi API với Response là một Class đơn giản
> `RestTemplateController.java`
```java
ResponseEntity<Payment> responseEntity = restTemplateService.process(HttpMethod.GET, "http://localhost:8080/api/v1/payment/1", null, null, Payment.class);

Payment payment = responseEntity.getBody();
```

### 3.3.2. Gọi API với Response là một ParameterizedTypeReference
> `RestTemplateController.java`
```java
ParameterizedTypeReference<List<Payment>> parameterizedTypeReference = new ParameterizedTypeReference<List<Payment>>() {};
ResponseEntity<List<Payment>> responseEntity = restTemplateService.processParameterizedType(HttpMethod.GET, "http://localhost:8080/api/v1/payment", null, null, parameterizedTypeReference);

List<Payment> payments = responseEntity.getBody();
```
