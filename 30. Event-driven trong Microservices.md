# Event-driven trong Microservices
## 1. Giới thiệu
### 1.1. Temporal Coupling
Cần tránh `Temporal Coupling` (phụ thuộc thời gian) giữa các service bất cứ khi nào có thể:
- `Temporal Coupling` xảy ra khi một `service gọi` mong muốn phản hồi ngay lập tức từ `service được gọi` trước khi tiếp tục xử lý công việc của nó. Nếu `service được gọi` gặp bất kỳ sự chậm trễ nào trong việc phản hồi, điều đó sẽ làm ảnh hưởng tiêu cực tới thời gian phản hồi chung của `service gọi`.
- Kịch bản này thường xuyên xảy ra trong quá trình trao đổi dữ liệu giữa các service trong một hệ thống Microservices.

### 1.2. Asynchronous Communication
`Syncronous Communication` (giao tiếp đồng bộ) giữa các service không phải lúc nào cũng là lựa chọn tốt.

Trong nhiều tình huống thực tế, `Asynchronous Communication` (giao tiếp bất đồng bộ) là lựa chọn tốt hơn. `Asynchronous Communication` có thể đáp ứng các yêu cầu một cách hiệu quả.

### 1.3. Building event-driven Microservices
Một sự kiện, cũng như một sự cố, biểu thị một sự kiện quan trọng xảy ra trong hệ thống. Sự kiện có thể là bất kỳ hành động nào mà một service thực hiện, hoặc một sự kiện ngoại lệ xảy ra trong hệ thống, như việc chuyển đổi các trạng thái của một service.

Nhiều nguồn có thể tạo ra sự kiện. Khi sự kiện xảy ra, nó có thể cảnh báo cho các bên liên quan.

`Event-driven Microservices` có thể được xây dựng nhờ sử dụng:
- `Event-driven Architecture`: là một kiến trúc phần mềm mà các thành phần của nó giao tiếp với nhau bằng cách gửi và nhận các sự kiện.
- `Producing and consuming events using Asynchronous Communication`: các service có thể tạo ra sự kiện và tiêu thụ sự kiện sử dụng giao tiếp bất đồng bộ.
- `Event brokers`: là một phần mềm giữa các service, giúp chuyển tiếp sự kiện từ service này sang service khác.
- `Spring Cloud Function`: là một dự án Spring Cloud giúp xây dựng các service dựa trên các hàm Spring.
- `Spring Cloud Stream`: là một dự án Spring Cloud giúp xây dựng các service dựa trên các luồng dữ liệu.

#### 1.3.1. Event-driven Architecture
`Event-driven Architecture` là một kiến trúc phần mềm mà các thành phần của nó giao tiếp với nhau bằng cách gửi và nhận các sự kiện.

Có `2` loại mô hình chính trong `Event-driven Architecture`:
- `Publisher/Subcriber (Pub/Sub) Model`: Mô hình này sẽ xoay quanh việc `subcription`. `Producer` sẽ tạo ra các sự kiện, nó được phân phối tới tất cả các `subcriber` để tiêu thụ. Khi 1 `event` đã được nhận, nó không thể được phân phối lại nữa, nghĩa là những `subcriber` tham gia sau khi `event` đã được phân phối sẽ không nhận được các `event` đã được phân phối trước đó (`pass event`). Mô hình này được sử dụng trong **`RABBITMQ`**.
- `Event Streaming Model`: Trong mô hình này, các `event` sẽ được ghi vào `log` một cách tuần tự. `Producer` xuất bản các `event` khi chúng xảy ra và các `event` này sẽ được lưu trữ theo thứ tự 1 cách hợp lý. Thay vì việc phải `subcribe` vào các `event`, `consumer` có thể đọc từ bất kỳ phần nào của `event stream`. Một lợi thế của mô hình này là `event` có thể được phát, đọc và xử lý nhiều lần, cho phép `client` tham gia bất kỳ lúc nào cũng có thể đọc được `event` đã được phát trước đó. Mô hình này được sử dụng trong **`KAFKA`**.