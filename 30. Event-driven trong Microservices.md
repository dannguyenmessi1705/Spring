# Event-driven trong Microservices
## 1. Giới thiệu
### 1.1. Temporal Coupling
Cần tránh `Temporal Coupling` (phụ thuộc thời gian) giữa các service bất cứ khi nào có thể:
- `Temporal Coupling` xảy ra khi một `service gọi` mong muốn phản hồi ngay lập tức từ `service được gọi` trước khi tiếp tục xử lý công việc của nó. Nếu `service được gọi` gặp bất kỳ sự chậm trễ nào trong việc phản hồi, điều đó sẽ làm ảnh hưởng tiêu cực tới thời gian phản hồi chung của `service gọi`.
- Kịch bản này thường xuyên xảy ra trong quá trình trao đổi dữ liệu giữa các service trong một hệ thống Microservices.

### 1.2. Asynchronous Communication
`Syncronous Communication` (giao tiếp đồng bộ) giữa các service không phải lúc nào cũng là lựa chọn tốt.

Trong nhiều tình huống thực tế, `Asynchronous Communication` (giao tiếp bất đồng bộ) là lựa chọn tốt hơn. `Asynchronous Communication` có thể đáp ứng các yêu cầu một cách hiệu quả.

### 1.3. Building event-driven Microservices
Một sự kiện, cũng như một sự cố, biểu thị một sự kiện quan trọng xảy ra trong hệ thống. Sự kiện có thể là bất kỳ hành động nào mà một service thực hiện, hoặc một sự kiện ngoại lệ xảy ra trong hệ thống, như việc chuyển đổi các trạng thái của một service.

Nhiều nguồn có thể tạo ra sự kiện. Khi sự kiện xảy ra, nó có thể cảnh báo cho các bên liên quan.

`Event-driven Microservices` có thể được xây dựng nhờ sử dụng:
- `Event-driven Architecture`: là một kiến trúc phần mềm mà các thành phần của nó giao tiếp với nhau bằng cách gửi và nhận các sự kiện.
- `Producing and consuming events using Asynchronous Communication`: các service có thể tạo ra sự kiện và tiêu thụ sự kiện sử dụng giao tiếp bất đồng bộ.
- `Event brokers`: là một phần mềm giữa các service, giúp chuyển tiếp sự kiện từ service này sang service khác.
- `Spring Cloud Function`: là một dự án Spring Cloud giúp xây dựng các service dựa trên các hàm Spring.
- `Spring Cloud Stream`: là một dự án Spring Cloud giúp xây dựng các service dựa trên các luồng dữ liệu.

#### 1.3.1. Event-driven Architecture
`Event-driven Architecture` là một kiến trúc phần mềm mà các thành phần của nó giao tiếp với nhau bằng cách gửi và nhận các sự kiện.

Có `2` loại mô hình chính trong `Event-driven Architecture`:
- `Publisher/Subcriber (Pub/Sub) Model`: Mô hình này sẽ xoay quanh việc `subcription`. `Producer` sẽ tạo ra các sự kiện, nó được phân phối tới tất cả các `subcriber` để tiêu thụ. Khi 1 `event` đã được nhận, nó không thể được phân phối lại nữa, nghĩa là những `subcriber` tham gia sau khi `event` đã được phân phối sẽ không nhận được các `event` đã được phân phối trước đó (`pass event`). Mô hình này được sử dụng trong **`RABBITMQ`**.
- `Event Streaming Model`: Trong mô hình này, các `event` sẽ được ghi vào `log` một cách tuần tự. `Producer` xuất bản các `event` khi chúng xảy ra và các `event` này sẽ được lưu trữ theo thứ tự 1 cách hợp lý. Thay vì việc phải `subcribe` vào các `event`, `consumer` có thể đọc từ bất kỳ phần nào của `event stream`. Một lợi thế của mô hình này là `event` có thể được phát, đọc và xử lý nhiều lần, cho phép `client` tham gia bất kỳ lúc nào cũng có thể đọc được `event` đã được phát trước đó. Mô hình này được sử dụng trong **`KAFKA`**.

#### 1.3.2. RabbitMQ
`RabbitMQ` là một `message broker` mã nguồn mở được xây dựng trên `Erlang`. Nó được công nhận rộng rãi nhờ sử dụng `AMQP` (Advanced Message Queuing Protocol) làm giao thức truyền thông và khả năng cung cấp các `asynchronous messaging` linh hoạt, triển khai phân tán và giám sát toàn diện.

Khi sử dụng các solution dựa trên `AMQP`, `RabbitMQ` sẽ phân loại những bên tham gia thành các đối tượng sau:
- `Producer`: là bên tạo ra `message` và gửi nó tới `RabbitMQ` (publisher).
- `Consumer`: là bên nhận `message` từ `RabbitMQ` (subscriber).
- `Message Broker`: là `RabbitMQ` server chịu trách nhiệm nhận và phân phối `message` giữa `producer` và `consumer`.

Mô hình `AMQP` hoạt động dựa trên nguyên tắc `exchange` và `queue`:
1. `Producer` sẽ gửi `message` tới `exchange`.
2. `exchange` sẽ định tuyến `message` tới `queue` theo các quy tắc đã được cấu hình, và bản sao của `message` sẽ được lưu trữ trong `queue`.
3. `consumer` sẽ nhận `message` từ `queue`. Mỗi `message` chỉ được `consumer` nhận một lần và mỗi một `consumer` chỉ nhận `message` từ một `queue`.

#### 1.3.3. Spring Cloud Function
`Spring Cloud Function` là một dự án Spring Cloud giúp xây dựng các service dựa trên các hàm Spring, tuân thủ theo các giao diện tiêu chuẩn như `Supplier`, `Function`, `Consumer`.
- `Supplier`: là một hàm `không nhận tham số đầu vào` và `trả về một giá trị`.
- `Function`: là một hàm `nhận một tham số đầu vào` và `trả về một giá trị`. Thường được gọi là một bộ xử lý.
- `Consumer`: là một hàm `nhận một tham số đầu vào` và `không trả về giá trị`. Thường được gọi là thuê bao hoặc bộ tiêu thụ.

Các tính năng chính của `Spring Cloud Function`:
- Lựa chọn về kiểu lập trình như `reactive`, `imperative`, `hybrid`.
- `POJO Functions`: nếu có gì đó phù hợp với ngữ nghĩa `@FunctionalInterface` thì nó có thể được sử dụng như một `Function`.
- `Functional Composition`: hỗ trợ việc kết hợp các `imperative` và `reactive` functions.
- Hỗ trợ `REST` trong việc hiển thị các `Function` dưới dạng `Endpoint`.
- `Streaming data` (thông qua Apache Kafka, RabbitMQ, Solace) đến/từ các `Function` thông qua `Spring Cloud Stream`.
- Đóng gói các `Function` cho quá trình `deployment`, dành riêng cho nền tảng đích (như `AWS Lambda`, `Azure Functions`, `Google Cloud Functions`, hoặc các nhà cung cấp không có máy chủ).

## 2. Xây dựng `Message Microservices` với `Spring Cloud Function`.
### 2.1. Cài đặt thư viện.
Để sử dụng `Spring Cloud Function`, chúng ta cần thêm các dependency sau vào file `pom.xml`:
1. `spring-cloud.version`: phiên bản của `Spring Cloud` vào `properties` của `pom.xml`.
2. Bộ quản lý dependency của `Spring Cloud` vào `dependencyManagement` của `pom.xml`.
3. `spring-cloud-function-context`: thư viện chính của `Spring Cloud Function`.
>pom.xml
```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-function-context</artifactId>
</dependency>
```
4. (OPTIONAL) `spring-cloud-starter-function-web`: thư viện hỗ trợ việc xây dựng `RESTful API` cho các `Function`, `Supplier`, `Consumer`. Có thể tùy chọn thêm vào `pom.xml` nếu cần show các `Function` dưới dạng `Endpoint`. Ví dụ tên `Function` là `uppercase`, khi thêm thư viện này, chúng ta có thể truy cập `uppercase` thông qua `http://localhost:8080/uppercase`.
>pom.xml
```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-function-web</artifactId>
</dependency>
```

### 2.2. Xây dựng `Function`.
1. Đầu tiên chúng ta cần tạo ra 1 `DTO` class để định nghĩa dữ liệu đầu vào và dữ liệu đầu ra của `Function`. Dùng để giao tiếp với `Message Broker`.
>dto/AccountsMsgDto.java
```java
...
public record AccountsMsgDto(Long accountNumber, String name, String email, String mobileNumber) {}
```

2. Tiếp theo, chúng ta sẽ tạo ra các `@Bean` `Function` trong một class được đánh dấu là `@Configuration` để `Spring` có thể quét và tạo ra các `Bean` từ `Function` để xử lý dữ liệu. Các `logical` xử lý dữ liệu sẽ được viết bằng `Lambda Expression`. Có các loại `FunctionalInterface` sau:
    - `Function<T, R>`: nhận vào `T` và trả về `R`: Hoạt động với Method `POST`. `...return T -> { return R; }`
    - `Supplier<R>`: không nhận vào và trả về `R`: Hoạt động với Method `GET`. `...return () -> { return R; }`
    - `Consumer<T>`: nhận vào `T` và không trả về: Hoạt động với Method `POST`. `... return (T) -> { ... }`

>functions/MessageFunctions.java
```java
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration // Đánh dấu lớp này là một lớp cấu hình Spring, tạo ra các bean
public class MessageFunctions {
  private final Logger logger = LoggerFactory.getLogger(getClass());
  @Bean // Đánh dấu phương thức này là một bean
  public Function<AccountsMsgDto, AccountsMsgDto> email() { // Tạo ra một bean kiểu Function với đầu vào và đầu ra là AccountsMsgDto, endpoint là /email
    return accountsMsgDto -> { // accountsMsgDto là đầu vào của hàm
      logger.info("Sending email to: " + accountsMsgDto.toString());
      return accountsMsgDto; // Trả về đầu ra của hàm 
    }; // Phải được viết bằng Lambda Expression (->)
  }

  @Bean
  public Function<AccountsMsgDto, Long> sms() { // Tạo ra một bean kiểu Function với đầu vào là AccountsMsgDto và đầu ra là Long, endpoint là /sms
    return accountsMsgDto -> { // accountsMsgDto là đầu vào của hàm
      logger.info("Sending SMS to: " + accountsMsgDto.toString());
      return accountsMsgDto.accountNumber(); // Trả về đầu ra của hàm 
    }; // Phải được viết bằng Lambda Expression (->)
  }

  @Bean
  public Supplier<String> name() { // Tạo ra một bean kiểu Supplier với đầu ra là String, endpoint là /name
    return () -> { // Đầu vào của hàm là rỗng
      logger.info("Getting name example");
      return "John Doe"; // Trả về đầu ra của hàm
    }; // Phải được viết bằng Lambda Expression (->)
  }

  @Bean
  public Consumer<String> print() { // Tạo ra một bean kiểu Consumer với đầu vào là String, endpoint là /print
    return s -> logger.info("Printing: " + s); // s là đầu vào của hàm, và trong Lambda Expression (->) không có return
  }
}
```

Nếu sử dụng thư viện `spring-cloud-starter-function-web`, chúng ta có thể truy cập các `Function` thông qua `Endpoint`:
- `http://localhost:8080/email`
- `http://localhost:8080/sms`
- `http://localhost:8080/name`
- `http://localhost:8080/print`

Ngoài ra chúng ta có thể gộp 2 hoặc nhiều `Function` thành một `Function` lớn bằng cách cấu hình trong `application.yml`, các tên `Function` sẽ được phân cách bằng dấu `|`.
> Lúc này, endpoint của `Function` lớn sẽ là gộp tên của các `Function` thành một chuỗi, ví dụ `/emailsms` hoặc `/smsemail` hoặc `/emailsmssmsemail`. Và đặc biệt nó sẽ thực hiện `logical` của các `Function` cùng một lúc.
>application.yml
```yml
spring:
  cloud:
    function:
      definition: email|sms # Gộp 2 Function email và sms thành một Function lớn, endpoint là /emailsms hoặc /smsemail hoặc /emailsmssmsemail.... đồng thời thực hiện logical của cả 2 Function email và sms
```
