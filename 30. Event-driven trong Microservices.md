# Event-driven trong Microservices
## 1. Giới thiệu
### 1.1. Temporal Coupling
Cần tránh `Temporal Coupling` (phụ thuộc thời gian) giữa các service bất cứ khi nào có thể:
- `Temporal Coupling` xảy ra khi một `service gọi` mong muốn phản hồi ngay lập tức từ `service được gọi` trước khi tiếp tục xử lý công việc của nó. Nếu `service được gọi` gặp bất kỳ sự chậm trễ nào trong việc phản hồi, điều đó sẽ làm ảnh hưởng tiêu cực tới thời gian phản hồi chung của `service gọi`.
- Kịch bản này thường xuyên xảy ra trong quá trình trao đổi dữ liệu giữa các service trong một hệ thống Microservices.

### 1.2. Asynchronous Communication
`Syncronous Communication` (giao tiếp đồng bộ) giữa các service không phải lúc nào cũng là lựa chọn tốt.

Trong nhiều tình huống thực tế, `Asynchronous Communication` (giao tiếp bất đồng bộ) là lựa chọn tốt hơn. `Asynchronous Communication` có thể đáp ứng các yêu cầu một cách hiệu quả.

### 1.3. Building event-driven Microservices
Một sự kiện, cũng như một sự cố, biểu thị một sự kiện quan trọng xảy ra trong hệ thống. Sự kiện có thể là bất kỳ hành động nào mà một service thực hiện, hoặc một sự kiện ngoại lệ xảy ra trong hệ thống, như việc chuyển đổi các trạng thái của một service.

Nhiều nguồn có thể tạo ra sự kiện. Khi sự kiện xảy ra, nó có thể cảnh báo cho các bên liên quan.

`Event-driven Microservices` có thể được xây dựng nhờ sử dụng:
- `Event-driven Architecture`: là một kiến trúc phần mềm mà các thành phần của nó giao tiếp với nhau bằng cách gửi và nhận các sự kiện.
- `Producing and consuming events using Asynchronous Communication`: các service có thể tạo ra sự kiện và tiêu thụ sự kiện sử dụng giao tiếp bất đồng bộ.
- `Event brokers`: là một phần mềm giữa các service, giúp chuyển tiếp sự kiện từ service này sang service khác.
- `Spring Cloud Function`: là một dự án Spring Cloud giúp xây dựng các service dựa trên các hàm Spring.
- `Spring Cloud Stream`: là một dự án Spring Cloud giúp xây dựng các service dựa trên các luồng dữ liệu.

#### 1.3.1. Event-driven Architecture
`Event-driven Architecture` là một kiến trúc phần mềm mà các thành phần của nó giao tiếp với nhau bằng cách gửi và nhận các sự kiện.

Có `2` loại mô hình chính trong `Event-driven Architecture`:
- `Publisher/Subcriber (Pub/Sub) Model`: Mô hình này sẽ xoay quanh việc `subcription`. `Producer` sẽ tạo ra các sự kiện, nó được phân phối tới tất cả các `subcriber` để tiêu thụ. Khi 1 `event` đã được nhận, nó không thể được phân phối lại nữa, nghĩa là những `subcriber` tham gia sau khi `event` đã được phân phối sẽ không nhận được các `event` đã được phân phối trước đó (`pass event`). Mô hình này được sử dụng trong **`RABBITMQ`**.
- `Event Streaming Model`: Trong mô hình này, các `event` sẽ được ghi vào `log` một cách tuần tự. `Producer` xuất bản các `event` khi chúng xảy ra và các `event` này sẽ được lưu trữ theo thứ tự 1 cách hợp lý. Thay vì việc phải `subcribe` vào các `event`, `consumer` có thể đọc từ bất kỳ phần nào của `event stream`. Một lợi thế của mô hình này là `event` có thể được phát, đọc và xử lý nhiều lần, cho phép `client` tham gia bất kỳ lúc nào cũng có thể đọc được `event` đã được phát trước đó. Mô hình này được sử dụng trong **`KAFKA`**.

#### 1.3.2. RabbitMQ
`RabbitMQ` là một `message broker` mã nguồn mở được xây dựng trên `Erlang`. Nó được công nhận rộng rãi nhờ sử dụng `AMQP` (Advanced Message Queuing Protocol) làm giao thức truyền thông và khả năng cung cấp các `asynchronous messaging` linh hoạt, triển khai phân tán và giám sát toàn diện.

Khi sử dụng các solution dựa trên `AMQP`, `RabbitMQ` sẽ phân loại những bên tham gia thành các đối tượng sau:
- `Producer`: là bên tạo ra `message` và gửi nó tới `RabbitMQ` (publisher).
- `Consumer`: là bên nhận `message` từ `RabbitMQ` (subscriber).
- `Message Broker`: là `RabbitMQ` server chịu trách nhiệm nhận và phân phối `message` giữa `producer` và `consumer`.

Mô hình `AMQP` hoạt động dựa trên nguyên tắc `exchange` và `queue`:
1. `Producer` sẽ gửi `message` tới `exchange`.
2. `exchange` sẽ định tuyến `message` tới `queue` theo các quy tắc đã được cấu hình, và bản sao của `message` sẽ được lưu trữ trong `queue`.
3. `consumer` sẽ nhận `message` từ `queue`. Mỗi `message` chỉ được `consumer` nhận một lần và mỗi một `consumer` chỉ nhận `message` từ một `queue`.

#### 1.3.3. Spring Cloud Function
`Spring Cloud Function` là một dự án Spring Cloud giúp xây dựng các service dựa trên các hàm Spring, tuân thủ theo các giao diện tiêu chuẩn như `Supplier`, `Function`, `Consumer`.
- `Supplier`: là một hàm `không nhận tham số đầu vào` và `trả về một giá trị`.
- `Function`: là một hàm `nhận một tham số đầu vào` và `trả về một giá trị`. Thường được gọi là một bộ xử lý.
- `Consumer`: là một hàm `nhận một tham số đầu vào` và `không trả về giá trị`. Thường được gọi là thuê bao hoặc bộ tiêu thụ.

Các tính năng chính của `Spring Cloud Function`:
- Lựa chọn về kiểu lập trình như `reactive`, `imperative`, `hybrid`.
- `POJO Functions`: nếu có gì đó phù hợp với ngữ nghĩa `@FunctionalInterface` thì nó có thể được sử dụng như một `Function`.
- `Functional Composition`: hỗ trợ việc kết hợp các `imperative` và `reactive` functions.
- Hỗ trợ `REST` trong việc hiển thị các `Function` dưới dạng `Endpoint`.
- `Streaming data` (thông qua Apache Kafka, RabbitMQ, Solace) đến/từ các `Function` thông qua `Spring Cloud Stream`.
- Đóng gói các `Function` cho quá trình `deployment`, dành riêng cho nền tảng đích (như `AWS Lambda`, `Azure Functions`, `Google Cloud Functions`, hoặc các nhà cung cấp không có máy chủ).
