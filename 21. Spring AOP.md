# Spring AOP (Aspect-Oriented Programming)
## 1. Giới thiệu
- `Spring AOP` là một phần của `Spring Framework` giúp chúng ta tách biệt các phần của ứng dụng, giúp chúng ta dễ dàng quản lý và bảo trì ứng dụng hơn.
- `Spring AOP` giúp chúng ta tách biệt các phần của ứng dụng như logging, transaction, security, caching, ...
- `Spring AOP` không phải là một `OOP` (Object-Oriented Programming) mà nó là một `AOP` (Aspect-Oriented Programming).

## 2. Khái niệm
- `Aspect`: Là một module chứa các `Advice` và `Pointcut`.
    + `Advice`: Là một hành động được thực thi trước, sau hoặc xung quanh một `Join Point`.
    + `Pointcut`: Là một điểm trong ứng dụng nơi mà chúng ta muốn thực thi `Advice`.
- `Join Point`: Là một điểm trong ứng dụng nơi mà chúng ta có thể thực thi `Advice`.
- `Weaving`: Là framework `AOP` sử dụng `Weaving` để kết hợp `Aspect` với `Join Point` để tạo ra `Advice`. (`Spring AOP` hoặc `AspectJ`).

## 3. Cách thức hoạt động
- `Spring AOP` hoạt động theo các bước sau:
    - Bước 1: Xác định `Aspect` và `Join Point`.
    - Bước 2: Xác định `Advice`.
    - Bước 3: Xác định `Pointcut`.
    - Bước 4: Kết hợp `Aspect` với `Join Point` để tạo ra `Advice`.
    - Bước 5: Thực thi `Advice`.

## 4. Các framework hỗ trợ `AOP`
### 4.1. Spring AOP
- `Spring AOP` không hoàn toàn là `AOP` mà nó chỉ hỗ trợ một số tính năng cơ bản của `AOP`, nhưng nó lại được sử dụng rộng rãi trong các ứng dụng `Spring`.
- `Spring AOP` chỉ hoạt động với các `Spring Bean`.
- VD: Phương thức Intercept gọi tới một `Spring Bean`, Logging, Transaction management, Security, Caching, ...

### 4.2. AspectJ
- `AspectJ` là một framework `AOP` mạnh mẽ hơn `Spring AOP` nhưng lại it được sử dụng hơn.
- `AspectJ` hoạt động với bất kỳ đối tượng nào trong ứng dụng.
- VD: Bất kỳ phương thức Intercept nào cũng có thể gọi đến bất kỳ file nào, không giới hạn với `Spring Bean`.

## 5. Cấu hình `Spring AOP`
### 5.1. Thêm `Spring AOP` dependency
```xml
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-aop</artifactId>
		</dependency>
```

### 5.2. Tạo `Aspect`
- Tạo một class và đánh dấu `@Aspect` và `@Configuration`.
- Tạo các `Advice` và `Pointcut`.
- Các `PointCut` có thể là:
    + `@Before`: Thực thi trước khi phương thức được gọi.
    + `@After`: Thực thi sau khi phương thức được gọi (không quan tâm kết quả trả về).
    + `@AfterReturning`: Thực thi sau khi phương thức được gọi và trả về kết quả.
    + `@AfterThrowing`: Thực thi sau khi phương thức được gọi và ném ra một ngoại lệ.
    + `@Around`: Thực thi trước và sau khi phương thức được gọi (Dùng `ProceedingJoinPoint`).
- Tham số truyền vào `@Before`, `@After`, `@AfterReturning`, `@AfterThrowing` là `Pointcut`:
    + `execution(* com.example.demo.service.*.*(..))`: Chặn tất cả các phương thức trong package `com.example.demo.service`.
    + `execution(* com.example.demo.service.*.get*(..))`: Chặn tất cả các phương thức trong package `com.example.demo.service` bắt đầu bằng `get`.
    + `execution(* com.example.demo.service.*.*(int))`: Chặn tất cả các phương thức trong package `com.example.demo.service` có một tham số kiểu `int`.
    + `execution(* com.example.demo.service.*.*(int, *))`: Chặn tất cả các phương thức trong package `com.example.demo.service` có hai tham số, tham số thứ nhất kiểu `int`.
    + `execution(* com.example.demo.service.*.*(int, ..))`: Chặn tất cả các phương thức trong package `com.example.demo.service` có ít nhất một tham số kiểu `int`.
    + `execution(int com.example.demo.service.*.*(..))`: Chặn tất cả các phương thức trong package `com.example.demo.service` trả về kiểu `int`.
    + `execution(bean(*Service*))`: Chặn tất cả các phương thức của các `Spring Bean` có annotation `Service`.
    + `annotation(org.springframework.web.bind.annotation.GetMapping)`: Chặn tất cả các phương thức có annotation `GetMapping`.
- VD: Logging, Transaction management, Security, Caching, ...

>LoggingAspect.java
```java
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.JoinPoint;
import org.springframework.stereotype.Configuration;

@Configuration
@Aspect
public class LoggingAspect {
    @Before("execution(* com.example.demo.service.*.*(..))") // (Pointcut)
    public void logBefore(JoinPoint join) { // JoinPoint là một interface trong AspectJ, nó cung cấp thông tin về method được gọi
        System.out.println("Logging before method {}", join); // Logging ra method trước khi thực thi (Advice)
    }

    @AfterThrowing(pointcut = "execution(* com.didan.learn_spring_aop.service.*.*(..))", 
			       throwing = "ex") // Tạo Pointcut cho method trong package service khi method ném ra 1 ngoại lệ
	public void afterThrowing(JoinPoint joinPoint, Exception ex) { // Annotation AfterThrowing sẽ chạy khi method gặp lỗi
		logger.error("Call AfterThrowing - Method is called {} with exception {}", joinPoint, ex);
	}

    @AfterReturning(pointcut = "execution(* com.didan.learn_spring_aop.service.*.*(..))", 
                    returning = "result") // Tạo Pointcut cho method trong package service khi method trả về kq
	public void afterReturning(JoinPoint joinPoint, Object result) { // Annotation AfterReturning sẽ chạy khi method trả về kết quả
		logger.info("Call AfterReturning - Method is called {} with result {}", joinPoint, result);
	}
}
```
> Lưu ý: Khi sử dụng annotation `@Around`, chúng ta cần truyền vào tham số `ProceedingJoinPoint` thay vì `JoinPoint` vì `ProceedingJoinPoint` cung cấp phương thức `proceed()` để thực thi phương thức gốc, còn `JoinPooint` chỉ cung cấp thông tin về method được gọi. Ngoài ra chúng ta cũng cần trả về kết quả của phương thức gốc với kiểu `Object`.

```java
	@Around("execution(* com.didan.learn_spring_aop.service.*.*(..))") // Tạo Pointcut cho method trong package service)
	public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        // Trước khi thực thi method
		long startTime = System.currentTimeMillis(); // Lấy thời gian hiện tại
		
        // Thực thi method
		Object result = proceedingJoinPoint.proceed(); // Chạy method được đánh dấu bởi Pointcut
		
        // Sau khi thực thi method
		long endTime = System.currentTimeMillis(); // Lấy thời gian sau khi chạy method
		
		logger.info("Call Around - Method is called {} with time {}ms", proceedingJoinPoint, endTime - startTime);
		
		return result; // Trả về kết quả của method
		
	}
```

### 5.3. Thủ thuật khi sử dụng `Spring AOP`
Bởi vì mỗi `Pointcut` có thể `execution` đến nhiều `package`, một khi `package` đó thay đổi tên, chúng ta sẽ phải thay đổi tất cả các `Pointcut` đó. Để giải quyết vấn đề này, chúng ta có thể sử dụng `@Pointcut` để định nghĩa một `Pointcut` và sử dụng nó ở nhiều `Advice` khác nhau.

>PoincutConfig.java
```java
// KHI THAY ĐỔI TÊN PACKAGE, CHỈ CẦN THAY ĐỔI Ở ĐÂY
import org.aspectj.lang.annotation.Aspect;

@Configuration
@Aspect
public class PointcutConfig {
    @Pointcut("execution(* com.example.demo.service.*.*(..))")
    public void serviceLayer() {
    } // Định nghĩa Pointcut cho các method trong package service

    @Pointcut("execution(* com.example.demo.repository.*.*(..))")
    public void repositoryLayer() {
    } // Định nghĩa Pointcut cho các method trong package repository
}
```

>LoggingAspect.java
```java
// GỌI ĐẾN POINTCUT ĐÃ ĐƯỢC ĐỊNH NGHĨA, LƯU Ý ĐỂ KHÔNG PHẢI VIẾT LẠI EXECUTION VÌ ĐÃ ĐƯỢC ĐỊNH NGHĨA CLASS PointcutConfig
import org.aspectj.lang.annotation.Aspect;

@Configuration
@Aspect
public class LoggingAspect {
    @Before("com.example.demo.aspect.PointcutConfig.serviceLayer()")
    public void logBefore(JoinPoint join) {
        System.out.println("Logging before method {}", join);
    }

    @Before("com.example.demo.aspect.PointcutConfig.repositoryLayer()")
    public void logBefore(JoinPoint join) {
        System.out.println("Logging before method {}", join);
    }
}
```